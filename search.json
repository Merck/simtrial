[{"path":"https://merck.github.io/simtrial/articles/discrepancy-between-simtrial-and-survival.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Note on potential discrepancies between simtrial and survdiff","text":"survival (base R) package, log-rank Cox estimation procedures apply (default) correction “fix” roundoff errors. implemented timefix option (default timefix = TRUE) via aeqSurv() function. However, simtrial package, (also Hmisc), correction implemented; Consequently, can discrepancies simtrial base R survival (survdiff(), coxph(), survfit()). details aeqSurv() function, see Therneau, 2016 ?aeqSurv function documentation. following, describe simulation scenario discrepancy generated illustrate discrepancies can resolved (desired) pre-processing survival times aeqSurv() thus replicating survdiff() coxph() default calculations. simulated dataset, two observations generated: Observation \\(=464\\) survival time \\(Y=0.306132722582\\). Observation \\(=516\\) survival time \\(Y=0.306132604679\\). Per aeqSurv(), times tied set \\(Y=0.306132604679\\). log-rank Cox estimates can therefore differ approaches without “timefix” correction.","code":"library(gsDesign) library(gsDesign2) library(dplyr) library(gt) library(simtrial) library(tidyr) library(survival)"},{"path":"https://merck.github.io/simtrial/articles/discrepancy-between-simtrial-and-survival.html","id":"scenario-definitions","dir":"Articles","previous_headings":"","what":"Scenario definitions","title":"Note on potential discrepancies between simtrial and survdiff","text":"define various true data generating model scenarios convert use gsDesign2. , using single scenario discrepancies found. just illustration inform user simtrial discrepancies can occur resolve via aeqSurv(), desired.","code":"survival_at_24_months <- 0.35 hr <- log(.35) / log(.25) control_median <- 12 control_rate <- c(log(2) / control_median, (log(.25) - log(.2)) / 12)  scenarios <- tribble(   ~Scenario, ~Name,           ~Period, ~duration, ~Survival,   0,         \"Control\",       0,       0,         1,   0,         \"Control\",       1,       24,        .25,   0,         \"Control\",       2,       12,        .2,   1,         \"PH\",            0,       0,         1,   1,         \"PH\",            1,       24,        .35,   1,         \"PH\",            2,       12,        .2^hr,   2,         \"3-month delay\", 0,       0,         1,   2,         \"3-month delay\", 1,       3,         exp(-3 * control_rate[1]),   2,         \"3-month delay\", 2,       21,        .35,   2,         \"3-month delay\", 3,       12,        .2^hr,   3,         \"6-month delay\", 0,       0,         1,   3,         \"6-month delay\", 1,       6,         exp(-6 * control_rate[1]),   3,         \"6-month delay\", 2,       18,        .35,   3,         \"6-month delay\", 3,       12,        .2^hr,   4,         \"Crossing\",      0,       0,         1,   4,         \"Crossing\",      1,       3,         exp(-3 * control_rate[1] * 1.3),   4,         \"Crossing\",      2,       21,        .35,   4,         \"Crossing\",      3,       12,        .2^hr,   5,         \"Weak null\",     0,       0,         1,   5,         \"Weak null\",     1,       24,        .25,   5,         \"Weak null\",     2,       12,        .2,   6,         \"Strong null\",   0,       0,         1,   6,         \"Strong null\",   1,       3,         exp(-3 * control_rate[1] * 1.5),   6,         \"Strong null\",   2,       3,         exp(-6 * control_rate[1]),   6,         \"Strong null\",   3,       18,        .25,   6,         \"Strong null\",   4,       12,        .2, ) # scenarios |> gt() fr <- scenarios |>   group_by(Scenario) |>   #  filter(Scenario == 2) |>   mutate(     Month = cumsum(duration),     x_rate = -(log(Survival) - log(lag(Survival, default = 1))) /       duration,     rate = ifelse(Month > 24, control_rate[2], control_rate[1]),     hr = x_rate / rate   ) |>   select(-x_rate) |>   filter(Period > 0, Scenario > 0) |>   ungroup() # fr |> gt() |> fmt_number(columns = everything(), decimals = 2)  fr <- fr |> mutate(fail_rate = rate, dropout_rate = 0.001, stratum = \"All\")  # MWLR mwlr <- fixed_design_mb(   tau = 12,   enroll_rate = define_enroll_rate(duration = 12, rate = 1),   fail_rate = fr |> filter(Scenario == 2),   alpha = 0.025, power = .85, ratio = 1,   study_duration = 36 ) |> to_integer()  er <- mwlr$enroll_rate"},{"path":"https://merck.github.io/simtrial/articles/discrepancy-between-simtrial-and-survival.html","id":"a-scenario-that-generates-a-discrepancy","dir":"Articles","previous_headings":"","what":"A scenario that generates a discrepancy","title":"Note on potential discrepancies between simtrial and survdiff","text":"Simulated dataset discrepancy logrank test simtrial::wlr() survdiff() (also compare score test coxph() [survdiff() default timefix = TRUE]). Verify timefix = FALSE coxph() agrees wlr(): Pre-processing survival times aeqSurv() implement timefix = TRUE procedure. Verify wlr() survdiff() now agree. differ (tte2 times aeqSurv())? Verify coxph() (default) coxph() aeqSurv() pre-processing (using tte2 outcome setting timefix = FALSE) identical: Also note ties impact separate arms. difference tte tte2 times, impact ties Cox \"breslow\" \"efron\" ties (single tie tte2) separate arms. Lastly, artificially change treatment two observations tied within treatment arm generates difference \"breslow\" \"efron\" options ties: ","code":"set.seed(3219)  dgm <- fr[c(14:17), ]  fail_rate <- data.frame(   stratum = rep(\"All\", 2 * nrow(dgm)),   period = rep(dgm$Period, 2),   treatment = c(     rep(\"control\", nrow(dgm)),     rep(\"experimental\", nrow(dgm))   ),   duration = rep(dgm$duration, 2),   rate = c(dgm$rate, dgm$rate * dgm$hr) )  dgm$stratum <- \"All\" # Constant dropout rate for both treatment arms and all scenarios dropout_rate <- data.frame(   stratum = rep(\"All\", 2),   period = rep(1, 2),   treatment = c(\"control\", \"experimental\"),   duration = rep(100, 2),   rate = rep(.001, 2) ) ss <- 395  set.seed(8316951 + ss * 1000)  # Generate a dataset dat <- sim_pw_surv(   n = 698,   enroll_rate = er,   fail_rate = fail_rate,   dropout_rate = dropout_rate )  analysis_data <- cut_data_by_date(dat, 36)  dfa <- analysis_data  dfa$treat <- ifelse(dfa$treatment == \"experimental\", 1, 0)  z1 <- dfa |> wlr(weight = fh(rho = 0, gamma = 0))  check <- survdiff(Surv(tte, event) ~ treat, data = dfa)  # Note, for `coxph()`, use # cph.score <- summary(coxph(Surv(tte, event) ~ treat, data = dfa, control = coxph.control(timefix = TRUE)))$sctest  cat(\"Log-rank wlr() vs survdiff()\", c(z1$z^2, check$chisq), \"\\n\") ## Log-rank wlr() vs survdiff() 0.1577428 0.1577954 cph.score <- summary(coxph(   Surv(tte, event) ~ treat,   data = dfa,   control = coxph.control(timefix = FALSE) ))$sctest cat(\"Log-rank wlr() vs Cox score z^2\", c(z1$z^2, cph.score[\"test\"]), \"\\n\") ## Log-rank wlr() vs Cox score z^2 0.1577428 0.1577428 Y <- dfa[, \"tte\"] Delta <- dfa[, \"event\"]  tfixed <- aeqSurv(Surv(Y, Delta)) Y <- tfixed[, \"time\"] Delta <- tfixed[, \"status\"] # Use aeqSurv version dfa$tte2 <- Y dfa$event2 <- Delta  # wlr() after \"timefix\" dfa2 <- dfa dfa2$tte <- dfa2$tte2 dfa2$event <- dfa2$event2 z1new <- dfa2 |> wlr(weight = fh(rho = 0, gamma = 0)) cat(\"Log-rank wlr() with timefix vs survdiff() z^2\", c(z1new$z^2, check$chisq), \"\\n\") ## Log-rank wlr() with timefix vs survdiff() z^2 0.1577954 0.1577954 dfa <- dfa[order(dfa$tte2), ]  id <- seq(1, nrow(dfa))  diff <- exp(dfa$tte) - exp(dfa$tte2) id_diff <- which(abs(diff) > 0)  tolook <- seq(id_diff - 2, id_diff + 2)  dfcheck <- dfa[tolook, c(\"tte\", \"tte2\", \"event\", \"event2\", \"treatment\")] print(dfcheck, digits = 12) ##                tte           tte2 event event2    treatment ## 13  0.276251560170 0.276251560170     1      1 experimental ## 143 0.298789385712 0.298789385712     1      1      control ## 464 0.306132722582 0.306132604679     1      1      control ## 516 0.306132604679 0.306132604679     1      1 experimental ## 605 0.336489970678 0.336489970678     1      1 experimental # Check Cox with ties cox_breslow <- summary(coxph(Surv(tte, event) ~ treatment, data = dfa, ties = \"breslow\"))$conf.int cox_efron <- summary(coxph(Surv(tte, event) ~ treatment, data = dfa, ties = \"efron\"))$conf.int cat(\"Cox Breslow and Efron hr (tte, timefix=TRUE):\", c(cox_breslow[1], cox_efron[1]), \"\\n\") ## Cox Breslow and Efron hr (tte, timefix=TRUE): 0.9657106 0.9657106 # Here ties do not have impact because in separate arms cox_breslow <- summary(coxph(Surv(tte2, event2) ~ treatment, data = dfa, ties = \"breslow\", control = coxph.control(timefix = FALSE)))$conf.int cox_efron <- summary(coxph(Surv(tte2, event2) ~ treatment, data = dfa, ties = \"efron\", control = coxph.control(timefix = FALSE)))$conf.int cat(\"Cox Breslow and Efron hr (tte2, timefix=FALSE):\", c(cox_breslow[1], cox_efron[1]), \"\\n\") ## Cox Breslow and Efron hr (tte2, timefix=FALSE): 0.9657106 0.9657106 # Create tie within treatment arm by changing treatment dfa3 <- dfa dfa3[19, \"treat\"] <- 1.0  cox_breslow <- summary(coxph(Surv(tte, event) ~ treat, data = dfa3, ties = \"breslow\", control = coxph.control(timefix = TRUE)))$conf.int cox_efron <- summary(coxph(Surv(tte, event) ~ treat, data = dfa3, ties = \"efron\", control = coxph.control(timefix = TRUE)))$conf.int cat(\"Cox Breslow and Efron hr (tte, timefix=TRUE)=\", c(cox_breslow[1], cox_efron[1]), \"\\n\") ## Cox Breslow and Efron hr (tte, timefix=TRUE)= 0.9729723 0.9729778 cox_breslow <- summary(coxph(Surv(tte2, event2) ~ treat, data = dfa3, ties = \"breslow\", control = coxph.control(timefix = FALSE)))$conf.int cox_efron <- summary(coxph(Surv(tte2, event2) ~ treat, data = dfa3, ties = \"efron\", control = coxph.control(timefix = FALSE)))$conf.int cat(\"Cox Breslow and Efron hr (tte2, timefix=FALSE)=\", c(cox_breslow[1], cox_efron[1]), \"\\n\") ## Cox Breslow and Efron hr (tte2, timefix=FALSE)= 0.9729723 0.9729778"},{"path":"https://merck.github.io/simtrial/articles/maxcombo.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"vignette demonstrates use simple routine simulations testing using Fleming-Harrington weighted logrank tests MaxCombo test. addition, demonstrate perform tests dataset generated simulation routines within package. Note \\(p\\)-values computed one-sided small values indicating experimental treatment favored.","code":""},{"path":"https://merck.github.io/simtrial/articles/maxcombo.html","id":"defining-the-test","dir":"Articles","previous_headings":"","what":"Defining the test","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"MaxCombo test posed maximum multiple Fleming-Harrington weighted logrank tests (Harrington Fleming (1982), Fleming Harrington (2011)). Combination tests looking maximum selected tests class also proposed; see Lee (2007), Roychoudhury et al. (2021), Lin et al. (2020). Fleming-Harrington class indexed parameters \\(\\rho \\geq 0\\) \\(\\gamma \\geq 0\\). denote FH(\\(\\rho, \\gamma\\)). class includes logrank test FH(0, 0). tests interest include: FH(0, 1): test -weights early events FH(1, 0): test -weights late events FH(1, 1): test -weights events increasingly quantiles differ median","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/maxcombo.html","id":"generating-test-statistics-with-sim_fixed_n","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Generating test statistics with sim_fixed_n()","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"begin single trial simulation generated routine sim_fixed_n() using default arguments routine. sim_fixed_n() produces one record per test data cutoff method per simulation. choose 3 tests (logrank = FH(0, 0), FH(0, 1) FH(1, 1)). one test chosen correlation tests computed shown Karrison (2016), case columns V1, V2, V3. columns rho, gamma indicate \\(\\rho\\) \\(\\gamma\\) used compute test. z FH(\\(\\rho, \\gamma\\)) normal test statistic variance 1 negative value favoring experimental treatment. variable cut indicates data cut analysis, case maximum targeted minimum follow-last enrollment date targeted event count reached. Sim sequential index simulations performed.","code":"library(simtrial) library(knitr) library(dplyr) library(gt) set.seed(123)  x <- sim_fixed_n(   n_sim = 1,   timing_type = 5,   rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 1)) ) #> Backend uses sequential processing.  x |>   gt() |>   fmt_number(columns = c(\"ln_hr\", \"z\", \"duration\", \"v1\", \"v2\", \"v3\"), decimals = 2)"},{"path":"https://merck.github.io/simtrial/articles/maxcombo.html","id":"generating-data-with-sim_pw_surv","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Generating data with sim_pw_surv()","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"begin another simulation generated sim_pw_surv(). , use defaults routine. generated, need cut data analysis. cut 75 events. Now can analyze data. begin s show can done single line. case, use 4 test combination suggested Lin et al. (2020), Roychoudhury et al. (2021). Suppose want \\(p\\)-value just based logrank FH(0, 1) FH(1, 0) suggested Lee (2007). remove rows columns associated FH(0, 0) FH(1, 1) apply pvalue_maxcombo().","code":"set.seed(123)  s <- sim_pw_surv(n = 100)  s |>   head() |>   gt() |>   fmt_number(columns = c(\"enroll_time\", \"fail_time\", \"dropout_time\", \"cte\"), decimals = 2) x <- s |> cut_data_by_event(75)  x |>   head() |>   gt() |>   fmt_number(columns = \"tte\", decimals = 2) z <- s |>   cut_data_by_event(75) |>   maxcombo(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1))  z #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 0) + FH(0, 1) + FH(1, 0) + FH(1, 1)\" #>  #> $z #> [1] -2.511925 -2.907093 -1.899871 -3.119549 #>  #> $p_value #> [1] 0.00204688 z <- s |>   cut_data_by_event(75) |>   maxcombo(rho = c(0, 1), gamma = c(1, 0))  z #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 1) + FH(1, 0)\" #>  #> $z #> [1] -2.907093 -1.899871 #>  #> $p_value #> [1] 0.003395849"},{"path":"https://merck.github.io/simtrial/articles/maxcombo.html","id":"using-survival-data-in-another-format","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Using survival data in another format","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"trial generated sim_fixed_n(), process slightly involved. consider survival data simtrial format show transformation needed. case use small aml dataset survival package. rename variables create stratum variable follows: Now analyze data MaxCombo logrank FH(0, 1) compute \\(p\\)-value.","code":"library(survival) aml |>   head() |>   gt() x <- aml |> transmute(   tte = time,   event = status,   stratum = \"All\",   treatment = case_when(     x == \"Maintained\" ~ \"experimental\",     x == \"Nonmaintained\" ~ \"control\"   ) )  x |>   head() |>   gt() x |> maxcombo(rho = c(0, 0), gamma = c(0, 1)) #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 0) + FH(0, 1)\" #>  #> $z #> [1] -1.842929 -1.621762 #>  #> $p_value #> [1] 0.0491509"},{"path":"https://merck.github.io/simtrial/articles/maxcombo.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"now consider example simulation pvalue_maxcombo() help file demonstrate simulate power MaxCombo test. However, increase number simulations 100 case; larger number used (e.g., 1000) better estimate design properties. test \\(\\alpha=0.001\\) level. note use group_map produces list \\(p\\)-values simulation. nice something worked like dplyr::summarize() avoid unlist() allow evaluating, say, multiple data cutoff methods. latter can done without re-run simulations follows, demonstrated smaller number simulations. Now compute \\(p\\)-value separately cut type, first targeted event count. Now use later targeted events minimum follow-cutoffs.","code":"set.seed(123)  # Only use cut events + min follow-up x <- sim_fixed_n(   n_sim = 100,   timing_type = 5,   rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 1)) )  # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up x |>   group_by(sim) |>   filter(row_number() == 1) |>   ungroup() |>   summarize(power = mean(p_value < .001)) #> # A tibble: 1 × 1 #>   power #>   <dbl> #> 1  0.79 # Only use cuts for events and events + min follow-up set.seed(123)  x <- sim_fixed_n(   n_sim = 100,   timing_type = c(2, 5),   rho_gamma = data.frame(rho = 0, gamma = c(0, 1)) ) # Subset to targeted events cutoff tests # This chunk will be updated after the development of sim_gs_n and sim_fixed_n x |>   filter(cut == \"Targeted events\") |>   group_by(sim) |>   filter(row_number() == 1) |>   ungroup() |>   summarize(power = mean(p_value < .025)) #> # A tibble: 1 × 1 #>   power #>   <dbl> #> 1  0.95 # Subset to targeted events cutoff tests x |>   filter(cut != \"Targeted events\") |>   group_by(sim) |>   filter(row_number() == 1) |>   ungroup() |>   summarize(power = mean(p_value < .025)) #> # A tibble: 1 × 1 #>   power #>   <dbl> #> 1  0.95"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using the Magirr-Burman weights for testing","text":"Magirr Burman (2019) implemented modestly weighted logrank test following claim: Tests new class can constructed high power delayed-onset treatment effect scenario, well almost efficient standard logrank test proportional hazards. implemented package modestWLRT. Since implementation relatively straightforward, added functionality simtrial package explain use mb_weight() function. Packages used follows:","code":"library(simtrial) library(dplyr) library(survival)"},{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"simulating-a-delayed-effect-example","dir":"Articles","previous_headings":"","what":"Simulating a delayed effect example","title":"Using the Magirr-Burman weights for testing","text":"First, specify study duration, sample size enrollment rates. enrollment rate assumed constant enrollment period targeted sample size reached. failure rates, consider delayed treatment effect example Magirr Burman (2019). control group exponential failure rate median 15 months. initial 6 months, underlying hazard ratio one followed hazard ratio 0.7 thereafter. differs Magirr Burman (2019) delayed effect assumptions assume hazard ratio 0.5 6 months. Now generate single dataset characteristics cut data analysis 36 months post start enrollment. plot Kaplan-Meier curves resulting dataset (red curve experimental treatment, black control):","code":"study_duration <- 36 sample_size <- 300 enroll_rate <- data.frame(duration = 12, rate = 200 / 12) fail_rate <- data.frame(   stratum = c(\"All\", \"All\"),   duration = c(6, 36),   fail_rate = c(log(2) / 15, log(2) / 15),   hr = c(1, .7),   dropout_rate = c(0, 0) ) set.seed(7789) xpar <- to_sim_pw_surv(fail_rate) MBdelay <- sim_pw_surv(   n = sample_size,   stratum = data.frame(stratum = \"All\", p = 1),   block = c(rep(\"control\", 2), rep(\"experimental\", 2)),   enroll_rate = enroll_rate,   fail_rate = xpar$fail_rate,   dropout_rate = xpar$dropout_rate ) |>   cut_data_by_date(study_duration) fit <- survfit(Surv(tte, event) ~ treatment, data = MBdelay) plot(fit, col = 1:2, mark = \"|\", xaxt = \"n\") axis(1, xaxp = c(0, 36, 6))"},{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"generalizing-the-magirr-burman-test","dir":"Articles","previous_headings":"","what":"Generalizing the Magirr-Burman test","title":"Using the Magirr-Burman weights for testing","text":"Next, consider Magirr (2021) extension modestly weighted logrank test (MWLRT) Magirr Burman (2019) weights follows: \\[w(t, \\tau, w_{\\max}) = \\min\\left(w_{\\max},\\left(\\frac{1}{S(\\min(t,\\tau))}\\right)\\right).\\] requires generating weights computing test. begin default w_max=Inf corresponds original Magirr Burman (2019) test set time maximum weight \\(\\tau\\) delay = 6. Now set maximum weight 2 Magirr (2021) set delay=Inf maximum weight begins observed median observed combined treatment Kaplan-Meier curve. Another way can done generalized Fleming-Harrington test \\[w(t; \\rho, \\gamma, w_{\\max})= \\min((1-F(t))^\\rho F(t)^\\gamma, w_{\\max})).\\] let \\(\\gamma=0, \\rho = -1/2.\\)","code":"ZMB <- MBdelay |>   wlr(weight = mb(delay = 6)) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$z, lower.tail = FALSE) #> [1] 0.1395378 ZMB <- MBdelay |>   wlr(weight = mb(delay = Inf, w_max = 2)) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$z, lower.tail = FALSE) #> [1] 0.1387672 w_max <- 2 Z_modified_FH <- MBdelay |>   counting_process(arm = \"experimental\") |>   mutate(w = pmin(w_max, 1 / s)) |>   summarize(     S = sum(o_minus_e * w),     V = sum(var_o_minus_e * w^2),     z = S / sqrt(V)   ) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(Z_modified_FH$z) #> [1] 0.1387672"},{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"freidlin-and-korn-strong-null-hypothesis-example","dir":"Articles","previous_headings":"Generalizing the Magirr-Burman test","what":"Freidlin and Korn strong null hypothesis example","title":"Using the Magirr-Burman weights for testing","text":"next example, underlying survival uniformly worse experimental group compared control throughout planned follow-. presented Freidlin Korn (2019). case, hazard ratio 16 1/10 1 year (1.2 months), followed hazard ratio 0.76 thereafter. First, specify study duration, sample size enrollment rates. enrollment rate assumed constant enrollment period targeted sample size reached. failure rates, consider delayed treatment effect example Magirr Burman (2019). Now generate single dataset characteristics cut data analysis 5 years post start enrollment. plot Kaplan-Meier curves resulting dataset (red curve experimental treatment, black control):  perform logrank weighted logrank tests suggested limited downweighting follows, MaxCombo test component tests, p-value : Next, consider Magirr Burman (2019) modestly weighted logrank test -weighting specified first 6 months maximum weight 2. requires generating weights computing test. Finally, consider weighted logrank tests less -weighting. Results quite similar results greater -weighting. p-value Thus, less -weighting MaxCombo test appears less problematic. addressed greater length Mukhopadhyay et al. (2022).","code":"study_duration <- 5 sample_size <- 2000 enroll_duration <- .0001 enroll_rate <- data.frame(   duration = enroll_duration,   rate = sample_size / enroll_duration ) fail_rate <- data.frame(   stratum = \"All\",   fail_rate = 0.25,   dropout_rate = 0,   hr = c(4 / .25, .19 / .25),   duration = c(.1, 4.9) ) set.seed(7783) xpar <- to_sim_pw_surv(fail_rate) FHwn <- sim_pw_surv(   n = sample_size,   stratum = data.frame(stratum = \"All\", p = 1),   block = c(rep(\"control\", 2), rep(\"experimental\", 2)),   enroll_rate = enroll_rate,   fail_rate = xpar$fail_rate,   dropout_rate = xpar$dropout_rate ) |>   cut_data_by_date(study_duration) fit <- survfit(Surv(tte, event) ~ treatment, data = FHwn) plot(fit, col = 1:2, mark = \"|\", xaxt = \"n\") axis(1, xaxp = c(0, 36, 6)) xx <- FHwn |>   maxcombo(rho = c(0, 0, 1), gamma = c(0, 1, 1)) xx #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 0) + FH(0, 1) + FH(1, 1)\" #>  #> $z #> [1]  4.808526 -3.204735 -1.220445 #>  #> $p_value #> [1] 0.001256683 ZMB <- FHwn |>   wlr(weight = mb(delay = 6, w_max = 2))  # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$z, lower.tail = FALSE) #> [1] 0.920727 xx <- FHwn |>   maxcombo(rho = c(0, 0, .5), gamma = c(0, .5, .5)) xx #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 0) + FH(0, 0.5) + FH(0.5, 0.5)\" #>  #> $z #> [1]  4.8085258 -0.6919228  0.9278452 #>  #> $p_value #> [1] 0.2915952"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Simulating time-to-event trials in parallel","text":"vignette demonstrates ability implement sim_fixed_n() using user-defined backends parallelize simulations. consider backends supported future framework. backends supported future package include: sequential - default non-parallel backend. multisession - uses multiple background R sessions single machine. multicore - uses multiple forked R processes single non-Windows machine outside RStudio. cluster - supports external R sessions across multiple machines. can also choose backend types supported additional future extension packages, HPC job scheduler backends future.batchtools. function sim_fixed_n() provides simulation workflow two-arm trial single endpoint. can vary parameters trial using different functions outlined documentation. function now provides users opportunity implement simulations using previously described parallel backends accelerate computation. function sim_gs_n() simulates group sequential designs fixed sample size also supports use user-defined backends parallelize simulations similar manner.","code":""},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Simulating time-to-event trials in parallel","text":"Without specifying backend, sim_fixed_n() execute sequentially. sequential execution run n_sim iterations within process session R. order execute parallel, must define environment prior calling function. Setting seed prior calling function ensure results reproducible. Suppose want investigate duration trial two possible enrollments strategies. enrollments piecewise, varying durations rates.  see Enrollment 2 enrolls individuals quickly Enrollment 1 onset. Later, Enrollment 1 outpace Enrollment 2 eventually overtaken . , want consider duration study changes enrollments.","code":"library(simtrial) library(future) library(doFuture) set.seed(1)  n <- 5000 enroll_rate1 <- data.frame(rate = c(5, 20, 10), duration = c(100, 150, 150)) enroll_rate2 <- data.frame(rate = c(10, 15, 30), duration = c(150, 175, 75)) x1 <- rpwexp_enroll(n = n, enroll_rate = enroll_rate1) x2 <- rpwexp_enroll(n = n, enroll_rate = enroll_rate2)  plot(   x1, 1:n,   type = \"l\",   col = palette()[4],   xlim = c(0, max(x1, x2)),   main = \"Piecewise enrollments\",   xlab = \"Time\",   ylab = \"Enrollment\" ) lines(x2, 1:n, col = palette()[7]) legend(   250, 1500,   legend = c(\"Enrollment 1\", \"Enrollment 2\"),   col = c(palette()[4], palette()[7]),   lty = c(1, 1) )"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"the-sequential-run","dir":"Articles","previous_headings":"","what":"The sequential run","title":"Simulating time-to-event trials in parallel","text":"Naively, can execute simulations sequentially. set target total enrollment 3000 individuals trial ending observing 700 events. use timing_type = 2 return correct trial duration. Note: manually set number threads used {data.table} operations 1. purely sake comparing runtime parallel run performed later vignette. running simulations sequentially, want {data.table} take advantage parallel processing. message automatically appears console indicates backend used processing. calls proc.time() allow us evaluate computation time procedures. function provides three outputs, focus user elapsed time. User time represents CPU time spent evaluating function elapsed time represents “wall clock” time spent end user waiting results. can see CPU time 10.41 elapsed time 10.47 seconds. provide baseline computation time. may anticipated, see lower number events, enrollment 2 shorter average duration 99.8 enrollment 1, 131.2.","code":"data.table::setDTthreads(threads = 1) set.seed(1)  n_sim <- 200  start_sequential <- proc.time()  seq_result1 <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate1,   timing_type = 2 # Time until targeted event count achieved ) #> Backend uses sequential processing.  seq_result2 <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate2,   timing_type = 2 # Time until targeted event count achieved ) #> Backend uses sequential processing.  duration_sequential <- proc.time() - start_sequential print(duration_sequential) #>    user  system elapsed  #>  10.413   0.053  10.469"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"setting-up-a-parallel-backend","dir":"Articles","previous_headings":"","what":"Setting up a parallel backend","title":"Simulating time-to-event trials in parallel","text":"increased number simulations enrollment, can expect time run simulations increase. Furthermore, vary increase number parameter inputs consider, expect simulation process continue increase duration. help combat growing computational burden, can run simulations parallel using multisession backend available us plan(). can adjust default number cores function parallelly::availableCores(). multisession backend automatically use available cores default, use two. initialize backend, change plan.","code":"plan(multisession, workers = 2)"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"execution-in-parallel","dir":"Articles","previous_headings":"","what":"Execution in parallel","title":"Simulating time-to-event trials in parallel","text":"configured backend details, can execute code automatically distribute n_sim simulations across available cores. Note: worry setting data.table::setDTthreads(threads = 1) parallel processes spawned sim_fixed_n() {data.table} “automatically switches single threaded mode upon fork” (?data.table::setDTthreads). 1 can see CPU time 2.23 elapsed time 9.03 seconds. user time appears drastically reduced R keeps track time; time used parent process children processes reported user time. Therefore, compare elapsed time see real-world impact parallelization. change implementation back sequential backend, simply use . can also verify simulation results identical setting seed backend type affect results. , clear results sequential multisession backends match completely. Note: parallel implementation may always faster serial implementation. substantial overhead associated executing parallel, sequential evaluation may faster. low number simulations available cores, may preferable continue computation serial rather parallel. leave end user determine difference based resources available .","code":"set.seed(1)  start_parallel <- proc.time()  par_result1 <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate1,   timing_type = 2 # Time until targeted event count achieved ) #> Using 2 cores with backend multisession  par_result2 <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate2,   timing_type = 2 # Time until targeted event count achieved ) #> Using 2 cores with backend multisession  duration_parallel <- proc.time() - start_parallel print(duration_parallel) #>    user  system elapsed  #>   2.228   0.025   9.026 plan(sequential) all.equal(seq_result1, par_result1) #> [1] TRUE all.equal(seq_result2, par_result2) #> [1] TRUE"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"a-nested-parallel-example","dir":"Articles","previous_headings":"","what":"A nested parallel example","title":"Simulating time-to-event trials in parallel","text":"provide additional example using nested parallel structure users extensive resources, high-performance computing clusters, available . resources commonly available, execute code herein. Consider two accessible nodes, three cores (shown diagram ). Available resource schematic. Ideally, available resources used executing simulations. , need correctly define backend using plan() run code previously. different structures, topologies, backend can changed depth explanation given future topologies vignette. example follows closely example. snippet, consider two nodes named n1 n2 create function select number cores use named nodes. trivial , courteous user shared machines specify fewer available cores can using modification code. implement backend using list follows hierarchy available resources. function tweak() necessary override inherent protection nested parallelism, meant help avoid overloading one’s resources errantly starting many processes. need tweak backends, message echoed console nested backends reflects highest level nested hierarchy. backend place, can run identical code using available resources return results . , reset plan sequential avoid accidentally continuing execute later calls within resources.","code":"nodes <- c(\"n1\", \"n2\") custom_cores <- function() {   switch(Sys.info()[[\"nodename\"]],     \"n1\" = 3L, # Modify here for number of cores on node1     \"n2\" = 3L, # Modify here for number of cores on node2     ## Default:     availableCores()   ) } plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = custom_cores) )) set.seed(1)  enroll_rates <- list(enroll_rate1, enroll_rate2)  nested_result <- foreach::foreach(   i = 1:2,   .combine = \"list\",   .options.future = list(seed = TRUE) ) %dofuture% {   sim_fixed_n(     n_sim = n_sim,     sample_size = 3000,     target_event = 700,     enroll_rate = enroll_rates[[i]],     timing_type = 2 # Time until targeted event count achieved   ) } plan(sequential)"},{"path":"https://merck.github.io/simtrial/articles/rmst.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Restricted mean survival time (RMST)","text":"Restricted mean survival time (RMST) defined area survival curve specific time point. can interpreted average survival time defined time period ranging time 0 specific follow-time point, straightforward clinically meaningful way interpret contrast survival groups. RMST may provide valuable information comparing two survival curves proportional hazards assumption met, cases crossing delayed separation survival curves.","code":""},{"path":"https://merck.github.io/simtrial/articles/rmst.html","id":"rmst-vs--logrank","dir":"Articles","previous_headings":"","what":"RMST vs. logrank","title":"Restricted mean survival time (RMST)","text":"log-rank test calculates test statistics using survival rate time point, summarizes test equality survival curves whole entire follow-period. comparison RMST two survival curves provides estimate duration time gained lost associated exposure. Although RMST advantage hazard ratio, previous study showed difference RMST often operating characteristics similar log-rank test proportional hazards assumption (Royston Parmar 2013). However, case crossing survival curves, efficacy intervention may demonstrated showing difference RMST two curves, although log-rank test may fail detect difference occurrence non-proportional hazards.","code":""},{"path":"https://merck.github.io/simtrial/articles/rmst.html","id":"estimation-of-rmst-in-a-single-arm-at-a-single-time-point","dir":"Articles","previous_headings":"","what":"Estimation of RMST in a single arm at a single time point","title":"Restricted mean survival time (RMST)","text":"Assume event time \\(T\\), survival function \\(S(t) = Pr(T>t)\\). restricted mean survival time pre-specified cutoff time point \\(\\tau\\) \\[   \\text{RMST}(\\tau) = E[\\min (T, \\tau)] = \\int_{0}^{\\tau} S(u) d u. \\] Suppose \\(D\\) events, distinct observed event times \\(t_1 < t_2 < \\ldots <t_D\\). \\(= 1, \\ldots, D\\), let \\(Y_i\\) number risk just prior \\(t_i\\), let \\(d_i\\) number subjects fail \\(t_i\\). Kaplan-Meier (product-limit) estimate survival function \\(t_i\\) \\[   \\hat{S}(t_i)   =   \\prod_{j=1}^{}   \\left(     1-\\frac{d_{j}}{Y_{j}}   \\right) \\] Based definition formula , \\(\\text{RMST}(\\tau)\\) can estimated \\[   \\widehat{\\text{RMST}}(\\tau)   =   \\int_{0}^{\\tau} \\hat{S}(t) d t   =   \\sum_{=1}^{L_{\\tau}} \\hat{S}\\left(t_{-1}\\right)\\left(t_{}-t_{-1}\\right)   +   \\hat{S}\\left(t_{L_{\\tau}}\\right)\\left(\\tau-t_{L_{\\tau}}\\right), \\] \\(L_{\\tau}\\) number \\(t_i\\) values less \\(\\tau\\). standard error \\(\\widehat{\\text{RMST}}(\\tau)\\) can estimated \\[   \\hat{\\sigma}   =   \\widehat{\\text{Var}}(\\widehat{\\text{RMST}}(\\tau))   =   \\sqrt{\\sum_{=1}^{L_\\tau}   \\frac{d_{} A_{}^{2}}{Y_{}\\left(Y_{}-d_{}\\right)}} \\] \\[   A_{}   =   \\int_{t_i}^{\\tau} \\hat{S}(t) d t   =   \\sum_{j=}^{L_\\tau}   \\hat{S}(t_{j}) (t_{j+1}-t_{j})   +   \\hat{S}(t_{L_\\tau})(\\tau-t_{L_\\tau}) \\] \\(m=\\sum_{j=1}^{L_\\tau} d_{j}\\). \\((1-\\alpha)\\) confidence interval \\(\\text{RMST}\\) can calculated \\[   \\left[     \\widehat{\\operatorname{RMST}}(\\tau) - z_{\\alpha/2}\\hat{\\sigma},     \\;\\;     \\widehat{\\operatorname{RMST}}(\\tau) + z_{\\alpha/2}\\hat{\\sigma}   \\right] \\] \\(\\alpha\\) predefined significant level, \\(z_{\\alpha/2}\\) upper \\(1-\\alpha/2\\) critical value standard normal distribution.","code":"# Simulate NPH data from the piecewise model library(simtrial) # Table display library(gt) data(ex1_delayed_effect) data_single_arm <- ex1_delayed_effect[ex1_delayed_effect$trt == 1, ] simtrial:::rmst_single_arm(   time_var = data_single_arm$month,   event_var = data_single_arm$evntd,   tau = 10 ) |> gt()"},{"path":"https://merck.github.io/simtrial/articles/rmst.html","id":"estimation-of-rmst-differences-in-2-arms-at-a-single-time-point","dir":"Articles","previous_headings":"Estimation of RMST in a single arm at a single time point","what":"Estimation of RMST differences in 2 arms at a single time point","title":"Restricted mean survival time (RMST)","text":"Let \\(\\text{RMST}_{1}(\\tau)\\) \\(\\text{RMST}_{2}(\\tau)\\) RMST treatment group 1 2 predefined time \\(\\tau\\), RMST difference 2 treatment groups (\\(\\theta\\)) can defined \\[   \\theta = \\text{RMST}_1(\\tau) - \\text{RMST}_2(\\tau). \\] expected value \\(\\theta\\) \\(E(\\theta) = E[\\text{RMST}_{1}(\\tau)] - E[\\text{RMST}_{2}(\\tau)]\\). two treatment groups independent, variance \\(\\theta\\) \\[   \\text{Var}(\\theta) = \\sigma_{1}^{2} + \\sigma_{2}^{2} \\] Similarly, \\((1-\\alpha)\\) confidence interval RMST difference 2 groups can calculated : \\[   \\left[     \\hat{\\theta} - z_{\\alpha/2}\\sqrt{\\hat{\\sigma}_1^2 + \\hat{\\sigma}_2^2},     \\;\\;     \\hat{\\theta} + z_{\\alpha/2}\\sqrt{\\hat{\\sigma}_1^2 + \\hat{\\sigma}_2^2}   \\right]. \\] R package survRM2 (Uno et al. 2022) performs two-sample comparisons using RMST summary measure survival time distribution. Three kinds -group contrast metrics (.e., difference RMST, ratio RMST ratio restricted mean time lost (RMTL)) computed. performs ANCOVA-type covariate adjustment well unadjusted analyses measures. use R package validation simtrial::rmst().","code":"tau <- 10  data(ex1_delayed_effect)  ex1_delayed_effect |>   rmst(     var_label_tte = \"month\",     var_label_event = \"evntd\",     var_label_group = \"trt\",     tau = 10,     reference = \"0\"   ) #> $method #> [1] \"RMST\" #>  #> $parameter #> [1] 10 #>  #> $estimate #> [1] 0.8650493 #>  #> $se #> [1] 0.3900344 #>  #> $z #> [1] 2.21788 verify <- survRM2::rmst2(   time = ex1_delayed_effect$month,   status = ex1_delayed_effect$evntd,   arm = ex1_delayed_effect$trt,   tau = tau,   alpha = 0.05 )  verify$RMST.arm1$rmst[1] - verify$RMST.arm0$rmst[1] #>      Est.  #> 0.8650493"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Basic tools for time-to-event trial simulation and testing","text":"vignette demonstrates lower-level routines simtrial package specifically related trial generation statistical testing. routines follows: randomize_by_fixed_block() - fixed block randomization rpwexp_enroll() - random inter-arrival times piecewise constant enrollment rates rpwexp() - piecewise exponential failure rate generation cut_data_by_date() - cut data analysis specified calendar time cut_data_by_event() - cut data analysis specified event count, including ties cutoff date get_cut_date_by_event() - find date event count reached counting_process() - pre-process survival data counting process format Application demonstrated using higher-level routines sim_pw_surv() sim_fixed_n() generate simulations weighted logrank analysis stratified design. intent write routines spirit tidyverse approach (alternately referred data wrangling, tidy data, R Data Science, split-apply-combine). objectives easily documentable validated package easy use efficient broadly-useful tool simulation time--event clinical trials. package extended many ways future, including: Weighted logrank weighted Kaplan-Meier analyses One-step, hazard ratio estimator (first-order approximation PH) Randomization schemes stratified, fixed-block Poisson mixture survival distribution generation","code":"library(simtrial) library(gt) library(dplyr)"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"randomization","dir":"Articles","previous_headings":"","what":"Randomization","title":"Basic tools for time-to-event trial simulation and testing","text":"Fixed block randomization arbitrary block contents performed demonstrated . case block size 5 one string repeated twice block three strings appearing . normally, default blocks size four:","code":"randomize_by_fixed_block(n = 10, block = c(\"A\", \"Dog\", \"Cat\", \"Cat\")) #>  [1] \"A\"   \"Dog\" \"Cat\" \"Cat\" \"Dog\" \"Cat\" \"A\"   \"Cat\" \"Cat\" \"Dog\" randomize_by_fixed_block(n = 20) #>  [1] 0 0 1 1 1 0 0 1 0 1 0 1 1 0 0 1 1 1 0 0"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"enrollment","dir":"Articles","previous_headings":"","what":"Enrollment","title":"Basic tools for time-to-event trial simulation and testing","text":"Piecewise constant enrollment can randomly generated follows. Note duration specifies interval durations constant rates; final rate extended long needed generate specified number observations.","code":"rpwexp_enroll(   n = 20,   enroll_rate = data.frame(     duration = c(1, 2),     rate = c(2, 5)   ) ) #>  [1] 0.4321713 1.1920483 1.3606775 1.4337998 1.9976912 2.2833587 2.3205687 #>  [8] 2.3603258 2.4128677 2.5312003 2.5393496 2.8971532 3.0539522 3.2447750 #> [15] 3.6015153 3.6141447 3.7810793 4.2056592 4.4276540 4.5577338"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"time-to-event-and-time-to-dropout","dir":"Articles","previous_headings":"","what":"Time-to-event and time-to-dropout","title":"Basic tools for time-to-event trial simulation and testing","text":"Time--event time--dropout random number generation observations generated piecewise exponential failure times. large number observations, log-plot time--failure","code":"x <- rpwexp(   10000,   fail_rate = data.frame(     rate = c(1, 3, 10),     duration = c(.5, .5, 1)   ) ) plot(   sort(x),   (10000:1) / 10001,   log = \"y\",   main = \"PW Exponential simulated survival curve\",   xlab = \"Time\", ylab = \"P{Survival}\" )"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"generating-a-trial","dir":"Articles","previous_headings":"","what":"Generating a trial","title":"Basic tools for time-to-event trial simulation and testing","text":"Ideally, might done routine generation randomization, time--event data done modular fashion plugged general trial generation routine. now, stratified randomization, piecewise constant enrollment, fixed block randomization piecewise exponential failure rates support flexible set trial generation options time--event endpoint trials. present, follow format carefully little checking input developed -date. methods used demonstrated , combined single routine generate trial. Note generated output dataset, cte calendar time event dropout, whichever comes first, fail indicator cte represents event time. First set input variables make later call sim_pw_surv() straightforward read.","code":"stratum <- data.frame(stratum = c(\"Negative\", \"Positive\"), p = c(.5, .5))  block <- c(rep(\"control\", 2), rep(\"experimental\", 2))  enroll_rate <- data.frame(rate = c(3, 6, 9), duration = c(3, 2, 1))  fail_rate <- data.frame(   stratum = c(rep(\"Negative\", 4), rep(\"Positive\", 4)),   period = rep(1:2, 4),   treatment = rep(c(rep(\"control\", 2), rep(\"experimental\", 2)), 2),   duration = rep(c(3, 1), 4),   rate = log(2) / c(4, 9, 4.5, 10, 4, 9, 8, 18) ) dropout_rate <- data.frame(   stratum = c(rep(\"Negative\", 4), rep(\"Positive\", 4)),   period = rep(1:2, 4),   treatment = rep(c(rep(\"control\", 2), rep(\"experimental\", 2)), 2),   duration = rep(c(3, 1), 4),   rate = rep(c(.001, .001), 4) ) x <- sim_pw_surv(   n = 400,   stratum = stratum,   block = block,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   dropout_rate = dropout_rate )  head(x) |>   gt() |>   fmt_number(columns = c(\"enroll_time\", \"fail_time\", \"dropout_time\", \"cte\"), decimals = 2)"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"cutting-data-for-analysis","dir":"Articles","previous_headings":"","what":"Cutting data for analysis","title":"Basic tools for time-to-event trial simulation and testing","text":"two ways cut data generated dataset x . first uses calendar cutoff date. output includes time randomization event dropout (tte), indicator represents event (event), stratum observation generated (stratum) treatment group assigned (treatment). Observations enrolled input cut_date deleted events censoring x cut_date censored specified cut_date. instance, wish cut entire dataset 50 events observed Positive stratum can use get_cut_date_by_event function follows: Perhaps common way cut data event count overall population, done using cut_data_by_event function. Note tied events date cte count reached, included. Also, count never reached, event times included cut - indication error.","code":"y <- cut_data_by_date(x, cut_date = 5)  head(y) |>   gt() |>   fmt_number(columns = \"tte\", decimals = 2) cut50Positive <- get_cut_date_by_event(filter(x, stratum == \"Positive\"), 50) y50Positive <- cut_data_by_date(x, cut50Positive)  with(y50Positive, table(stratum, event)) #>           event #> stratum     0  1 #>   Negative 41 53 #>   Positive 46 50 y150 <- cut_data_by_event(x, 150) table(y150$event, y150$treatment) #>     #>     control experimental #>   0      44           54 #>   1      80           70"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"generating-a-counting-process-dataset","dir":"Articles","previous_headings":"","what":"Generating a counting process dataset","title":"Basic tools for time-to-event trial simulation and testing","text":"cut data analysis, can create dataset simple use weighted logrank tests. slightly complex version developed future enable Kaplan-Meier-based tests. take dataset y150 process format. counting process format discussed next section compute weighted logrank test.","code":"ten150 <- counting_process(y150, arm = \"experimental\")  head(ten150) |>   gt() |>   fmt_number(columns = c(\"tte\", \"o_minus_e\", \"var_o_minus_e\"), decimals = 2)"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"logrank-and-weighted-logrank-testing","dir":"Articles","previous_headings":"","what":"Logrank and weighted logrank testing","title":"Basic tools for time-to-event trial simulation and testing","text":"Now stratified logrank stratified weighted logrank tests easily generated based counting process format. record counting process dataset represents tte one events occurs; results stratum-specific. Included observation number events overall (events) experimental treatment group (txevents), number risk overall (atrisk) experimental treatment group (txatrisk) just tte, combined treatment group Kaplan-Meier survival estimate (left-continuous) tte, observed events experimental group minus expected tte based assumption risk observations equally likely event time, variance quantity (Var). generate stratified logrank test corresponding one-sided p-value, simply following: Fleming-Harrington \\(\\rho=1\\), \\(\\gamma=2\\) nearly simple. compute z-statistic corresponding one-sided p-value. Fleming-Harrington tests, routine built tests : wanted take minimum MaxCombo test, first use fh_weight() compute correlation matrix z-statistics follows. Note ordering rho_gamma g argument list opposite . correlation matrix z-values now V1-V4. can compute p-value MaxCombo follows using mvtnorm::pmvnorm(). Note arguments GenzBretz() stringent defaults; also used stringent parameters example help file.","code":"z <- with(ten150, sum(o_minus_e) / sqrt(sum(var_o_minus_e))) c(z, pnorm(z)) #> [1] -2.505355629  0.006116416 xx <- mutate(ten150, w = s * (1 - s)^2) z <- with(xx, sum(o_minus_e * w) / sum(sqrt(var_o_minus_e * w^2))) c(z, pnorm(z)) #> [1] -0.1970797  0.4218826 fh00 <- y150 |> wlr(weight = fh(rho = 0, gamma = 0)) fh01 <- y150 |> wlr(weight = fh(rho = 0, gamma = 1)) fh10 <- y150 |> wlr(weight = fh(rho = 1, gamma = 0)) fh11 <- y150 |> wlr(weight = fh(rho = 1, gamma = 1))  temp_tbl <- fh00 |>   unlist() |>   as.data.frame() |>   cbind(fh01 |> unlist() |> as.data.frame()) |>   cbind(fh10 |> unlist() |> as.data.frame()) |>   cbind(fh11 |> unlist() |> as.data.frame())  colnames(temp_tbl) <- c(\"Test 1\", \"Test 2\", \"Test 3\", \"Test 4\") temp_tbl #>                       Test 1             Test 2             Test 3 #> method                   WLR                WLR                WLR #> parameter FH(rho=0, gamma=0) FH(rho=0, gamma=1) FH(rho=1, gamma=0) #> estimate   -14.9849475025986  -4.58833802802725  -10.3966094745713 #> se          5.98116583796613   2.21990881849575   4.28272384915455 #> z           2.50535562941256   2.06690382496719   2.42756942561769 #> info        37.0469798657718   5.42019004111222   18.2768366472186 #> info0                  37.25   5.44366046093289   18.6227889331453 #>                       Test 4 #> method                   WLR #> parameter FH(rho=1, gamma=1) #> estimate   -2.69994556253347 #> se          1.13659961009608 #> z           2.37545881465262 #> info        1.36992936361306 #> info0       1.37044207369963 y150 |>   maxcombo(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)) #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 0) + FH(0, 1) + FH(1, 0) + FH(1, 1)\" #>  #> $z #> [1] -2.505356 -2.066904 -2.427569 -2.375459 #>  #> $p_value #> [1] 0.0125865"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"simplification-for-2-arm-trials","dir":"Articles","previous_headings":"","what":"Simplification for 2-arm trials","title":"Basic tools for time-to-event trial simulation and testing","text":"sim_fixed_n() routine combines much go straight generating tests individual trials cutting data analyzing need done separately. argument structure meant simpler sim_pw_surv(). Now simulate trial 2 times cut data analysis based timing_type = 1:5 translates : planned study duration, targeted event count achieved, planned minimum follow-enrollment complete, maximum 1 2, maximum 2 3. look carefully, asking cutoff planned number events different data cutoff methods. explain, note generally want sample_size match enrollment specified enroll_rate: targeted enrollment takes, average, 30 months longer sum enrollment durations enroll_rate (14 months) input enrollment rates. achieve input sample_size 500, final enrollment rate assumed steady state extends simulation targeted enrollment achieved. planned duration trial taken 30 months specified total_duration. targeted minimum follow-thus, implicit last subject enrolled 16 months prior duration given cutoff “Minimum follow-” cutoff simulations . planned duration cutoff given total_duration argument results much earlier cutoff.","code":"stratum <- data.frame(stratum = \"All\", p = 1) enroll_rate <- data.frame(   duration = c(2, 2, 10),   rate = c(3, 6, 9) ) fail_rate <- data.frame(   stratum = \"All\",   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(0.9, 0.6),   dropout_rate = rep(0.001, 2) ) block <- rep(c(\"experimental\", \"control\"), 2) rho_gamma <- data.frame(rho = 0, gamma = 0) sim_fixed_n(   n_sim = 2, # Number of simulations   sample_size = 500, # Trial sample size   target_event = 350, # Targeted events at analysis   stratum = stratum, # Study stratum   enroll_rate = enroll_rate, # Enrollment rates   fail_rate = fail_rate, # Failure rates   total_duration = 30, # Planned trial duration   block = block, # Block for treatment   timing_type = 1:5, # Use all possible data cutoff methods   rho_gamma = rho_gamma # FH test(s) to use; in this case, logrank ) |>   gt() |>   fmt_number(columns = c(\"ln_hr\", \"z\", \"duration\")) #> Backend uses sequential processing. enroll_rate |> summarize(   \"Targeted enrollment based on input enrollment rates\" = sum(duration * rate) ) #>   Targeted enrollment based on input enrollment rates #> 1                                                 108 total_duration <- 30 # From above total_duration - sum(enroll_rate$duration) #> [1] 16"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"step-1-simulate-time-to-event-data","dir":"Articles","previous_headings":"","what":"Step 1: Simulate time-to-event data","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"sim_pw_surv() function allows simulation clinical trial essentially arbitrary patterns enrollment, failure rates, censoring. implement sim_pw_surv(), need specify 5 design characteristics simulate time--event data: Sample Size (input n). Stratified Non-Stratified Designs (input stratum). Randomization Ratio (input block). sim_pw_surv() function uses fixed block randomization. Enrollment Rate (input enroll_rate). sim_pw_surv() function supports piecewise enrollment, allowing enrollment rate piecewise constant. Failure Rate (input fail_rate) time--event rate. sim_pw_surv() function uses piecewise exponential distribution failure rate, makes easy define distribution changing failure rates time. Specifically, \\(j\\)-th interval, rate denoted \\(\\lambda_j \\geq 0\\). require least one interval \\(\\lambda_j > 0\\). two methods defining failure rate: Specify failure rate treatment group, stratum, time period. example can found Scenario b). Create fail_rate using gsDesign2::define_fail_rate, convert required format using to_sim_pw_surv(). example provided Scenario ). Dropout Rate (input dropout_Rate). sim_pw_surv() function accepts piecewise constant dropout rates, may vary treatment group. configuration dropout specified treatment group, stratum, time period, setting dropout rate follows approach failure rate.","code":""},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"scenario-a-the-simplest-scenario","dir":"Articles","previous_headings":"Step 1: Simulate time-to-event data","what":"Scenario a) The simplest scenario","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"begin simplest implementation sim_pw_surv(). following lines code generate 500 subjects using equal randomization unstratified design. output sim_pw_surv() subject-level observations, including stratum, enrollment time observation, treatment group observation randomized , failure time, dropout time, calendar time enrollment plot minimum failure time dropout time ( cte), failure dropout indicator (fail = 1 failure, fail = 0 dropout).","code":"n_sim <- 100 n <- 500 stratum <- data.frame(stratum = \"All\", p = 1) block <- rep(c(\"experimental\", \"control\"), 2)  enroll_rate <- define_enroll_rate(rate = 12, duration = n / 12)  fail_rate <- define_fail_rate(duration = c(6, Inf), fail_rate = log(2) / 10,                                hr = c(1, 0.7), dropout_rate = 0.0001)  uncut_data_a <- sim_pw_surv(n = n, stratum = stratum, block = block,                             enroll_rate = enroll_rate,                             fail_rate = to_sim_pw_surv(fail_rate)$fail_rate,                             dropout_rate = to_sim_pw_surv(fail_rate)$dropout_rate) uncut_data_a |> head() |> gt() |> tab_header(\"An Overview of Simulated TTE data\")"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"scenario-b-differential-dropout-rates","dir":"Articles","previous_headings":"Step 1: Simulate time-to-event data","what":"Scenario b) Differential dropout rates","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"dropout rate can differ groups. instance, open-label studies, control group may experience higher dropout rate. follow lines code assumes control group dropout rate 0.002 first 10 months, decreases 0.001 thereafter. contrast, experimental group constant dropout rate 0.001 throughout study.","code":"differential_dropout_rate <- data.frame(   stratum = rep(\"All\", 3),    period = c(1, 2, 1),    treatment = c(\"control\", \"control\", \"experimental\"),    duration = c(10, Inf, Inf),    rate = c(0.002, 0.001, 0.001))  uncut_data_b <- sim_pw_surv(n = n, stratum = stratum, block = block,                             enroll_rate = enroll_rate,                             fail_rate = to_sim_pw_surv(fail_rate)$fail_rate,                             dropout_rate = differential_dropout_rate)"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"scenario-c-stratified-designs","dir":"Articles","previous_headings":"Step 1: Simulate time-to-event data","what":"Scenario c) Stratified designs","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"following code assumes two strata (biomarker-positive biomarker-negative) equal prevalence 0.5 . control arm, median survival time 10 months biomarker-positive subjects 8 months biomarker-negative subjects. strata, hazard ratio 1 first 3 months, decreases 0.6 biomarker-positive subjects 0.8 biomarker-negative subjects. dropout rate contently 0.001 strata time.","code":"stratified_enroll_rate <- data.frame(   stratum = c(\"Biomarker positive\", \"Biomarker negative\"),   rate = c(12, 12),    duration = c(1, 1))  stratified_fail_rate <- data.frame(   stratum = c(rep(\"Biomarker positive\", 3), rep(\"Biomarker negative\", 3)),    period = c(1, 1, 2, 1, 1, 2),    treatment = rep(c(\"control\", \"experimental\", \"experimental\"), 2),   duration = c(Inf, 3, Inf, Inf, 3, Inf),    rate = c(# failure rate of biomarker positive subjects: control arm, exp arm period 1, exp arm period 2            log(2) / 10, log(2) /10, log(2) / 10 * 0.6,            # failure rate of biomarker negative subjects: control arm, exp arm period 1, exp arm period 2            log(2) / 8, log(2) /8, log(2) / 8 * 0.8)   )  stratified_dropout_rate <- data.frame(   stratum = rep(c(\"Biomarker positive\", \"Biomarker negative\"), each = 2),   period = c(1, 1, 1, 1),    treatment = c(\"control\", \"experimental\", \"control\", \"experimental\"),   duration = rep(Inf, 4),    rate = rep(0.001, 4)   )  uncut_data_c <- sim_pw_surv(n = n,                             stratum = data.frame(stratum = c(\"Biomarker positive\", \"Biomarker negative\"),                                                   p = c(0.5, 0.5)),                             block = block,                             enroll_rate = stratified_enroll_rate,                             fail_rate = stratified_fail_rate,                             dropout_rate = stratified_dropout_rate                             )"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"scenario-d-multi-arm-designs","dir":"Articles","previous_headings":"Step 1: Simulate time-to-event data","what":"Scenario d) Multi-arm designs","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"Suppose wish 3 arms: control, low-dose high-dose. following code assumes control arm median survival time 10 months, low-dose arm median survival time 12 months, high-dose arm median survival time 14 months. hazard ratio low-dose arm 0.8, hazard ratio high-dose arm 0.6. dropout rate 0.001 arms. Block size 7 3:2:2 randomization. begin setting enrollment, failure dropout rates. illustration purposes, focus scenario b) following discussion.","code":"enroll_rate <- define_enroll_rate(rate = 12, duration = n / 12)  three_arm_fail_rate <- data.frame(   stratum = \"All\",   period = c(1, 1, 2, 1, 2),    treatment = c(\"control\", \"low-dose\", \"low-dose\", \"high-dose\", \"high-dose\"),   duration = c(Inf, 3, Inf, 3, Inf),    rate = c(# failure rate of control arm: period 1, period 2            log(2) / 10,            # failure rate of low-dose arm: period 1, period 2            log(2) / c(10, 10 / .8),            # failure rate of high-dose arm: period 1, period 2            log(2) / c(10, 10 / .6)))  three_arm_dropout_rate <- data.frame(   stratum = \"All\",   period = c(1, 1, 1),    treatment = c(\"control\", \"low-dose\", \"high-dose\"),   duration = rep(Inf, 3),    rate = rep(0.001, 3))  uncut_data_d <- sim_pw_surv(n = n,                             stratum = data.frame(stratum = \"All\"),                             block = c(rep(\"control\", 3), rep(\"low-dose\", 2), rep(\"high-dose\", 2)),                             enroll_rate = enroll_rate,                             fail_rate = three_arm_fail_rate,                             dropout_rate = three_arm_dropout_rate) uncut_data <- uncut_data_b"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"step-2-cut-data","dir":"Articles","previous_headings":"","what":"Step 2: Cut data","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"get_analysis_date() derives analysis date interim/final analysis given multiple conditions, see help page get_analysis_date() pkgdown website. Users can cut analysis 24th month 300 events, whichever arrives later. equivalent timing_type = 4 sim_fixed_n(). Users can also cut maximum targeted 300 event minimum follow-12 months. equivalent timing_type = 5 sim_fixed_n(). Users can cut data 300 events, maximum time extension reach targeted events 24 months. enabled timing_type sim_fixed_n(). Users can cut data 12 months followup 80% patients enrolled overall population . enabled timing_type sim_fixed_n(). examples available reference page get_analysis_date() illustration purposes, focus scenario d) following discussion.","code":"cut_date_a <- get_analysis_date(data = uncut_data,                                 planned_calendar_time = 24,                                 target_event_overall = 300) cut_date_b <- get_analysis_date(data = uncut_data,                                 min_followup = 12,                                 target_event_overall = 300) cut_date_c <- get_analysis_date(data = uncut_data,                                 max_extension_for_target_event = 12,                                 target_event_overall = 300) cut_date_d <- get_analysis_date(data = uncut_data,                                 min_n_overall = 100 * 0.8,                                 min_followup = 12) cut_date <- cut_date_d cat(\"The cutoff date is \", round(cut_date, 2)) ## The cutoff date is  20.19 cut_data <- uncut_data |> cut_data_by_date(cut_date) cut_data |> head() |> gt() |> tab_header(paste0(\"An Overview of TTE data Cut at \", round(cut_date, 2), \"Months\"))"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"step-3-run-tests","dir":"Articles","previous_headings":"","what":"Step 3: Run tests","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"simtrial package provides many options testing methods, including (weighted) logrank tests, RMST test, milestone test, MaxComboi test, see [Section “Compute p-values/test statistics” pkgdown reference page] (https://merck.github.io/simtrial/reference/index.html#compute-p-values-test-statistics). following code lists possible tests available simtrial. Users can select one tests listed combine testing results make comparisons across tests. demonstration purposes, aggregate tests together. output tests mentioned lists including: testing method employed (WLR, RMST, milestone, MaxCombo), can accessed using sim_res_rmst$method. parameters associated testing method. instance, RMST test parameter 10, indicating RMST evaluated month 10. can find information using sim_res_rmst$parameter. point estimate standard error testing method used. example, point estimate RMST represents survival difference experimental group control group. estimate can retrieved sim_res_rmst$estimate sim_res_rmst$se. Z-score testing method, accessible via sim_res_rmst$z. Please note Z-score provided MaxCombo test; instead, p-value reported (sim_res_mc$p_value).","code":"# Logrank test sim_res_lr <- cut_data |> wlr(weight = fh(rho = 0, gamma = 0))  # weighted logrank test by Fleming-Harrington weights sim_res_fh <- cut_data |> wlr(weight = fh(rho = 0, gamma = 0.5))  # Modestly weighted logrank test sim_res_mb <- cut_data |> wlr(weight = mb(delay = Inf, w_max = 2))  # Weighted logrank test by Xu 2017's early zero weights sim_res_xu <- cut_data |> wlr(weight = early_zero(early_period = 3))  # RMST test sim_res_rmst <- cut_data |> rmst(tau = 10)  # Milestone test sim_res_ms <- cut_data |> milestone(ms_time = 10)  # Maxcombo tests comboing multiple weighted logrank test with Fleming-Harrington weights sim_res_mc <- cut_data |> maxcombo(rho = c(0, 0), gamma = c(0, 0.5)) sim_res <- tribble(   ~Method, ~Parameter, ~Z, ~Estimate, ~SE, ~`P value`,   sim_res_lr$method, sim_res_lr$parameter, sim_res_lr$z, sim_res_lr$estimate, sim_res_lr$se, pnorm(-sim_res_lr$z),   sim_res_fh$method, sim_res_fh$parameter, sim_res_fh$z, sim_res_fh$estimate, sim_res_fh$se, pnorm(-sim_res_fh$z),   sim_res_mb$method, sim_res_mb$parameter, sim_res_mb$z, sim_res_mb$estimate, sim_res_mb$se, pnorm(-sim_res_mb$z),   sim_res_xu$method, sim_res_xu$parameter, sim_res_xu$z, sim_res_xu$estimate, sim_res_xu$se, pnorm(-sim_res_xu$z),   sim_res_rmst$method, sim_res_rmst$parameter|> as.character(), sim_res_rmst$z, sim_res_rmst$estimate, sim_res_rmst$se, pnorm(-sim_res_rmst$z),   sim_res_ms$method, sim_res_ms$parameter |> as.character(), sim_res_ms$z, sim_res_ms$estimate, sim_res_ms$se, pnorm(-sim_res_ms$z),   sim_res_mc$method, sim_res_mc$parameter, NA, NA, NA, sim_res_mc$p_value   )   sim_res |> gt() |> tab_header(\"One Simulation Results\")"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"step-4-perform-the-above-single-simulation-repeatedly","dir":"Articles","previous_headings":"","what":"Step 4: Perform the above single simulation repeatedly","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"now merge Steps 1 3 single function named one_sim(), facilitates single simulation run. construction one_sim() involves copying lines code Steps 1 3. , execute one_sim() multiple times using parallel computation. following lines code uses 2 workers run 100 simulations. output parallel computation resembles output sim_fix_n() described vignette Simulate Fixed Designs Ease via sim_fixed_n. row output corresponds simulation results testing method per repeation.","code":"one_sim <- function(sim_id = 1,                      # arguments from Step 1: design characteristic                     n, stratum, enroll_rate, fail_rate, dropout_rate, block,                      # arguments from Step 2； cutting method                     min_n_overall, min_followup,                     # arguments from Step 3； testing method                     fh, mb, xu, rmst, ms, mc                     ) {     # Step 1: simulate a time-to-event data     uncut_data <- sim_pw_surv(       n = n,       stratum = stratum,       block = block,       enroll_rate = enroll_rate,       fail_rate = fail_rate,       dropout_rate = dropout_rate)           ## Step 2: Cut data     cut_date <- get_analysis_date(min_n_overall = min_n_overall, min_followup = min_followup, data = uncut_data)     cut_data <- uncut_data |> cut_data_by_date(cut_date)          # Step 3: Run tests     sim_res_lr <- cut_data |> wlr(weight = fh(rho = 0, gamma = 0))     sim_res_fh <- cut_data |> wlr(weight = fh(rho = fh$rho, gamma = fh$gamma))     sim_res_mb <- cut_data |> wlr(weight = mb(delay = mb$delay, w_max = mb$w_max))     sim_res_xu <- cut_data |> wlr(weight = early_zero(early_period = xu$early_period))     sim_res_rmst <- cut_data |> rmst(tau = rmst$tau)     sim_res_ms <- cut_data |> milestone(ms_time = ms$ms_time)     sim_res_mc <- cut_data |> maxcombo(rho = mc$rho, gamma = mc$gamma)          sim_res <- tribble(       ~`Sim ID`, ~Method, ~Parameter, ~Z, ~Estimate, ~SE, ~`P value`,       sim_id, sim_res_lr$method, sim_res_lr$parameter, sim_res_lr$z, sim_res_lr$estimate, sim_res_lr$se, pnorm(-sim_res_lr$z),       sim_id, sim_res_fh$method, sim_res_fh$parameter, sim_res_fh$z, sim_res_fh$estimate, sim_res_fh$se, pnorm(-sim_res_fh$z),       sim_id, sim_res_mb$method, sim_res_mb$parameter, sim_res_mb$z, sim_res_mb$estimate, sim_res_mb$se, pnorm(-sim_res_mb$z),       sim_id, sim_res_xu$method, sim_res_xu$parameter, sim_res_xu$z, sim_res_xu$estimate, sim_res_xu$se, pnorm(-sim_res_xu$z),       sim_id, sim_res_rmst$method, sim_res_rmst$parameter|> as.character(), sim_res_rmst$z, sim_res_rmst$estimate, sim_res_rmst$se, pnorm(-sim_res_rmst$z),       sim_id, sim_res_ms$method, sim_res_ms$parameter |> as.character(), sim_res_ms$z, sim_res_ms$estimate, sim_res_ms$se, pnorm(-sim_res_ms$z),       sim_id, sim_res_mc$method, sim_res_mc$parameter, NA, NA, NA, sim_res_mc$p_value   )             return(sim_res) } set.seed(2025)  plan(\"multisession\", workers = 2) ans <- foreach(   sim_id = seq_len(n_sim),   .errorhandling = \"stop\",   .options.future = list(seed = TRUE)   ) %dofuture% {     ans_new <- one_sim(       sim_id = sim_id,        # arguments from Step 1: design characteristic       n = n,        stratum = stratum,        enroll_rate = enroll_rate,        fail_rate = to_sim_pw_surv(fail_rate)$fail_rate,        dropout_rate = differential_dropout_rate,        block = block,        # arguments from Step 2； cutting method       min_n_overall = 500 * 0.8,       min_followup = 12,       # arguments from Step 3； testing method       fh = list(rho = 0, gamma = 0.5),        mb = list(delay = Inf, w_max = 2),        xu = list(early_period = 3),        rmst = list(tau = 10),        ms = list(ms_time = 10),        mc = list(rho = c(0, 0), gamma = c(0, 0.5))       )                                    ans_new   }  ans <- data.table::rbindlist(ans)  plan(\"sequential\") ans |> head() |> gt() |> tab_header(\"Overview Each Simulation results\")"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_custom.html","id":"step-5-summarize-simulations","dir":"Articles","previous_headings":"","what":"Step 5: Summarize simulations","title":"Custom Fixed Design Simulations: A Tutorial on Writing Code from the Ground Up","text":"Using 100 parallel simulations provided , users can summarize simulated power compare across different testing methods data manipulation using dplyr. Please note power calculation MaxCombo test differs tests, report Z-score.","code":"ans_non_mc <- ans |>   filter(Method != \"MaxCombo\") |>   group_by(Method, Parameter) %>%    summarise(Power = mean(Z > -qnorm(0.025))) |>   ungroup()  ans_mc <- ans |>   filter(Method == \"MaxCombo\") |>   summarize(Power = mean(`P value` < 0.025), Method = \"MaxCombo\", Parameter = \"FH(0, 0) + FH(0, 0.5)\")   ans_non_mc |>   union(ans_mc) |>   gt() |>   tab_header(\"Summary from 100 simulations\")"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_simple.html","id":"step-1-define-design-parameters","dir":"Articles","previous_headings":"","what":"Step 1: Define design parameters","title":"Simulate Fixed Designs with Ease via sim_fixed_n","text":"run simulations fixed design, several design characteristics may used. Depending data cutoff analysis option, different inputs may required. following lines code specify unstratified 2-arm trial equal randomization. simulation repeated 2 times. Enrollment targeted last 12 months constant enrollment rate. median control arm 10 months, delayed effect first 3 months followed hazard ratio 0.7 thereafter. exponential dropout rate 0.001 time. specify sample size targeted event count based fixed_design_ahr() function options. following design computes sample size targeted event counts 85% power. approach, users can obtain sample size targeted events output x, specifically using sample_size <- x$analysis$n target_event <- x$analysis$event. Now set derived targeted sample size, enrollment rate, event count .","code":"n_sim <- 100 total_duration <- 36 stratum <- data.frame(stratum = \"All\", p = 1) block <- rep(c(\"experimental\", \"control\"), 2)  enroll_rate <- data.frame(stratum = \"All\", rate = 12, duration = 500 / 12) fail_rate <- data.frame(stratum = \"All\",                         duration = c(3, Inf), fail_rate = log(2) / 10,                          hr = c(1, 0.6), dropout_rate = 0.001) x <- fixed_design_ahr(enroll_rate = enroll_rate, fail_rate = fail_rate,                        alpha = 0.025, power = 0.85, ratio = 1,                        study_duration = total_duration) |> to_integer() x |> summary() |> gt() |>    tab_header(title = \"Sample Size and Targeted Events Based on AHR Method\",               subtitle = \"Fixed Design with 85% Power, One-sided 2.5% Type I error\") |>   fmt_number(columns = c(4, 5, 7), decimals = 2) sample_size <- x$analysis$n target_event <- x$analysis$event enroll_rate <- x$enroll_rate"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_simple.html","id":"step-2-run-sim_fixed_n","dir":"Articles","previous_headings":"","what":"Step 2: Run sim_fixed_n()","title":"Simulate Fixed Designs with Ease via sim_fixed_n","text":"Now set design characteristics Step 1, can proceed run sim_fix_n() simulations. function automatically utilizes parallel computing backend, helps reduce running time. timing_type specifies one following cutoffs setting time analysis: timing_type = 1: planned study duration. timing_type = 2: time target event count observed. timing_type = 3: planned minimum follow-period enrollment completion. timing_type = 4: maximum planned study duration time observe targeted event count (.e., using timing_type = 1 timing_type = 2 together). timing_type = 5: maximum time observe targeted event count minimum follow-following enrollment completion (.e., using timing_type = 2 timing_type = 3 together). rho_gamma argument data frame containing variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted log-rank test per row. instance, setting rho = 0 gamma = 0 yields standard unweighted log-rank test, rho = 0 gamma = 0.5 provides weighted Fleming-Harrington (0, 0.5) log-rank test. interested tests Fleming-Harrington weighted log-rank test, please refer vignette “Articles”/“Simulate fixed/group sequential designs”/“Custom Fixed Design Simulations: Tutorial Writing Code Ground ”. output sim_fixed_n data frame one row per simulated dataset per cutoff specified timing_type, per test statistic specified rho_gamma. just run 2 simulated trials see different cutoffs vary 2 trial instances.","code":"sim_res <- sim_fixed_n(   n_sim = 2, # only use 2 simulations for initial run   sample_size = sample_size,    block = block,    stratum = stratum,   target_event = target_event,    total_duration = total_duration,   enroll_rate = enroll_rate,    fail_rate = fail_rate,   timing_type = 1:5,    rho_gamma = data.frame(rho = 0, gamma = 0)) sim_res |>   gt() |>   tab_header(\"Tests for Each Simulation Result\", subtitle = \"Logrank Test for Different Analysis Cutoffs\") |>   fmt_number(columns = c(4, 5, 7), decimals = 2)"},{"path":"https://merck.github.io/simtrial/articles/sim_fixed_design_simple.html","id":"step-3-summarize-simulations","dir":"Articles","previous_headings":"","what":"Step 3: Summarize simulations","title":"Simulate Fixed Designs with Ease via sim_fixed_n","text":"Now run 100 simulated trials summarize results data cutoff analysis. 100 simulations provided, users can summarize simulated power compare targeted 85% power. cutoff methods approximate targeted power well similar average duration mean number events. can also things like summarize distribution event counts planned study duration. can see event count varies fair amount.  also evaluate distribution trial duration analysis performed targeted events achieved.","code":"sim_res <- sim_fixed_n(   n_sim = n_sim,   sample_size = sample_size,    block = block, stratum = stratum,   target_event = target_event,    total_duration = total_duration,   enroll_rate = enroll_rate,    fail_rate = fail_rate,   timing_type = 1:5,    rho_gamma = data.frame(rho = 0, gamma = 0)) sim_res |>   group_by(cut) |>   summarize(`Simulated Power` = mean(z > qnorm(1 - 0.025)),              `Mean events` = mean(event),             `Mean duration` = mean(duration)) |>   mutate(`Sample size` = sample_size,          `Targeted events` = target_event) |>   gt() |>   tab_header(title = \"Summary of 100 simulations by 5 different analysis cutoff methods\",              subtitle = \"Tested by logrank\") |>   fmt_number(columns = c(2:4), decimals = 2) hist(sim_res$event[sim_res$cut == \"Planned duration\"],       breaks = 10,      main = \"Distribution of Event Counts at Planned Study Duration\",      xlab = \"Event Count at Targeted Trial Duration\") plot(density(sim_res$duration[sim_res$cut == \"Targeted events\"]),       main = \"Trial Duration Smoothed Density\",      xlab = \"Trial duration when Targeted Event Count is Observed\")"},{"path":"https://merck.github.io/simtrial/articles/sim_gs_design_simple.html","id":"step-1-define-design-paramaters","dir":"Articles","previous_headings":"","what":"Step 1: Define design paramaters","title":"Simulate Group Sequential Designs with Ease via sim_gs_n","text":"run simulations group sequential design, several design characteristics required. following code creates design unstratified 2-arm trial equal randomization. Enrollment targeted last 12 months constant enrollment rate. control arm specified exponential median 10 months. experimental arm distribution piecewise exponential distribution delay 3 months benefit relative control (HR = 1) followed hazard ratio 0.6 thereafter. Additionally, exponential dropout rate 0.001 per month (unit time). set parameters similar vignette Simulate Fixed Designs Ease via sim_fixed_n. total sample size derived 90% power. Now get updated planned enrollment rate design achieve targeted sample size. additional parameters required group sequential design simulation demonstrated . One testing method. focus logrank . Users can change tests interest; comments demonstrate logrank modestly weighted logrank test (Magirr Burman (2019)) Fleming-Harrington (Harrington Fleming (1982)) tests; set group sequential designs alternate tests beyond scope article. testing methods available reference page simtrial. final step specify data cut analysis group sequential design. create_cut() function includes 5 options analysis cutoff: planned calendar time, targeted events, maximum time extension reach targeted events, planned minimum time previous analysis, minimal follow-time specified enrollment fraction. details examples available help page. straightforward method cutting analyses based events. instance, following code specifies 2 interim analyses 1 final analysis cut 106, 227, 287 events occur. event-driven approach, need update efficacy boundary. Users can set complex cutting. example, first interim analysis occurs targeted IA 1 analyusis time least IA 1 targeted events observed, later. However, target number events reached, wait maximum 16 months start enrollment. second interim analysis targeted take place targeted time targeted events IA 2, whichever later. Additionally, interim analysis scheduled least 10 months first interim analysis, later 28 months start enrollment. final analysis set targeted final analysis time targeted events final analysis, whichever later. must least 6 months IA 2. Please keep mind cut event-driven, boundary updates necessary; covered . can find information boundary updates boundary update vignette. vignette, use event-driven cut illustrative purposes.","code":"stratum <- data.frame(stratum = \"All\", p = 1) block <- rep(c(\"experimental\", \"control\"), 2) # enrollment rate will be updated later,  # multiplied by a constant to get targeted power enroll_rate <- data.frame(stratum = \"All\", rate = 1, duration = 12) fail_rate <- data.frame(stratum = \"All\",                         duration = c(3, Inf), fail_rate = log(2) / 10,                          hr = c(1, 0.6), dropout_rate = 0.001) # Derive design using the average hazard ratio method x <- gs_design_ahr(enroll_rate = enroll_rate, fail_rate = fail_rate,                    analysis_time = c(12, 24, 36), alpha = 0.025, beta = 0.1,                    # spending function for upper bound                    upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),                    # Fixed lower bound                    lower = gs_b,                    lpar = rep(-Inf, 3)) |> to_integer()  sample_size <- x$analysis$n |> max() event <- x$analysis$event eff_bound <- x$bound$z[x$bound$bound == \"upper\"] cat(paste(\"The total sample size is \", sample_size, \"\\n\", sep = '')) ## The total sample size is 362 cat(\"The number of events at IA1, IA2 and FA are:\", event, \"\\n\") ## The number of events at IA1, IA2 and FA are: 106 227 287 cat(\"The efficacy bounds at IA1, IA2 and FA are:\", round(eff_bound, 3), \"\\n\") ## The efficacy bounds at IA1, IA2 and FA are: 3.508 2.269 2.023 cat(\"Targeted analysis times:\", round(x$analysis$time, 1), \"\\n\") ## Targeted analysis times: 12 24 35.9 enroll_rate <- x$enroll_rate enroll_rate ##   stratum     rate duration ## 1     All 30.16667       12 # Example for logrank weight <- fh(rho = 0, gamma = 0) test <- wlr # Example for Modestly Weighted Logrank Test (Magirr-Burman) # weight <- mb(delay = Inf, w_max = 2) # Example for Fleming-Harrington(0, 0.5) # weight <- fh(rho = 0, gamma = 0.5) ia1_cut <- create_cut(target_event_overall = event[1]) ia2_cut <- create_cut(target_event_overall = event[2]) fa_cut <- create_cut(target_event_overall = event[3])  cut <- list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut) ia1_cut <- create_cut(   planned_calendar_time = round(x$analysis$time[1]),    target_event_overall = x$analysis$event[1],   max_extension_for_target_event = 16)  ia2_cut <- create_cut(   planned_calendar_time = round(x$analysis$time[2]),   target_event_overall = x$analysis$event[2],   min_time_after_previous_analysis = 10,    max_extension_for_target_event = 28)  fa_cut <- create_cut(   planned_calendar_time = round(x$analysis$time[3]),   min_time_after_previous_analysis = 6,   target_event_overall = x$analysis$event[3])  cut <- list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut)"},{"path":"https://merck.github.io/simtrial/articles/sim_gs_design_simple.html","id":"step-2-run-sim_gs_n","dir":"Articles","previous_headings":"","what":"Step 2: Run sim_gs_n()","title":"Simulate Group Sequential Designs with Ease via sim_gs_n","text":"Now set design characteristics Step 1, can proceed run sim_gs_n() specified number simulations. function automatically utilizes parallel computing backend, helps reduce running time. output sim_gs_n data frame one row per simulation per analysis. show results first 2 simulated trials . estimate column sum(0 - E) logrank test; se column standard error estimated null hypothesis. z column test statistic logrank test (estimate / se). info info0 columns information current analysis alternate null hypotheses, respectively.","code":"n_sim <- 100 # Number of simulated trials sim_res <- sim_gs_n(   n_sim = n_sim,   sample_size = sample_size, stratum = stratum, block = block,   enroll_rate = enroll_rate, fail_rate = fail_rate,   test = test, weight = weight, cut = cut) sim_res |> head(n = 6) |> gt() |> tab_header(\"Overview Each Simulation results\") |>   fmt_number(columns = c(5, 8:12), decimals = 2)"},{"path":"https://merck.github.io/simtrial/articles/sim_gs_design_simple.html","id":"step-3-summarize-simulations","dir":"Articles","previous_headings":"","what":"Step 3: Summarize simulations","title":"Simulate Group Sequential Designs with Ease via sim_gs_n","text":"100 simulations provided, users can summarize simulated power compare target power 90% follows:","code":"sim_res |>   left_join(data.frame(analysis = 1:3, eff_bound = eff_bound)) |>   group_by(analysis) |>   summarize(`Mean time` = mean(cut_date), `sd(time)` = sd(cut_date), `Simulated power` = mean(z >= eff_bound)) |>   ungroup() |>   mutate(`Asymptotic power` = x$bound$probability[x$bound$bound == \"upper\"]) |>   gt() |>   tab_header(\"Summary of 100 simulations\") |>    fmt_number(columns = 2, decimals = 1) |>   fmt_number(columns = 3:5, decimals = 2)"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"TTE simulation data manipulations","text":"attempt provide big picture view involved clinical trial simulation individual time--event data generated patient. Primary interest group sequential trials, usually single endpoint. However extensions made.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"results-data-table","dir":"Articles","previous_headings":"","what":"Results data table","title":"TTE simulation data manipulations","text":"time simulation planning analysis plan trial needed. group sequential design, data table store results generated. Generally, dimensions variables planned storage planned front. simple example, group sequential design 3 analyses planned, 15 data items analysis 10,000 simulations planned, data table 30,000 rows 15 columns used store summary results. trial simulation proceeds, row updated results analysis.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"simulated-trial-dataset-generation","dir":"Articles","previous_headings":"","what":"Simulated trial dataset generation","title":"TTE simulation data manipulations","text":"simulated trial, initial table generated information patient level. trials generated sequentially, space needed data table re-used, never requiring allocation space. row contains data single patient. example, simulate trial 500 patients 10 data items per patients. data items columns, patients rows.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"dataset-manipulations-for-analysis","dir":"Articles","previous_headings":"","what":"Dataset manipulations for analysis","title":"TTE simulation data manipulations","text":"Simulated trial data need manipulated individual analysis (interim final) clinical trial. following operations needed: Ordering data Selecting subset analysis Calculating individual patient results subset time analysis. Number subjects treatment group Number events treatment group Kaplan-Meier estimation survival curves Observed minus expected computations well weighting logrank, weighted logrank calculations. Using survival package compute hazard ratio estimates.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"flow-for-simulating-group-sequential-one-scenario-algorithm","dir":"Articles","previous_headings":"","what":"Flow for simulating group sequential: one scenario algorithm","title":"TTE simulation data manipulations","text":"Group sequential design simulation flow: Generate trial. Analyze repeatedly. Summarize across simulated trials.","code":""},{"path":"https://merck.github.io/simtrial/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Keaven Anderson. Author. Yujie Zhao. Author, maintainer. John Blischak. Author. Nan Xiao. Contributor. Yilong Zhang. Author. Jianxiao Yang. Contributor. Lili Ling. Contributor. Xintong Li. Contributor. Ruixue Wang. Contributor. Yi Cui. Contributor. Ping Yang. Contributor. Yalin Zhu. Contributor. Heng Zhou. Contributor. Amin Shirazi. Contributor. Cole Manschot. Contributor. Larry Leon. Contributor. Merck & Co., Inc., Rahway, NJ, USA affiliates. Copyright holder.","code":""},{"path":"https://merck.github.io/simtrial/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson K, Zhao Y, Blischak J, Zhang Y (2025). simtrial: Clinical Trial Simulation. R package version 1.0.1, https://merck.github.io/simtrial/.","code":"@Manual{,   title = {simtrial: Clinical Trial Simulation},   author = {Keaven Anderson and Yujie Zhao and John Blischak and Yilong Zhang},   year = {2025},   note = {R package version 1.0.1},   url = {https://merck.github.io/simtrial/}, }"},{"path":"https://merck.github.io/simtrial/index.html","id":"simtrial-","dir":"","previous_headings":"","what":"Clinical Trial Simulation","title":"Clinical Trial Simulation","text":"simtrial fast extensible clinical trial simulation framework time--event endpoints.","code":""},{"path":"https://merck.github.io/simtrial/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Clinical Trial Simulation","text":"easiest way get simtrial install CRAN: Alternatively, use new feature get bug fix, can install development version simtrial GitHub:","code":"install.packages(\"simtrial\") # install.packages(\"remotes\") remotes::install_github(\"Merck/simtrial\")"},{"path":"https://merck.github.io/simtrial/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Clinical Trial Simulation","text":"simtrial intended general purpose tool simulating fixed, group sequential adaptive clinical trials. allows stratified populations flexible parameters generating enrollment, event times, dropout times. takes care bookkeeping enable easily going data generation creating analysis datasets evaluation standard innovative designs testing procedures. single endpoint, easily generate trials multiple arms (e.g., single multiple experimental arms versus common control) multiple study populations (e.g., overall population biomarker positive). tools built package logrank weighted logrank tests, arbitrary testing estimation procedures easily applied. addition weighted logrank tests, support combinations weighted logrank tests (e.g., MaxCombo test). package used piecewise constant enrollment, failure dropout rates simple model able approximate arbitrary distributions easily. model also enables simulating non-proportional hazards assumptions transparent users explain non-statistical collaborators. simtrial designed core philosophy basing computations efficient table transformations package easy qualify use regulated environments. utilizes blazingly fast data.table tabular data processing, enhanced C++ implementations ensure optimal performance. However, require user data.table C++ user. Initial areas focus : Generating time--event data stratified trials using piecewise constant enrollment piecewise exponential failure rates. proportional non-proportional hazards supported. proportional hazards, assumptions along lines used Lachin Foulkes implemented gsDesign deriving group sequential designs. Setting data cutoffs (interim final) analyses. Support weighted logrank tests arbitrary weighting schemes, specifically supporting Fleming-Harrington set tests, including logrank test.","code":""},{"path":"https://merck.github.io/simtrial/index.html","id":"future-developments","dir":"","previous_headings":"","what":"Future developments","title":"Clinical Trial Simulation","text":"Expectations future development include: Provide test suite document package fit use regulatory environment. examples.","code":""},{"path":"https://merck.github.io/simtrial/reference/as_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert summary table to a gt object — as_gt","title":"Convert summary table to a gt object — as_gt","text":"Convert summary table gt object","code":""},{"path":"https://merck.github.io/simtrial/reference/as_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert summary table to a gt object — as_gt","text":"","code":"as_gt(x, ...)  # S3 method for class 'simtrial_gs_wlr' as_gt(   x,   title = \"Summary of simulation results by WLR tests\",   subtitle = NULL,   ... )"},{"path":"https://merck.github.io/simtrial/reference/as_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert summary table to a gt object — as_gt","text":"x object returned summary(). ... Additional parameters (used). title Title gt table. subtitle Subtitle gt table.","code":""},{"path":"https://merck.github.io/simtrial/reference/as_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert summary table to a gt object — as_gt","text":"gt table. gt table summarizing simulation results.","code":""},{"path":"https://merck.github.io/simtrial/reference/as_gt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert summary table to a gt object — as_gt","text":"","code":"# Parameters for enrollment enroll_rampup_duration <- 4 # Duration for enrollment ramp up enroll_duration <- 16 # Total enrollment duration enroll_rate <- gsDesign2::define_enroll_rate(   duration = c(     enroll_rampup_duration, enroll_duration - enroll_rampup_duration),  rate = c(10, 30))  # Parameters for treatment effect delay_effect_duration <- 3 # Delay treatment effect in months median_ctrl <- 9 # Survival median of the control arm median_exp <- c(9, 14) # Survival median of the experimental arm dropout_rate <- 0.001 fail_rate <- gsDesign2::define_fail_rate(   duration = c(delay_effect_duration, 100),   fail_rate = log(2) / median_ctrl,   hr = median_ctrl / median_exp,   dropout_rate = dropout_rate)  # Other related parameters alpha <- 0.025 # Type I error beta <- 0.1 # Type II error ratio <- 1 # Randomization ratio (experimental:control)  # Build a one-sided group sequential design design <- gsDesign2::gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, alpha = alpha, beta = beta,   analysis_time = c(12, 24, 36),   upper = gsDesign2::gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = alpha),   lower = gsDesign2::gs_b,   lpar = rep(-Inf, 3))  # Define cuttings of 2 IAs and 1 FA ia1_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[1])) ia2_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[2])) fa_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[3]))  # Run simulations simulation <- sim_gs_n(   n_sim = 3,   sample_size = ceiling(design$analysis$n[3]),   enroll_rate = design$enroll_rate,   fail_rate = design$fail_rate,   test = wlr,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   weight = fh(rho = 0, gamma = 0.5)) #> Backend uses sequential processing.  # Summarize simulations simulation |>  summary(bound = gsDesign::gsDesign(k = 3, test.type = 1, sfu = gsDesign::sfLDOF)$upper$bound) |>  simtrial::as_gt()     Summary of simulation results by WLR tests     Weighted by FH(rho=0, gamma=0.5)     analysis       Time       N       Event       Crossing probability     1 12.14286 356 97 NA2 24.71662 505 305 0.66666673 36.84514 505 405 1.0000000 # Summarize simulations and compare with the planned design simulation |>   summary(design = design) |>   simtrial::as_gt()     Summary of simulation results by WLR tests     Weighted by FH(rho=0, gamma=0.5)     Analysis                Time                       N                       Events                       Probability of crossing efficacy bounds under H1            Asymptotic       Simulated       Asymptotic       Simulated       Asymptotic       Simulated       Asymptotic       Simulated     1 12 12.14286 353.0464 356 96.77449 97 0.0001486592 NA2 24 24.71662 504.3520 505 304.00970 305 0.5723210881 13 36 36.84514 504.3520 505 404.14162 405 0.8999997572 NA"},{"path":"https://merck.github.io/simtrial/reference/check_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Check argument types, length, or dimension — check_args","title":"Check argument types, length, or dimension — check_args","text":"Check argument types, length, dimension","code":""},{"path":"https://merck.github.io/simtrial/reference/check_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check argument types, length, or dimension — check_args","text":"","code":"check_args(arg, type, length = NULL, dim = NULL)"},{"path":"https://merck.github.io/simtrial/reference/check_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check argument types, length, or dimension — check_args","text":"arg argument checked. type character vector candidate argument type. length numeric value argument length NULL. dim numeric vector argument dimension NULL.","code":""},{"path":"https://merck.github.io/simtrial/reference/check_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check argument types, length, or dimension — check_args","text":"Check failure detailed error message.","code":""},{"path":"https://merck.github.io/simtrial/reference/check_args.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check argument types, length, or dimension — check_args","text":"type, length dim NULL, corresponding check executed.","code":""},{"path":"https://merck.github.io/simtrial/reference/check_args.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Check argument types, length, or dimension — check_args","text":"contents section shown PDF user manual .","code":""},{"path":"https://merck.github.io/simtrial/reference/check_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check argument types, length, or dimension — check_args","text":"","code":"if (FALSE) { # \\dontrun{ tbl <- as.data.frame(matrix(1:9, nrow = 3)) simtrial:::check_args(arg = tbl, type = c(\"data.frame\"))  vec <- c(\"a\", \"b\", \"c\") simtrial:::check_args(arg = vec, type = c(\"character\"), length = 3) } # }"},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":null,"dir":"Reference","previous_headings":"","what":"Process survival data into counting process format — counting_process","title":"Process survival data into counting process format — counting_process","text":"Produces data frame sorted stratum time. Included times one event occurs. output dataset contains stratum, TTE (time--event), risk count, count events specified TTE sorted stratum TTE.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process survival data into counting process format — counting_process","text":"","code":"counting_process(x, arm)"},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process survival data into counting process format — counting_process","text":"x data frame missing values contain variables: stratum: Stratum. treatment: Treatment group. tte: Observed time. event: Binary event indicator, 1 represents event, 0 represents censoring. arm Value input treatment column indicates treatment group value.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process survival data into counting process format — counting_process","text":"data frame grouped stratum sorted within stratum tte. includes rows least one event population, least one subject risk treatment group control group. variables represent following within stratum time one events observed: event_total: Total number events event_trt: Total number events treatment group n_risk_total: Number subjects risk n_risk_trt: Number subjects risk treatment group s: Left-continuous Kaplan-Meier survival estimate o_minus_e: treatment group, observed number events minus expected number events. expected number events estimated assuming treatment effect hypergeometric distribution parameters total number events, total number events treatment group number events time. (assumption log-rank test null hypothesis) var_o_minus_e: Variance o_minus_e assumption.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process survival data into counting process format — counting_process","text":"function considered two group situation. tie handled Breslow's Method. output produced counting_process() produces counting process dataset grouped stratum sorted within stratum increasing times events occur. object assigned class \"counting_process\". also attribute \"ratio\", ratio events treatment arm compared control arm input time--event data. input data generated sim_pw_surv(), ratio attribute simply obtained attribute name input object. Otherwise, returned ratio empirical ratio treatment control events.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process survival data into counting process format — counting_process","text":"","code":"# Example 1 x <- data.frame(   stratum = c(rep(1, 10), rep(2, 6)),   treatment = rep(c(1, 1, 0, 0), 4),   tte = 1:16,   event = rep(c(0, 1), 8) ) counting_process(x, arm = 1) #>   stratum event_total event_trt tte n_risk_total n_risk_trt         s #> 1       1           1         1   2            9          5 1.0000000 #> 2       1           1         0   4            7          4 0.8888889 #> 3       1           1         1   6            5          3 0.7619048 #> 4       1           1         0   8            3          2 0.6095238 #> 5       2           1         0  12            5          2 1.0000000 #> 6       2           1         1  14            3          1 0.8000000 #>    o_minus_e var_o_minus_e #> 1  0.4444444     0.2469136 #> 2 -0.5714286     0.2448980 #> 3  0.4000000     0.2400000 #> 4 -0.6666667     0.2222222 #> 5 -0.4000000     0.2400000 #> 6  0.6666667     0.2222222  # Example 2 x <- sim_pw_surv(n = 400) y <- cut_data_by_event(x, 150) |> counting_process(arm = \"experimental\") # Weighted logrank test (Z-value and 1-sided p-value) z <- sum(y$o_minus_e) / sqrt(sum(y$var_o_minus_e)) c(z, pnorm(z)) #> [1] -3.5701616116  0.0001783805"},{"path":"https://merck.github.io/simtrial/reference/create_cut.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a cutting function — create_cut","title":"Create a cutting function — create_cut","text":"Create cutting function use sim_gs_n()","code":""},{"path":"https://merck.github.io/simtrial/reference/create_cut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a cutting function — create_cut","text":"","code":"create_cut(...)"},{"path":"https://merck.github.io/simtrial/reference/create_cut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a cutting function — create_cut","text":"... Arguments passed get_analysis_date()","code":""},{"path":"https://merck.github.io/simtrial/reference/create_cut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a cutting function — create_cut","text":"function accepts data frame simulated trial data returns cut date","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/create_cut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a cutting function — create_cut","text":"","code":"# Simulate trial data trial_data <- sim_pw_surv()  # Create a cutting function that applies the following 2 conditions: # - At least 45 months have passed since the start of the study # - At least 300 events have occurred cutting <- create_cut(   planned_calendar_time = 45,   target_event_overall = 350 )  # Cut the trial data cutting(trial_data) #> [1] 77.87317"},{"path":"https://merck.github.io/simtrial/reference/create_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a cutting test function — create_test","title":"Create a cutting test function — create_test","text":"Create cutting test function use sim_gs_n()","code":""},{"path":"https://merck.github.io/simtrial/reference/create_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a cutting test function — create_test","text":"","code":"create_test(test, ...)"},{"path":"https://merck.github.io/simtrial/reference/create_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a cutting test function — create_test","text":"test test function wlr(), maxcombo(), rmst() ... Arguments passed cutting test function","code":""},{"path":"https://merck.github.io/simtrial/reference/create_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a cutting test function — create_test","text":"function accepts data frame simulated trial data returns test result","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/create_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a cutting test function — create_test","text":"","code":"# Simulate trial data trial_data <- sim_pw_surv()  # Cut after 150 events trial_data_cut <- cut_data_by_event(trial_data, 150)  # Create a cutting test function that can be used by sim_gs_n() regular_logrank_test <- create_test(wlr, weight = fh(rho = 0, gamma = 0))  # Test the cutting regular_logrank_test(trial_data_cut) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0)\" #>  #> $estimate #> [1] -16.60282 #>  #> $se #> [1] 4.370912 #>  #> $z #> [1] 3.798481 #>  #> $info #> [1] 23.1828 #>  #> $info0 #> [1] 23.25 #>   # The results are the same as directly calling the function stopifnot(all.equal(   regular_logrank_test(trial_data_cut),   wlr(trial_data_cut, weight = fh(rho = 0, gamma = 0)) ))"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a dataset for analysis at a specified date — cut_data_by_date","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"Cut dataset analysis specified date","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"","code":"cut_data_by_date(x, cut_date)"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"x time--event dataset, example, generated sim_pw_surv(). cut_date Date relative start randomization (cte input dataset) dataset cut analysis.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"data frame ready survival analysis, including columns time event (tte), event, stratum, treatment. class data frame tte_data, attribute ratio generated sim_pw_surv() also attached.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"","code":"# Use default enrollment and event rates and # cut at calendar time 5 after start of randomization sim_pw_surv(n = 20) |> cut_data_by_date(5) #>          tte event stratum    treatment #> 1  4.8763169     0     All experimental #> 2  4.8703586     0     All experimental #> 3  2.2070735     1     All      control #> 4  0.1173257     1     All      control #> 5  4.6605109     0     All experimental #> 6  4.5461906     0     All      control #> 7  4.5116372     0     All      control #> 8  4.0148199     0     All experimental #> 9  3.8905856     0     All experimental #> 10 3.7668601     0     All      control #> 11 3.6986976     0     All experimental #> 12 3.6716565     0     All      control #> 13 3.5130873     0     All experimental #> 14 3.2754677     0     All      control #> 15 1.1770995     1     All      control #> 16 3.2343190     0     All experimental #> 17 3.1307312     0     All experimental #> 18 2.9814824     0     All experimental #> 19 2.9608820     0     All      control #> 20 0.3731280     1     All      control"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a dataset for analysis at a specified event count — cut_data_by_event","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"Takes time--event data set cuts data event count reached.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"","code":"cut_data_by_event(x, event)"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"x time--event dataset, example, generated sim_pw_surv(). event Event count data cutoff made.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"data frame ready survival analysis, including columns time event (tte), event, stratum, treatment. class data frame tte_data, attribute ratio generated sim_pw_surv() also attached.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"","code":"# Use default enrollment and event rates at cut at 100 events x <- sim_pw_surv(n = 200) |> cut_data_by_event(100) table(x$event, x$treatment) #>     #>     control experimental #>   0      44           48 #>   1      52           48"},{"path":"https://merck.github.io/simtrial/reference/early_zero.html","id":null,"dir":"Reference","previous_headings":"","what":"Zero early weighting function — early_zero","title":"Zero early weighting function — early_zero","text":"Zero early weighting function","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zero early weighting function — early_zero","text":"","code":"early_zero(early_period, fail_rate = NULL)"},{"path":"https://merck.github.io/simtrial/reference/early_zero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zero early weighting function — early_zero","text":"early_period initial delay period weights increase; , weights constant final weight delay period. fail_rate Failure rate","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zero early weighting function — early_zero","text":"list parameters zero early weighting function","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Zero early weighting function — early_zero","text":"Xu, Z., Zhen, B., Park, Y., & Zhu, B. (2017). \"Designing therapeutic cancer vaccine trials delayed treatment effect.\"","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zero early weighting function — early_zero","text":"","code":"library(gsDesign2) #>  #> Attaching package: ‘gsDesign2’ #> The following object is masked from ‘package:simtrial’: #>  #>     as_gt  # Example 1: Unstratified ---- sim_pw_surv(n = 200) |>   cut_data_by_event(125) |>   wlr(weight = early_zero(early_period = 2)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"Xu 2017 with first 2 months of 0 weights\" #>  #> $estimate #> [1] -19.03831 #>  #> $se #> [1] 4.794997 #>  #> $z #> [1] 3.970454 #>  #> $info #> [1] 22.73958 #>  #> $info0 #> [1] 24 #>   # Example 2: Stratified ---- n <- 500 # Two strata stratum <- c(\"Biomarker-positive\", \"Biomarker-negative\") prevalence_ratio <- c(0.6, 0.4)  # Enrollment rate enroll_rate <- define_enroll_rate(   stratum = rep(stratum, each = 2),   duration = c(2, 10, 2, 10),   rate = c(c(1, 4) * prevalence_ratio[1], c(1, 4) * prevalence_ratio[2]) ) enroll_rate$rate <- enroll_rate$rate * n / sum(enroll_rate$duration * enroll_rate$rate)  # Failure rate med_pos <- 10 # Median of the biomarker positive population med_neg <- 8 # Median of the biomarker negative population hr_pos <- c(1, 0.7) # Hazard ratio of the biomarker positive population hr_neg <- c(1, 0.8) # Hazard ratio of the biomarker negative population fail_rate <- define_fail_rate(   stratum = rep(stratum, each = 2),   duration = c(3, 1000, 4, 1000),   fail_rate = c(log(2) / c(med_pos, med_pos, med_neg, med_neg)),   hr = c(hr_pos, hr_neg),   dropout_rate = 0.01 )  # Simulate data temp <- to_sim_pw_surv(fail_rate) # Convert the failure rate set.seed(2023)  sim_pw_surv(   n = n, # Sample size   # Stratified design with prevalence ratio of 6:4   stratum = data.frame(stratum = stratum, p = prevalence_ratio),   # Randomization ratio   block = c(\"control\", \"control\", \"experimental\", \"experimental\"),   enroll_rate = enroll_rate, # Enrollment rate   fail_rate = temp$fail_rate, # Failure rate   dropout_rate = temp$dropout_rate # Dropout rate ) |>   cut_data_by_event(125) |>   wlr(weight = early_zero(early_period = 2, fail_rate = fail_rate)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"Xu 2017 with first 2 months of 0 weights\" #>  #> $estimate #> [1] 1.207753 #>  #> $se #> [1] 1.133941 #>  #> $z #> [1] -1.065093 #>  #> $info #> [1] 1.285211 #>  #> $info0 #> [1] 1.298506 #>"},{"path":"https://merck.github.io/simtrial/reference/ex1_delayed_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 1 for non-proportional hazards working group — ex1_delayed_effect","title":"Time-to-event data example 1 for non-proportional hazards working group — ex1_delayed_effect","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex1_delayed_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 1 for non-proportional hazards working group — ex1_delayed_effect","text":"","code":"data(ex1_delayed_effect)"},{"path":"https://merck.github.io/simtrial/reference/ex1_delayed_effect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 1 for non-proportional hazards working group — ex1_delayed_effect","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex1_delayed_effect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 1 for non-proportional hazards working group — ex1_delayed_effect","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187–198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/ex1_delayed_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 1 for non-proportional hazards working group — ex1_delayed_effect","text":"","code":"library(survival) #>  #> Attaching package: ‘survival’ #> The following object is masked from ‘package:future’: #>  #>     cluster  data(ex1_delayed_effect) km1 <- with(ex1_delayed_effect, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 121     86   5.04    4.18    6.21 #> trt=1 240    132   7.66    6.54    9.48 plot(km1)  with(subset(ex1_delayed_effect, trt == 1), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 240    132   7.66    6.54    9.48 with(subset(ex1_delayed_effect, trt == 0), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 121     86   5.04    4.18    6.21"},{"path":"https://merck.github.io/simtrial/reference/ex2_delayed_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 2 for non-proportional hazards working group — ex2_delayed_effect","title":"Time-to-event data example 2 for non-proportional hazards working group — ex2_delayed_effect","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex2_delayed_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 2 for non-proportional hazards working group — ex2_delayed_effect","text":"","code":"data(ex2_delayed_effect)"},{"path":"https://merck.github.io/simtrial/reference/ex2_delayed_effect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 2 for non-proportional hazards working group — ex2_delayed_effect","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex2_delayed_effect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 2 for non-proportional hazards working group — ex2_delayed_effect","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187–198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/ex2_delayed_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 2 for non-proportional hazards working group — ex2_delayed_effect","text":"","code":"library(survival)  data(ex2_delayed_effect) km1 <- with(ex2_delayed_effect, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 137    123   2.84    2.18    3.50 #> trt=1 135    105   3.45    2.13    5.07 plot(km1)  with(subset(ex2_delayed_effect, trt == 1), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 135    105   3.45    2.13    5.07 with(subset(ex2_delayed_effect, trt == 0), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 137    123   2.84    2.18     3.5"},{"path":"https://merck.github.io/simtrial/reference/ex3_cure_with_ph.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 3 for non-proportional hazards working group — ex3_cure_with_ph","title":"Time-to-event data example 3 for non-proportional hazards working group — ex3_cure_with_ph","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex3_cure_with_ph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 3 for non-proportional hazards working group — ex3_cure_with_ph","text":"","code":"data(ex3_cure_with_ph)"},{"path":"https://merck.github.io/simtrial/reference/ex3_cure_with_ph.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 3 for non-proportional hazards working group — ex3_cure_with_ph","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex3_cure_with_ph.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 3 for non-proportional hazards working group — ex3_cure_with_ph","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187–198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/ex3_cure_with_ph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 3 for non-proportional hazards working group — ex3_cure_with_ph","text":"","code":"library(survival)  data(ex3_cure_with_ph) km1 <- with(ex3_cure_with_ph, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 137    101   1.05   0.523    1.74 #> trt=1 143     86   1.74   1.158    3.13 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/ex4_belly.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 4 for non-proportional hazards working group — ex4_belly","title":"Time-to-event data example 4 for non-proportional hazards working group — ex4_belly","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex4_belly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 4 for non-proportional hazards working group — ex4_belly","text":"","code":"data(ex4_belly)"},{"path":"https://merck.github.io/simtrial/reference/ex4_belly.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 4 for non-proportional hazards working group — ex4_belly","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex4_belly.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 4 for non-proportional hazards working group — ex4_belly","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187–198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/ex4_belly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 4 for non-proportional hazards working group — ex4_belly","text":"","code":"library(survival)  data(ex4_belly) km1 <- with(ex4_belly, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 387    339   5.40    4.61    5.55 #> trt=1 387    327   6.42    5.81    6.91 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/ex5_widening.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 5 for non-proportional hazards working group — ex5_widening","title":"Time-to-event data example 5 for non-proportional hazards working group — ex5_widening","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex5_widening.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 5 for non-proportional hazards working group — ex5_widening","text":"","code":"data(ex5_widening)"},{"path":"https://merck.github.io/simtrial/reference/ex5_widening.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 5 for non-proportional hazards working group — ex5_widening","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex5_widening.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 5 for non-proportional hazards working group — ex5_widening","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187–198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/ex5_widening.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 5 for non-proportional hazards working group — ex5_widening","text":"","code":"library(survival)  data(ex5_widening) km1 <- with(ex5_widening, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> trt=0 79     65   8.16    6.65    10.3 #> trt=1 86     48  19.97   17.07    26.6 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/ex6_crossing.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 6 for non-proportional hazards working group — ex6_crossing","title":"Time-to-event data example 6 for non-proportional hazards working group — ex6_crossing","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex6_crossing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 6 for non-proportional hazards working group — ex6_crossing","text":"","code":"data(ex6_crossing)"},{"path":"https://merck.github.io/simtrial/reference/ex6_crossing.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 6 for non-proportional hazards working group — ex6_crossing","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/ex6_crossing.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 6 for non-proportional hazards working group — ex6_crossing","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187–198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/ex6_crossing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 6 for non-proportional hazards working group — ex6_crossing","text":"","code":"library(survival)  data(ex6_crossing) km1 <- with(ex6_crossing, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 145    111  10.66    8.83    12.5 #> trt=1 145    113   9.92    7.38    14.3 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/fh.html","id":null,"dir":"Reference","previous_headings":"","what":"Fleming-Harrington weighting function — fh","title":"Fleming-Harrington weighting function — fh","text":"Fleming-Harrington weighting function","code":""},{"path":"https://merck.github.io/simtrial/reference/fh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fleming-Harrington weighting function — fh","text":"","code":"fh(rho = 0, gamma = 0)"},{"path":"https://merck.github.io/simtrial/reference/fh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fleming-Harrington weighting function — fh","text":"rho Non-negative number. rho = 0, gamma = 0 equivalent regular logrank test. gamma Non-negative number. rho = 0, gamma = 0 equivalent regular logrank test.","code":""},{"path":"https://merck.github.io/simtrial/reference/fh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fleming-Harrington weighting function — fh","text":"list parameters Fleming-Harrington weighting function","code":""},{"path":"https://merck.github.io/simtrial/reference/fh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fleming-Harrington weighting function — fh","text":"","code":"sim_pw_surv(n = 200) |>   cut_data_by_event(100) |>   wlr(weight = fh(rho = 0, gamma = 1)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=1)\" #>  #> $estimate #> [1] -2.354546 #>  #> $se #> [1] 1.596507 #>  #> $z #> [1] 1.474812 #>  #> $info #> [1] 2.598126 #>  #> $info0 #> [1] 2.625333 #>"},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise exponential survival estimation — fit_pwexp","title":"Piecewise exponential survival estimation — fit_pwexp","text":"Computes survival function, density function, -2 * log-likelihood based input dataset intervals piecewise constant failure rates. Initial version assumes observations right censored events .","code":""},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise exponential survival estimation — fit_pwexp","text":"","code":"fit_pwexp(   srv = Surv(time = ex1_delayed_effect$month, event = ex1_delayed_effect$evntd),   intervals = array(3, 3) )"},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise exponential survival estimation — fit_pwexp","text":"srv Input survival object (see survival::Surv()); note 0 = censored, 1 = event survival::Surv(). intervals Vector containing positive values indicating interval lengths exponential rates assumed. Note final infinite interval added events occur final interval specified.","code":""},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise exponential survival estimation — fit_pwexp","text":"matrix rows containing interval length, estimated rate, -2 * log-likelihood interval.","code":""},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise exponential survival estimation — fit_pwexp","text":"","code":"# Use default arguments for delayed effect example dataset (ex1_delayed_effect) library(survival)  # Example 1 rateall <- fit_pwexp() rateall #>   intervals     ttot event       rate     m2ll #> 1         3 937.1785    97 0.10350216 634.0236 #> 2         3 605.3572    71 0.11728612 446.3257 #> 3         3 346.8482    30 0.08649317 206.8614 #> 4       Inf 254.1148    20 0.07870458 141.6822  # Example 2 # Estimate by treatment effect rate1 <- with(subset(ex1_delayed_effect, trt == 1), fit_pwexp(Surv(month, evntd))) rate0 <- with(subset(ex1_delayed_effect, trt == 0), fit_pwexp(Surv(month, evntd)))  rate1 #>   intervals     ttot event       rate      m2ll #> 1         3 620.4375    64 0.10315302 418.75734 #> 2         3 415.8482    36 0.08657005 248.16970 #> 3         3 256.2053    19 0.07415927 136.85853 #> 4       Inf 205.4186    13 0.06328542  97.76261 rate0 #>   intervals      ttot event      rate      m2ll #> 1         3 316.74106    33 0.1041861 215.26408 #> 2         3 189.50899    35 0.1846878 188.23619 #> 3         3  90.64288    11 0.1213554  68.39871 #> 4       Inf  48.69624     7 0.1437483  41.15568 rate1$rate / rate0$rate #> [1] 0.9900847 0.4687372 0.6110917 0.4402517  # Chi-square test for (any) treatment effect (8 - 4 parameters = 4 df) pchisq(sum(rateall$m2ll) - sum(rate1$m2ll + rate0$m2ll),   df = 4,   lower.tail = FALSE ) #> [1] 0.006424744  # Compare with logrank survdiff(formula = Surv(month, evntd) ~ trt, data = ex1_delayed_effect) #> Call: #> survdiff(formula = Surv(month, evntd) ~ trt, data = ex1_delayed_effect) #>  #>         N Observed Expected (O-E)^2/E (O-E)^2/V #> trt=0 121       86     67.7      4.97      7.35 #> trt=1 240      132    150.3      2.24      7.35 #>  #>  Chisq= 7.3  on 1 degrees of freedom, p= 0.007   # Example 3 # Simple model with 3 rates same for each for 3 months, # different for each treatment after months rate1a <- with(subset(ex1_delayed_effect, trt == 1), fit_pwexp(Surv(month, evntd), 3)) rate0a <- with(subset(ex1_delayed_effect, trt == 0), fit_pwexp(Surv(month, evntd), 3)) rate1a$rate / rate0a$rate #> [1] 0.9900847 0.4808339  m2ll0 <- rateall$m2ll[1] + rate1a$m2ll[2] + rate0a$m2ll[2] m2ll1 <- sum(rate0$m2ll) + sum(rate1$m2ll)  # As a measure of strength, chi-square examines improvement in likelihood pchisq(m2ll0 - m2ll1, df = 5, lower.tail = FALSE) #> [1] 0.741822"},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive analysis date for interim/final analysis given multiple conditions — get_analysis_date","title":"Derive analysis date for interim/final analysis given multiple conditions — get_analysis_date","text":"Derive analysis date interim/final analysis given multiple conditions","code":""},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive analysis date for interim/final analysis given multiple conditions — get_analysis_date","text":"","code":"get_analysis_date(   data,   planned_calendar_time = NA,   target_event_overall = NA,   target_event_per_stratum = NA,   max_extension_for_target_event = NA,   previous_analysis_date = 0,   min_time_after_previous_analysis = NA,   min_n_overall = NA,   min_n_per_stratum = NA,   min_followup = NA )"},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive analysis date for interim/final analysis given multiple conditions — get_analysis_date","text":"data simulated data generated sim_pw_surv(). planned_calendar_time numerical value specifying planned calendar time analysis. target_event_overall numerical value specifying targeted events overall population. target_event_per_stratum named numerical vector specifying targeted events per stratum. max_extension_for_target_event numerical value specifying maximum time extension reach targeted events. previous_analysis_date numerical value specifying previous analysis date. min_time_after_previous_analysis numerical value specifying planned minimum time previous analysis. min_n_overall numerical value specifying minimal overall sample size enrolled kick analysis. min_n_per_stratum named numerical vector specifying minimal sample size enrolled per stratum kick analysis. min_followup numerical value specifying minimal follow-time specified enrollment fraction min_n_overall min_n_per_stratum.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive analysis date for interim/final analysis given multiple conditions — get_analysis_date","text":"numerical value analysis date.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Derive analysis date for interim/final analysis given multiple conditions — get_analysis_date","text":"obtain analysis date, consider following multiple conditions: Condition 1 planned calendar time analysis. Condition 2 targeted events, encompassing overall population stratum-specific events. Condition 3 maximum time extension required achieve targeted events. Condition 4 planned minimum time interval previous analysis. Condition 5 minimum follow-time needed reach certain number patients enrollments. Users flexibility employ 5 conditions simultaneously selectively choose specific conditions determine analysis date. unused conditions default NA affect output. Regardless number conditions used, analysis date determined min(max(date1, date2, date4, date5, na.rm = TRUE), date3, na.rm = TRUE), date1, date2, date3, date4, date5 represent analysis dates determined solely Condition 1, Condition 2, Condition 3, Condition 4 Condition 5, respectively.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive analysis date for interim/final analysis given multiple conditions — get_analysis_date","text":"","code":"library(gsDesign2)  alpha <- 0.025 ratio <- 3 n <- 500 info_frac <- c(0.7, 1) prevalence_ratio <- c(0.4, 0.6) study_duration <- 48  # Two strata stratum <- c(\"Biomarker-positive\", \"Biomarker-negative\")  prevalence_ratio <- c(0.6, 0.4) # enrollment rate enroll_rate <- define_enroll_rate(   stratum = rep(stratum, each = 2),   duration = c(2, 10, 2, 10),   rate = c(c(1, 4) * prevalence_ratio[1], c(1, 4) * prevalence_ratio[2]) ) enroll_rate$rate <- enroll_rate$rate * n / sum(enroll_rate$duration * enroll_rate$rate)  # Failure rate med_pos <- 10 # Median of the biomarker positive population med_neg <- 8 # Median of the biomarker negative population hr_pos <- c(1, 0.7) # Hazard ratio of the biomarker positive population hr_neg <- c(1, 0.8) # Hazard ratio of the biomarker negative population fail_rate <- define_fail_rate(   stratum = rep(stratum, each = 2),   duration = 1000,   fail_rate = c(log(2) / c(med_pos, med_pos, med_neg, med_neg)),   hr = c(hr_pos, hr_neg),   dropout_rate = 0.01 )  # Simulate data temp <- to_sim_pw_surv(fail_rate) # Convert the failure rate set.seed(2023) simulated_data <- sim_pw_surv(   n = n, # Sample size   # Stratified design with prevalence ratio of 6:4   stratum = data.frame(stratum = stratum, p = prevalence_ratio),   # Randomization ratio   block = c(\"control\", \"control\", \"experimental\", \"experimental\"),   enroll_rate = enroll_rate, # Enrollment rate   fail_rate = temp$fail_rate, # Failure rate   dropout_rate = temp$dropout_rate # Dropout rate )  # Example 1: Cut for analysis at the 24th month. # Here, we only utilize the `planned_calendar_time = 24` argument, # while leaving the remaining unused arguments as their default value of `NA`. get_analysis_date(   simulated_data,   planned_calendar_time = 24 ) #> [1] 24  # Example 2: Cut for analysis when there are 300 events in the overall population. # Here, we only utilize the `target_event_overall = 300` argument, # while leaving the remaining unused arguments as their default value of `NA`. get_analysis_date(   simulated_data,   target_event_overall = 300 ) #> [1] 25.61506  # Example 3: Cut for analysis at the 24th month and there are 300 events # in the overall population, whichever arrives later. # Here, we only utilize the `planned_calendar_time = 24` and # `target_event_overall = 300` argument, # while leaving the remaining unused arguments as their default value of `NA`. get_analysis_date(   simulated_data,   planned_calendar_time = 24,   target_event_overall = 300 ) #> [1] 25.61506  # Example 4a: Cut for analysis when there are at least 100 events # in the biomarker-positive population, and at least 200 events # in the biomarker-negative population, whichever arrives later. # Here, we only utilize the `target_event_per_stratum = c(100, 200)`, # which refers to 100 events in the biomarker-positive population, # and 200 events in the biomarker-negative population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by the number of events # in each stratum. get_analysis_date(   simulated_data,   target_event_per_stratum = c(\"Biomarker-positive\" = 100, \"Biomarker-negative\" = 200) ) #> [1] 59.1661 # Example 4b: Cut for analysis when there are at least 100 events # in the biomarker-positive population, but we don't have a requirement # for the biomarker-negative population. Additionally, we want to cut # the analysis when there are at least 150 events in total. # Here, we only utilize the `target_event_overall = 150` and # `target_event_per_stratum = c(100, NA)`, which refers to 100 events # in the biomarker-positive population, and there is event requirement # for the biomarker-negative population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by the number of events # in the biomarker-positive population, and the total number of events, # which arrives later. get_analysis_date(   simulated_data,   target_event_overall = 150,   target_event_per_stratum = c(\"Biomarker-positive\" = 100, \"Biomarker-negative\" = NA) ) #> [1] 18.30272 # Example 4c: Cut for analysis when there are at least 100 events # in the biomarker-positive population, but we don't have a requirement # for the biomarker-negative population. Additionally, we want to cut # the analysis when there are at least 150 events in total and after 24 months. # Here, we only utilize the `planned_calendar_time = 24`, # `target_event_overall = 150` and # `target_event_per_stratum = c(100, NA)`, which refers to 100 events # in the biomarker-positive population, and there is event requirement # for the biomarker-negative population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by the number of events # in the biomarker-positive population, the total number of events, and # planned calendar time, which arrives later. get_analysis_date(   simulated_data,   planned_calendar_time = 24,   target_event_overall = 150,   target_event_per_stratum = c(\"Biomarker-positive\" = 100, \"Biomarker-negative\" = NA) ) #> [1] 24  # Example 5: Cut for analysis when there are at least 100 events # in the biomarker positive population, and at least 200 events # in the biomarker negative population, whichever arrives later. # But will stop at the 30th month if events are fewer than 100/200. # Here, we only utilize the `max_extension_for_target_event = 30`, # and `target_event_per_stratum =  c(100, 200)`, which refers to # 100/200 events in the biomarker-positive/negative population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by the number of events # in the 2 strata, and the max extension to arrive at the targeted # events, which arrives later. get_analysis_date(   simulated_data,   target_event_per_stratum = c(\"Biomarker-positive\" = 100, \"Biomarker-negative\" = 200),   max_extension_for_target_event = 30 ) #> [1] 30  # Example 6a: Cut for analysis after 12 months followup when 80% # of the patients are enrolled in the overall population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by # 12 months + time when 80% patients enrolled. get_analysis_date(   simulated_data,   min_n_overall = n * 0.8,   min_followup = 12 ) #> [1] 28.82521 # Example 6b: Cut for analysis after 12 months followup when 80% # of the patients are enrolled in the overall population. Besides, # the analysis happens when there are at least 150 events in total. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by the total number of events, # and 12 months + time when 80% patients enrolled, which arrives later. get_analysis_date(   simulated_data,   target_event_overall = 150,   min_n_overall = n * 0.8,   min_followup = 12 ) #> [1] 28.82521  # Example 7a: Cut for analysis when 12 months after at least 200/160 patients # are enrolled in the biomarker positive/negative population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by 12 months + time when there are # 200/160 patients enrolled in the biomarker-positive/negative stratum. get_analysis_date(   simulated_data,   min_n_per_stratum =  c(\"Biomarker-negative\" = 200, \"Biomarker-positive\" = 160),   min_followup = 12 ) #> [1] 32.88461 # Example 7b: Cut for analysis when 12 months after at least 200 patients # are enrolled in the biomarker positive population, but we don't have a # specific requirement for the biomarker negative population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by 12 months + time when there are # 200 patients enrolled in the biomarker-positive stratum. get_analysis_date(   simulated_data,   min_n_per_stratum = c(\"Biomarker-negative\" = 200, \"Biomarker-positive\" = NA),   min_followup = 12 ) #> [1] 32.88461 # Example 7c: Cut for analysis when 12 months after at least 200 patients # are enrolled in the biomarker-positive population, but we don't have a # specific requirement for the biomarker-negative population. We also want # there are at least 80% of the patients enrolled in the overall population. # The remaining unused arguments as their default value of `NA`, # so the analysis date is only decided by 12 months + max(time when there are # 200 patients enrolled in the biomarker-positive stratum, time when there are # 80% patients enrolled). get_analysis_date(   simulated_data,   min_n_overall = n * 0.8,   min_n_per_stratum = c(\"Biomarker-negative\" = 200, \"Biomarker-positive\" = NA),   min_followup = 12 ) #> [1] 32.88461"},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Get date at which an event count is reached — get_cut_date_by_event","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"Get date event count reached","code":""},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"","code":"get_cut_date_by_event(x, event)"},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"x time--event dataset, example, generated sim_pw_surv(). event Event count dataset cut analysis.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"numeric value cte input dataset targeted event count reached, final event count never reached, final cte event occurs.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  # Use default enrollment and calendar cut date # for 50 events in the \"Positive\" stratum x <- sim_pw_surv(   n = 200,   stratum = data.frame(     stratum = c(\"Positive\", \"Negative\"),     p = c(.5, .5)   ),   fail_rate = data.frame(     stratum = rep(c(\"Positive\", \"Negative\"), 2),     period = rep(1, 4),     treatment = c(rep(\"control\", 2), rep(\"experimental\", 2)),     duration = rep(1, 4),     rate = log(2) / c(6, 9, 9, 12)   ),   dropout_rate = data.frame(     stratum = rep(c(\"Positive\", \"Negative\"), 2),     period = rep(1, 4),     treatment = c(rep(\"control\", 2), rep(\"experimental\", 2)),     duration = rep(1, 4),     rate = rep(.001, 4)   ) )  d <- get_cut_date_by_event(x |> filter(stratum == \"Positive\"), event = 50)  y <- cut_data_by_date(x, cut_date = d) table(y$stratum, y$event) #>            #>             0  1 #>   Negative 50 44 #>   Positive 34 50"},{"path":"https://merck.github.io/simtrial/reference/maxcombo.html","id":null,"dir":"Reference","previous_headings":"","what":"MaxCombo test — maxcombo","title":"MaxCombo test — maxcombo","text":"WARNING: experimental function work--progress. function arguments change add additional features.","code":""},{"path":"https://merck.github.io/simtrial/reference/maxcombo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MaxCombo test — maxcombo","text":"","code":"maxcombo(   data = cut_data_by_event(sim_pw_surv(n = 200), 150),   rho = c(0, 0, 1),   gamma = c(0, 1, 1),   return_variance = FALSE,   return_corr = FALSE )"},{"path":"https://merck.github.io/simtrial/reference/maxcombo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MaxCombo test — maxcombo","text":"data TTE dataset. rho Numeric vector. Must greater equal zero. Must length gamma. gamma Numeric vector. Must greater equal zero. Must length rho. return_variance logical flag , TRUE, adds columns estimated variance weighted sum observed minus expected; see details; Default: FALSE. return_corr logical flag , TRUE, adds columns estimated correlation weighted sum observed minus expected; see details; Default: FALSE.","code":""},{"path":"https://merck.github.io/simtrial/reference/maxcombo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MaxCombo test — maxcombo","text":"list containing test method (method), parameters test method (parameter), point estimate treatment effect (estimate), standardized error treatment effect (se), Z-score test MaxCombo (z), p-values (p_value) correlation matrix tests MaxCombo (begin v)","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/maxcombo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MaxCombo test — maxcombo","text":"","code":"sim_pw_surv(n = 200) |>   cut_data_by_event(150) |>   maxcombo(rho = c(0, 0), gamma = c(0, 1), return_corr = TRUE) #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 0) + FH(0, 1)\" #>  #> $z #> [1] -1.429270 -1.925974 #>  #> $corr #>          v1        v2 #> 1 1.0000000 0.8572258 #> 2 0.8572258 1.0000000 #>  #> $p_value #> [1] 0.03992553 #>"},{"path":"https://merck.github.io/simtrial/reference/mb.html","id":null,"dir":"Reference","previous_headings":"","what":"Magirr and Burman weighting function — mb","title":"Magirr and Burman weighting function — mb","text":"Magirr Burman weighting function","code":""},{"path":"https://merck.github.io/simtrial/reference/mb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magirr and Burman weighting function — mb","text":"","code":"mb(delay = 4, w_max = Inf)"},{"path":"https://merck.github.io/simtrial/reference/mb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Magirr and Burman weighting function — mb","text":"delay initial delay period weights increase; , weights constant final weight delay period. w_max Maximum weight returned. Set delay = Inf, w_max = 2 consistent recommendation Magirr (2021).","code":""},{"path":"https://merck.github.io/simtrial/reference/mb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Magirr and Burman weighting function — mb","text":"list parameters Magirr Burman weighting function","code":""},{"path":"https://merck.github.io/simtrial/reference/mb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Magirr and Burman weighting function — mb","text":"Magirr Burman (2019) proposed weighted logrank test better power logrank test treatment effect delayed, still maintain good power proportional hazards assumption. Magirr (2021), (equivalent ) maximum weight proposed opposed fixed time duration weights increase. weights early interval specified user inverse combined treatment group empirical survival distribution; see details. initial period, weights constant maximum previous weights. Another advantage test strong null hypothesis underlying survival control group greater equal underlying survival experimental group, Type error controlled specified level. define \\(t^*\\) input variable delay. specifies initial period weights increase. also set maximum weight \\(w_{\\max}\\). define specific weights, let \\(S(t)\\) denote Kaplan-Meier survival estimate time \\(t\\) combined data (control plus experimental treatment groups). weight time \\(t\\) defined $$w(t)=\\min(w_{\\max}, S(\\min(t, t^*))^{-1}).$$","code":""},{"path":"https://merck.github.io/simtrial/reference/mb.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Magirr and Burman weighting function — mb","text":"Magirr, Dominic, Carl‐Fredrik Burman. 2019. \"Modestly weighted logrank tests.\" Statistics Medicine 38 (20): 3782–3790. Magirr, Dominic. 2021. \"Non‐proportional hazards immuno‐oncology: old perspective needed?\" Pharmaceutical Statistics 20 (3): 512–527.","code":""},{"path":"https://merck.github.io/simtrial/reference/mb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Magirr and Burman weighting function — mb","text":"","code":"sim_pw_surv(n = 200) |>   cut_data_by_event(100) |>   wlr(weight = mb(delay = 8, w_max = Inf)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"MB(delay = 8, max_weight = Inf)\" #>  #> $estimate #> [1] -12.94058 #>  #> $se #> [1] 6.689765 #>  #> $z #> [1] 1.934385 #>  #> $info #> [1] 44.70922 #>  #> $info0 #> [1] 45.36046 #>"},{"path":"https://merck.github.io/simtrial/reference/mb_delayed_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated survival dataset with delayed treatment effect — mb_delayed_effect","title":"Simulated survival dataset with delayed treatment effect — mb_delayed_effect","text":"Magirr Burman (2019) considered several scenarios modestly weighted logrank test. One delayed treatment effect hazard ratio 1 6 months followed hazard ratio 1/2 thereafter. scenario enrolled 200 patients uniformly 12 months cut data analysis 36 months enrollment opened. dataset generated sim_pw_surv() function scenario.","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_delayed_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated survival dataset with delayed treatment effect — mb_delayed_effect","text":"","code":"mb_delayed_effect"},{"path":"https://merck.github.io/simtrial/reference/mb_delayed_effect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated survival dataset with delayed treatment effect — mb_delayed_effect","text":"data frame 200 rows 4 columns: tte: Time event.","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_delayed_effect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated survival dataset with delayed treatment effect — mb_delayed_effect","text":"Magirr, Dominic, Carl‐Fredrik Burman. 2019. \"Modestly weighted logrank tests.\" Statistics Medicine 38 (20): 3782–3790.","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_delayed_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated survival dataset with delayed treatment effect — mb_delayed_effect","text":"","code":"library(survival)  fit <- survfit(Surv(tte, event) ~ treatment, data = mb_delayed_effect)  # Plot survival plot(fit, lty = 1:2) legend(\"topright\", legend = c(\"control\", \"experimental\"), lty = 1:2)   # Set up time, event, number of event dataset for testing # with arbitrary weights ten <- mb_delayed_effect |> counting_process(arm = \"experimental\") head(ten) #>   stratum event_total event_trt        tte n_risk_total n_risk_trt     s #> 1     All           1         1 0.07659251          200        100 1.000 #> 2     All           1         0 0.49067015          199         99 0.995 #> 3     All           1         1 0.65465035          198         99 0.990 #> 4     All           1         0 0.65906384          197         98 0.985 #> 5     All           1         1 0.81945349          196         98 0.980 #> 6     All           1         0 0.82788909          195         97 0.975 #>    o_minus_e var_o_minus_e #> 1  0.5000000     0.2500000 #> 2 -0.4974874     0.2499937 #> 3  0.5000000     0.2500000 #> 4 -0.4974619     0.2499936 #> 5  0.5000000     0.2500000 #> 6 -0.4974359     0.2499934  # MaxCombo with logrank, FH(0,1), FH(1,1) mb_delayed_effect |>   maxcombo(rho = c(0, 0, 1), gamma = c(0, 1, 1), return_corr = TRUE) #> $method #> [1] \"MaxCombo\" #>  #> $parameter #> [1] \"FH(0, 0) + FH(0, 1) + FH(1, 1)\" #>  #> $z #> [1] -2.473248 -2.424018 -2.482653 #>  #> $corr #>          v1        v2        v3 #> 1 1.0000000 0.8606625 0.9312916 #> 2 0.8606625 1.0000000 0.9579831 #> 3 0.9312916 0.9579831 1.0000000 #>  #> $p_value #> [1] 0.01104817 #>   # Generate another dataset ds <- sim_pw_surv(   n = 200,   enroll_rate = data.frame(rate = 200 / 12, duration = 12),   fail_rate = data.frame(     stratum = c(\"All\", \"All\", \"All\"),     period = c(1, 1, 2),     treatment = c(\"control\", \"experimental\", \"experimental\"),     duration = c(42, 6, 36),     rate = c(log(2) / 15, log(2) / 15, log(2) / 15 * 0.6)   ),   dropout_rate = data.frame(     stratum = c(\"All\", \"All\"),     period = c(1, 1),     treatment = c(\"control\", \"experimental\"),     duration = c(42, 42),     rate = c(0, 0)   ) ) # Cut data at 24 months after final enrollment mb_delayed_effect_2 <- ds |> cut_data_by_date(max(ds$enroll_time) + 24)"},{"path":"https://merck.github.io/simtrial/reference/milestone.html","id":null,"dir":"Reference","previous_headings":"","what":"Milestone test for two survival curves — milestone","title":"Milestone test for two survival curves — milestone","text":"Milestone test two survival curves","code":""},{"path":"https://merck.github.io/simtrial/reference/milestone.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Milestone test for two survival curves — milestone","text":"","code":"milestone(data, ms_time, test_type = c(\"log-log\", \"naive\"))"},{"path":"https://merck.github.io/simtrial/reference/milestone.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Milestone test for two survival curves — milestone","text":"data Data frame containing least 3 columns: tte - Time event. event - Event indicator. treatment - Grouping variable. ms_time Milestone analysis time. test_type Method build test statistics. 2 options: \"naive\": naive approach dividing KM survival difference standard derivations, see equation (1) Klein, J. P., Logan, B., Harhoff, M., & Andersen, P. K. (2007). \"log-log\": log-log transformation survival, see equation (3) Klein, J. P., Logan, B., Harhoff, M., & Andersen, P. K. (2007).","code":""},{"path":"https://merck.github.io/simtrial/reference/milestone.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Milestone test for two survival curves — milestone","text":"list frame containing: method - method, always \"milestone\". parameter - Milestone time point. estimate - Survival difference experimental control arm. se - Standard error control experimental arm. z - Test statistics.","code":""},{"path":"https://merck.github.io/simtrial/reference/milestone.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Milestone test for two survival curves — milestone","text":"Klein, J. P., Logan, B., Harhoff, M., & Andersen, P. K. (2007). \"Analyzing survival curves fixed point time.\" Statistics Medicine, 26(24), 4505–4519.","code":""},{"path":"https://merck.github.io/simtrial/reference/milestone.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Milestone test for two survival curves — milestone","text":"","code":"cut_data <- sim_pw_surv(n = 200) |>   cut_data_by_event(150)  cut_data |>   milestone(10, test_type = \"log-log\") #> $method #> [1] \"milestone\" #>  #> $parameter #> [1] 10 #>  #> $estimate #> [1] 0.3090112 #>  #> $se #> [1] 0.2084854 #>  #> $z #> [1] 1.482171 #>   cut_data |>   milestone(10, test_type = \"naive\") #> $method #> [1] \"milestone\" #>  #> $parameter #> [1] 10 #>  #> $estimate #> [1] 0.105612 #>  #> $se #> [1] 0.07066159 #>  #> $z #> [1] 1.494617 #>"},{"path":"https://merck.github.io/simtrial/reference/multitest.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform multiple tests on trial data cutting — multitest","title":"Perform multiple tests on trial data cutting — multitest","text":"WARNING: experimental function work--progress. function arguments /returned output format may change add additional features.","code":""},{"path":"https://merck.github.io/simtrial/reference/multitest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform multiple tests on trial data cutting — multitest","text":"","code":"multitest(data, ...)"},{"path":"https://merck.github.io/simtrial/reference/multitest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform multiple tests on trial data cutting — multitest","text":"data Trial data cut cut_data_by_event() cut_data_by_date() ... One test functions. Use create_test() change default arguments test function.","code":""},{"path":"https://merck.github.io/simtrial/reference/multitest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform multiple tests on trial data cutting — multitest","text":"list test results, one per test. test functions named call multitest(), returned list uses names.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/multitest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform multiple tests on trial data cutting — multitest","text":"","code":"trial_data <- sim_pw_surv(n = 200) trial_data_cut <- cut_data_by_event(trial_data, 150)  # create cutting test functions wlr_partial <- create_test(wlr, weight = fh(rho = 0, gamma = 0)) rmst_partial <- create_test(rmst, tau = 20) maxcombo_partial <- create_test(maxcombo, rho = c(0, 0), gamma = c(0, 0.5))  multitest(   data = trial_data_cut,   wlr = wlr_partial,   rmst = rmst_partial,   maxcombo = maxcombo_partial ) #> $wlr #> $wlr$method #> [1] \"WLR\" #>  #> $wlr$parameter #> [1] \"FH(rho=0, gamma=0)\" #>  #> $wlr$estimate #> [1] -21.51717 #>  #> $wlr$se #> [1] 5.971903 #>  #> $wlr$z #> [1] 3.603067 #>  #> $wlr$info #> [1] 36.96 #>  #> $wlr$info0 #> [1] 37.5 #>  #>  #> $rmst #> $rmst$method #> [1] \"RMST\" #>  #> $rmst$parameter #> [1] 20 #>  #> $rmst$estimate #> [1] 3.504274 #>  #> $rmst$se #> [1] 1.064673 #>  #> $rmst$z #> [1] 3.291409 #>  #>  #> $maxcombo #> $maxcombo$method #> [1] \"MaxCombo\" #>  #> $maxcombo$parameter #> [1] \"FH(0, 0) + FH(0, 0.5)\" #>  #> $maxcombo$z #> [1] -3.603067 -3.567134 #>  #> $maxcombo$p_value #> [1] 0.0002371133 #>  #>"},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":null,"dir":"Reference","previous_headings":"","what":"Permuted fixed block randomization — randomize_by_fixed_block","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"Fixed block randomization. block input repeat treatment code number times included within block. final block partial block n exact multiple block length.","code":""},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"","code":"randomize_by_fixed_block(n = 10, block = c(0, 0, 1, 1))"},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"n Sample size randomized. block Vector treatments included block.","code":""},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"treatment group sequence (vector) length n treatments block permuted within block block size equal length block.","code":""},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"","code":"library(dplyr)  # Example 1 # 2:1 randomization with block size 3, treatments \"A\" and \"B\" data.frame(x = 1:10) |> mutate(Treatment = randomize_by_fixed_block(block = c(\"A\", \"B\", \"B\"))) #>     x Treatment #> 1   1         B #> 2   2         B #> 3   3         A #> 4   4         A #> 5   5         B #> 6   6         B #> 7   7         B #> 8   8         A #> 9   9         B #> 10 10         A  # Example 2 # Stratified randomization data.frame(stratum = c(rep(\"A\", 10), rep(\"B\", 10))) |>   group_by(stratum) |>   mutate(Treatment = randomize_by_fixed_block()) #> # A tibble: 20 × 2 #> # Groups:   stratum [2] #>    stratum Treatment #>    <chr>       <dbl> #>  1 A               1 #>  2 A               1 #>  3 A               0 #>  4 A               0 #>  5 A               1 #>  6 A               0 #>  7 A               0 #>  8 A               1 #>  9 A               1 #> 10 A               0 #> 11 B               1 #> 12 B               0 #> 13 B               1 #> 14 B               0 #> 15 B               0 #> 16 B               1 #> 17 B               0 #> 18 B               1 #> 19 B               1 #> 20 B               0"},{"path":"https://merck.github.io/simtrial/reference/rmst.html","id":null,"dir":"Reference","previous_headings":"","what":"RMST difference of 2 arms — rmst","title":"RMST difference of 2 arms — rmst","text":"RMST difference 2 arms","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RMST difference of 2 arms — rmst","text":"","code":"rmst(   data,   tau = 10,   var_label_tte = \"tte\",   var_label_event = \"event\",   var_label_group = \"treatment\",   formula = NULL,   reference = \"control\",   alpha = 0.05 )"},{"path":"https://merck.github.io/simtrial/reference/rmst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RMST difference of 2 arms — rmst","text":"data time--event dataset column tte indicating survival time column event indicating whether event censor. tau RMST analysis time. var_label_tte Column name TTE variable. var_label_event Column name event variable. var_label_group Column name grouping variable. formula (default: NULL) formula indicates TTE, event, group variables using syntax Surv(tte, event) ~ group) (see Details information). alternative specifying variables strings. formula provided, values passed var_label_tte, var_label_event, var_label_group ignored. reference group label indicating reference group. alpha Type error.","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RMST difference of 2 arms — rmst","text":"z statistics.","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"RMST difference of 2 arms — rmst","text":"argument formula provided convenience easily specify TTE, event, grouping variables using syntax Surv(tte, event) ~ group). Surv() {survival} package (survival::Surv()). can also explicitly name arguments passed Surv(), example following equivalent Surv(event = event, time = tte) ~ group). Note however function Surv() never actually executed. Similarly, functions applied formula also ignored, thus apply transformation functions log() since effect.","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RMST difference of 2 arms — rmst","text":"","code":"data(ex1_delayed_effect) rmst(   data = ex1_delayed_effect,   var_label_tte = \"month\",   var_label_event = \"evntd\",   var_label_group = \"trt\",   tau = 10,   reference = \"0\" ) #> $method #> [1] \"RMST\" #>  #> $parameter #> [1] 10 #>  #> $estimate #> [1] 0.8650493 #>  #> $se #> [1] 0.3900344 #>  #> $z #> [1] 2.21788 #>   # Formula interface rmst(   data = ex1_delayed_effect,   formula = Surv(month, evntd) ~ trt,   tau = 10,   reference = \"0\" ) #> $method #> [1] \"RMST\" #>  #> $parameter #> [1] 10 #>  #> $estimate #> [1] 0.8650493 #>  #> $se #> [1] 0.3900344 #>  #> $z #> [1] 2.21788 #>"},{"path":"https://merck.github.io/simtrial/reference/rmst_single_arm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate RMST for a single cut-off time point — rmst_single_arm","title":"Calculate RMST for a single cut-off time point — rmst_single_arm","text":"Calculate RMST single cut-time point","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst_single_arm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate RMST for a single cut-off time point — rmst_single_arm","text":"","code":"rmst_single_arm(   time_var,   event_var,   tau,   group_label = \"Single Group\",   alpha = 0.05 )"},{"path":"https://merck.github.io/simtrial/reference/rmst_single_arm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate RMST for a single cut-off time point — rmst_single_arm","text":"time_var numeric vector follow time. event_var numeric integer vector status indicator; 0=alive 1=event. tau value pre-defined cut-time point. group_label character customized treatment group name. alpha numeric value significant level RMST confidence interval. Default 0.05.","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst_single_arm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate RMST for a single cut-off time point — rmst_single_arm","text":"data frame Cutoff time: tau; Group label: group_label; Estimated RMST; Variance, standard error, CIs estimated RMST; Number events.","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst_single_arm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate RMST for a single cut-off time point — rmst_single_arm","text":"","code":"data(ex1_delayed_effect) data_single_arm <- ex1_delayed_effect[ex1_delayed_effect$trt == 1, ] simtrial:::rmst_single_arm(   time_var = data_single_arm$month,   event_var = data_single_arm$evntd,   tau = 10,   group_label = \"Treatment 1\",   alpha = 0.05 ) #>   cutoff_time       group     rmst   variance       std      lcl      ucl event #> 1          10 Treatment 1 6.495175 0.05711322 0.2389837 6.026776 6.963575   127"},{"path":"https://merck.github.io/simtrial/reference/rmst_two_arm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate RMST difference — rmst_two_arm","title":"Calculate RMST difference — rmst_two_arm","text":"Calculate RMST difference","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst_two_arm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate RMST difference — rmst_two_arm","text":"","code":"rmst_two_arm(   time_var,   event_var,   group_var,   trunc_time,   reference = sort(unique(group_var))[1],   alpha = 0.05 )"},{"path":"https://merck.github.io/simtrial/reference/rmst_two_arm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate RMST difference — rmst_two_arm","text":"time_var numeric vector follow time. event_var numeric integer vector status indicator; 0=alive 1=event. group_var vector treatment groups. trunc_time numeric vector pre-defined cut-time point(s). reference Group name reference group RMST comparison. Default first group name alphabetical order. alpha numeric value significant level RMST confidence interval. Default 0.05.","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst_two_arm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate RMST difference — rmst_two_arm","text":"list 2 data frames RMST calculations: rmst_per_arm: calculation results per group. rmst_diff: calculation results RMST differences.","code":""},{"path":"https://merck.github.io/simtrial/reference/rmst_two_arm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate RMST difference — rmst_two_arm","text":"","code":"data(ex1_delayed_effect) with(   ex1_delayed_effect,   simtrial:::rmst_two_arm(     time_var = month,     event_var = evntd,     group_var = trt,     trunc_time = 6,     reference = \"0\",     alpha = 0.05   ) ) #> $rmst_per_arm #>   cutoff_time group     rmst   variance       std      lcl      ucl event #> 1           6     0 4.340067 0.02902105 0.1703557 4.006176 4.673958    68 #> 2           6     1 4.552177 0.01607455 0.1267854 4.303682 4.800672   100 #>  #> $rmst_diff #>   cutoff_time group rmst_diff  variance       std        lcl       ucl #> 1           6 1 - 0 0.2121097 0.0450956 0.2123572 -0.2041029 0.6283222 #>"},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":null,"dir":"Reference","previous_headings":"","what":"The piecewise exponential distribution — rpwexp","title":"The piecewise exponential distribution — rpwexp","text":"piecewise exponential distribution allows simple method specify distribution hazard rate changes time. likely useful conditions failure rates change, also simulations may delayed treatment effect treatment effect otherwise changing (example, decreasing) time. rpwexp() support simulation Lachin Foulkes (1986) sample size method (fixed trial duration) well Kim Tsiatis (1990) method (fixed enrollment rates either fixed enrollment duration fixed minimum follow-); see gsDesign::nSurv().","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The piecewise exponential distribution — rpwexp","text":"","code":"rpwexp(n = 100, fail_rate = data.frame(duration = c(1, 1), rate = c(10, 20)))"},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The piecewise exponential distribution — rpwexp","text":"n Number observations generated. fail_rate data frame containing duration rate variables. rate specifies failure rates corresponding interval duration specified duration. final interval extended infinite ensure observations generated.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The piecewise exponential distribution — rpwexp","text":"generated random numbers.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The piecewise exponential distribution — rpwexp","text":"Using cumulative = TRUE option, enrollment times piecewise constant time can generated.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The piecewise exponential distribution — rpwexp","text":"","code":"# Example 1 # Exponential failure times x <- rpwexp(   n = 10000,   fail_rate = data.frame(rate = 5, duration = 1) ) plot(sort(x), (10000:1) / 10001,   log = \"y\", main = \"Exponential simulated survival curve\",   xlab = \"Time\", ylab = \"P{Survival}\" )   # Example 2  # Get 10k piecewise exponential failure times. # Failure rates are 1 for time 0 to 0.5, 3 for time 0.5 to 1, and 10 for > 1. # Intervals specifies duration of each failure rate interval # with the final interval running to infinity. x <- rpwexp(   n = 1e4,   fail_rate = data.frame(rate = c(1, 3, 10), duration = c(.5, .5, 1)) ) plot(sort(x), (1e4:1) / 10001,   log = \"y\", main = \"PW Exponential simulated survival curve\",   xlab = \"Time\", ylab = \"P{Survival}\" )"},{"path":"https://merck.github.io/simtrial/reference/rpwexp_enroll.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate piecewise exponential enrollment — rpwexp_enroll","title":"Generate piecewise exponential enrollment — rpwexp_enroll","text":"piecewise exponential enrollment rate generation enrollment rate distribution can easily approximated. rpwexp_enroll() support simulation Lachin Foulkes (1986) sample size method (fixed trial duration) well Kim Tsiatis(1990) method (fixed enrollment rates either fixed enrollment duration fixed minimum follow-); see gsDesign::nSurv().","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp_enroll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate piecewise exponential enrollment — rpwexp_enroll","text":"","code":"rpwexp_enroll(   n = NULL,   enroll_rate = data.frame(duration = c(1, 2), rate = c(2, 5)) )"},{"path":"https://merck.github.io/simtrial/reference/rpwexp_enroll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate piecewise exponential enrollment — rpwexp_enroll","text":"n Number observations. Default NULL yields random enrollment size. enroll_rate data frame containing period duration (duration) enrollment rate (rate). specified enrollment periods. necessary, last period extended ensure enrollment specified n.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp_enroll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate piecewise exponential enrollment — rpwexp_enroll","text":"vector random enrollment times.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp_enroll.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate piecewise exponential enrollment — rpwexp_enroll","text":"","code":"# Example 1 # Piecewise uniform (piecewise exponential inter-arrival times) for 10k patients enrollment # Enrollment rates of 5 for time 0-100, 15 for 100-300, and 30 thereafter x <- rpwexp_enroll(   n = 1e5,   enroll_rate = data.frame(     rate = c(5, 15, 30),     duration = c(100, 200, 100)   ) ) plot(x, 1:1e5,   main = \"Piecewise uniform enrollment simulation\",   xlab = \"Time\",   ylab = \"Enrollment\" )   # Example 2 # Exponential enrollment x <- rpwexp_enroll(   n = 1e5,   enroll_rate = data.frame(rate = .03, duration = 1) ) plot(x, 1:1e5,   main = \"Simulated exponential inter-arrival times\",   xlab = \"Time\",   ylab = \"Enrollment\" )"},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"sim_fixed_n() provides simulations single endpoint two-arm trial enrollment, hazard ratio, failure dropout rates change time.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"","code":"sim_fixed_n(   n_sim = 1000,   sample_size = 500,   target_event = 350,   stratum = data.frame(stratum = \"All\", p = 1),   enroll_rate = data.frame(duration = c(2, 2, 10), rate = c(3, 6, 9)),   fail_rate = data.frame(stratum = \"All\", duration = c(3, 100), fail_rate = log(2)/c(9,     18), hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)),   total_duration = 30,   block = rep(c(\"experimental\", \"control\"), 2),   timing_type = 1:5,   rho_gamma = data.frame(rho = 0, gamma = 0) )"},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"n_sim Number simulations perform. sample_size Total sample size per simulation. target_event Targeted event count analysis. stratum data frame stratum specified stratum, probability (incidence) stratum p. enroll_rate Piecewise constant enrollment rates time period. Note overall population enrollment rates stratum argument controls random distribution stratum. fail_rate Piecewise constant control group failure rates, hazard ratio experimental vs. control, dropout rates stratum time period. total_duration Total follow-start enrollment data cutoff. block sim_pw_surv(). Vector treatments included block. timing_type numeric vector determining data cutoffs used; see details. Default include available cutoff methods. rho_gamma data frame variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted logrank test per row.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"data frame including columns: event: Event count. ln_hr: Log-hazard ratio. z: Normal test statistic; < 0 favors experimental. cut: Text describing cutoff used. duration: Duration trial cutoff analysis. sim: Sequential simulation ID. One row per simulated dataset per cutoff specified timing_type, per test statistic specified. multiple Fleming-Harrington tests specified rho_gamma, columns rho gamma also included.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"timing_type 5 elements indicating different options data cutoff: 1: Uses planned study duration. 2: time targeted event count achieved. 3: planned minimum follow-enrollment complete. 4: maximum planned study duration targeted event count cuts (1 2). 5: maximum targeted event count minimum follow-cuts (2 3).","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"","code":"library(dplyr) library(future)  # Example 1: logrank test ---- x <- sim_fixed_n(n_sim = 10, timing_type = 1, rho_gamma = data.frame(rho = 0, gamma = 0)) #> Backend uses sequential processing. # Get power approximation mean(x$z <= qnorm(.025)) #> [1] 0  # Example 2: WLR with FH(0,1) ---- sim_fixed_n(n_sim = 1, timing_type = 1, rho_gamma = data.frame(rho = 0, gamma = 1)) #> Backend uses sequential processing. #>   method          parameter    estimate       se          z event      ln_hr #> 1    WLR FH(rho=0, gamma=1) -0.03587586 1.351219 0.02655074   103 -0.1042096 #>                cut duration sim #> 1 Planned duration       30   1 # Get power approximation mean(x$z <= qnorm(.025)) #> [1] 0  # \\donttest{ # Example 3: MaxCombo, i.e., WLR-FH(0,0)+ WLR-FH(0,1) # Power by test # Only use cuts for events, events + min follow-up x <- sim_fixed_n(   n_sim = 10,   timing_type = 2,   rho_gamma = data.frame(rho = 0, gamma = c(0, 1)) ) #> Backend uses sequential processing.  # Get power approximation x |>   group_by(sim) |>   filter(row_number() == 1) |>   ungroup() |>   summarize(power = mean(p_value < .025)) #> # A tibble: 1 × 1 #>   power #>   <dbl> #> 1     1  # Example 4 # Use two cores set.seed(2023) plan(\"multisession\", workers = 2) sim_fixed_n(n_sim = 10) #> Using 2 cores with backend multisession #>    method          parameter   estimate       se         z event      ln_hr #> 1     WLR FH(rho=0, gamma=0)  -9.044800 5.213492 1.7348832   109 -0.3342849 #> 2     WLR FH(rho=0, gamma=0) -41.170785 9.229540 4.4607622   350 -0.4793575 #> 3     WLR FH(rho=0, gamma=0) -41.444949 9.546994 4.3411518   376 -0.4498374 #> 4     WLR FH(rho=0, gamma=0) -41.170785 9.229540 4.4607622   350 -0.4793575 #> 5     WLR FH(rho=0, gamma=0) -41.444949 9.546994 4.3411518   376 -0.4498374 #> 6     WLR FH(rho=0, gamma=0)  -5.248725 5.068148 1.0356297   103 -0.2047494 #> 7     WLR FH(rho=0, gamma=0) -33.266167 9.245312 3.5981660   350 -0.3873648 #> 8     WLR FH(rho=0, gamma=0) -35.663072 9.468334 3.7665623   367 -0.3953215 #> 9     WLR FH(rho=0, gamma=0) -33.266167 9.245312 3.5981660   350 -0.3873648 #> 10    WLR FH(rho=0, gamma=0) -35.663072 9.468334 3.7665623   367 -0.3953215 #> 11    WLR FH(rho=0, gamma=0) -18.821290 4.838510 3.8898935    95 -0.8181040 #> 12    WLR FH(rho=0, gamma=0) -55.442685 9.055033 6.1228581   350 -0.6662357 #> 13    WLR FH(rho=0, gamma=0) -55.753830 9.043216 6.1652657   349 -0.6719858 #> 14    WLR FH(rho=0, gamma=0) -55.442685 9.055033 6.1228581   350 -0.6662357 #> 15    WLR FH(rho=0, gamma=0) -55.442685 9.055033 6.1228581   350 -0.6662357 #> 16    WLR FH(rho=0, gamma=0)  -3.064636 5.228765 0.5861109   110 -0.1120785 #> 17    WLR FH(rho=0, gamma=0) -33.961737 9.264232 3.6658988   350 -0.3939024 #> 18    WLR FH(rho=0, gamma=0) -34.607774 9.536543 3.6289642   372 -0.3781111 #> 19    WLR FH(rho=0, gamma=0) -33.961737 9.264232 3.6658988   350 -0.3939024 #> 20    WLR FH(rho=0, gamma=0) -34.607774 9.536543 3.6289642   372 -0.3781111 #> 21    WLR FH(rho=0, gamma=0) -13.960942 4.823458 2.8943845    94 -0.6069906 #> 22    WLR FH(rho=0, gamma=0) -37.851426 9.213540 4.1082391   350 -0.4410650 #> 23    WLR FH(rho=0, gamma=0) -36.640901 9.184545 3.9894083   348 -0.4296748 #> 24    WLR FH(rho=0, gamma=0) -37.851426 9.213540 4.1082391   350 -0.4410650 #> 25    WLR FH(rho=0, gamma=0) -37.851426 9.213540 4.1082391   350 -0.4410650 #> 26    WLR FH(rho=0, gamma=0) -14.173675 5.030231 2.8176983   103 -0.5638412 #> 27    WLR FH(rho=0, gamma=0) -35.792430 9.171024 3.9027737   350 -0.4227156 #> 28    WLR FH(rho=0, gamma=0) -36.093884 9.190638 3.9272445   351 -0.4245379 #> 29    WLR FH(rho=0, gamma=0) -35.792430 9.171024 3.9027737   350 -0.4227156 #> 30    WLR FH(rho=0, gamma=0) -36.093884 9.190638 3.9272445   351 -0.4245379 #> 31    WLR FH(rho=0, gamma=0)  -4.479885 5.189040 0.8633360   108 -0.1666295 #> 32    WLR FH(rho=0, gamma=0) -29.984429 9.309267 3.2209226   350 -0.3453421 #> 33    WLR FH(rho=0, gamma=0) -27.732193 9.152805 3.0299119   338 -0.3305844 #> 34    WLR FH(rho=0, gamma=0) -29.984429 9.309267 3.2209226   350 -0.3453421 #> 35    WLR FH(rho=0, gamma=0) -29.984429 9.309267 3.2209226   350 -0.3453421 #> 36    WLR FH(rho=0, gamma=0)  -8.620094 5.553024 1.5523243   124 -0.2803523 #> 37    WLR FH(rho=0, gamma=0) -30.211007 9.300647 3.2482694   350 -0.3478454 #> 38    WLR FH(rho=0, gamma=0) -33.581256 9.516244 3.5288351   367 -0.3690357 #> 39    WLR FH(rho=0, gamma=0) -30.211007 9.300647 3.2482694   350 -0.3478454 #> 40    WLR FH(rho=0, gamma=0) -33.581256 9.516244 3.5288351   367 -0.3690357 #> 41    WLR FH(rho=0, gamma=0)  -3.955284 5.093447 0.7765436   104 -0.1525416 #> 42    WLR FH(rho=0, gamma=0) -26.670986 9.302656 2.8670291   350 -0.3069406 #> 43    WLR FH(rho=0, gamma=0) -26.342504 9.314768 2.8280363   351 -0.3023229 #> 44    WLR FH(rho=0, gamma=0) -26.670986 9.302656 2.8670291   350 -0.3069406 #> 45    WLR FH(rho=0, gamma=0) -26.342504 9.314768 2.8280363   351 -0.3023229 #> 46    WLR FH(rho=0, gamma=0)  -9.242625 5.104900 1.8105400   106 -0.3551148 #> 47    WLR FH(rho=0, gamma=0) -35.255531 9.270632 3.8029263   350 -0.4077490 #> 48    WLR FH(rho=0, gamma=0) -36.706949 9.386743 3.9105095   360 -0.4138911 #> 49    WLR FH(rho=0, gamma=0) -35.255531 9.270632 3.8029263   350 -0.4077490 #> 50    WLR FH(rho=0, gamma=0) -36.706949 9.386743 3.9105095   360 -0.4138911 #>                                 cut duration sim #> 1                  Planned duration 30.00000   1 #> 2                   Targeted events 65.23187   1 #> 3                 Minimum follow-up 73.17268   1 #> 4  Max(planned duration, event cut) 65.23187   1 #> 5     Max(min follow-up, event cut) 73.17268   1 #> 6                  Planned duration 30.00000   2 #> 7                   Targeted events 67.64612   2 #> 8                 Minimum follow-up 72.56793   2 #> 9  Max(planned duration, event cut) 67.64612   2 #> 10    Max(min follow-up, event cut) 72.56793   2 #> 11                 Planned duration 30.00000   3 #> 12                  Targeted events 74.95821   3 #> 13                Minimum follow-up 74.72225   3 #> 14 Max(planned duration, event cut) 74.95821   3 #> 15    Max(min follow-up, event cut) 74.95821   3 #> 16                 Planned duration 30.00000   4 #> 17                  Targeted events 69.16631   4 #> 18                Minimum follow-up 73.68989   4 #> 19 Max(planned duration, event cut) 69.16631   4 #> 20    Max(min follow-up, event cut) 73.68989   4 #> 21                 Planned duration 30.00000   5 #> 22                  Targeted events 77.05035   5 #> 23                Minimum follow-up 76.68470   5 #> 24 Max(planned duration, event cut) 77.05035   5 #> 25    Max(min follow-up, event cut) 77.05035   5 #> 26                 Planned duration 30.00000   6 #> 27                  Targeted events 71.51268   6 #> 28                Minimum follow-up 72.34254   6 #> 29 Max(planned duration, event cut) 71.51268   6 #> 30    Max(min follow-up, event cut) 72.34254   6 #> 31                 Planned duration 30.00000   7 #> 32                  Targeted events 75.61250   7 #> 33                Minimum follow-up 72.99192   7 #> 34 Max(planned duration, event cut) 75.61250   7 #> 35    Max(min follow-up, event cut) 75.61250   7 #> 36                 Planned duration 30.00000   8 #> 37                  Targeted events 66.62160   8 #> 38                Minimum follow-up 70.19488   8 #> 39 Max(planned duration, event cut) 66.62160   8 #> 40    Max(min follow-up, event cut) 70.19488   8 #> 41                 Planned duration 30.00000   9 #> 42                  Targeted events 70.92746   9 #> 43                Minimum follow-up 71.28078   9 #> 44 Max(planned duration, event cut) 70.92746   9 #> 45    Max(min follow-up, event cut) 71.28078   9 #> 46                 Planned duration 30.00000  10 #> 47                  Targeted events 75.17856  10 #> 48                Minimum follow-up 76.94235  10 #> 49 Max(planned duration, event cut) 75.17856  10 #> 50    Max(min follow-up, event cut) 76.94235  10 plan(\"sequential\")  # Example 5: Stratified design with two strata sim_fixed_n(   n_sim = 100,   sample_size = 500,   target_event = 350,   stratum = data.frame(stratum = c(\"Biomarker-positive\", \"Biomarker-negative\"),                        p = c(0.5, 0.5)),   enroll_rate = data.frame(stratum = c(\"Biomarker positive\", \"Biomarker negative\"),                            duration = c(12, 12), rate = c(250 / 12, 250 / 12)),   fail_rate = data.frame(stratum = c(rep(\"Biomarker-positive\", 2), rep(\"Biomarker-negative\", 2)),                          duration = c(3, Inf, 3, Inf),                          fail_rate = log(2) / c(12, 12, 8, 8),                          hr = c(1, 0.6, 1, 0.7),                          dropout_rate = rep(0.001, 4)),   total_duration = 30,   block = rep(c(\"experimental\", \"control\"), 2),   timing_type = 1:5,   rho_gamma = data.frame(rho = 0, gamma = 0)   ) #> Backend uses sequential processing. #>     method          parameter    estimate       se         z event       ln_hr #> 1      WLR FH(rho=0, gamma=0) -23.0217533 8.752762 2.6302274   310 -0.30029344 #> 2      WLR FH(rho=0, gamma=0) -28.3774965 9.310166 3.0480120   350 -0.32682864 #> 3      WLR FH(rho=0, gamma=0) -23.9658317 8.782125 2.7289330   312 -0.31062740 #> 4      WLR FH(rho=0, gamma=0) -28.3774965 9.310166 3.0480120   350 -0.32682864 #> 5      WLR FH(rho=0, gamma=0) -28.3774965 9.310166 3.0480120   350 -0.32682864 #> 6      WLR FH(rho=0, gamma=0) -28.0378878 9.106595 3.0788551   341 -0.33645614 #> 7      WLR FH(rho=0, gamma=0) -27.8651365 9.215376 3.0237657   350 -0.32623754 #> 8      WLR FH(rho=0, gamma=0) -29.4918973 9.128929 3.2305978   343 -0.35213216 #> 9      WLR FH(rho=0, gamma=0) -27.8651365 9.215376 3.0237657   350 -0.32623754 #> 10     WLR FH(rho=0, gamma=0) -27.8651365 9.215376 3.0237657   350 -0.32623754 #> 11     WLR FH(rho=0, gamma=0) -19.9895259 8.582706 2.3290471   299 -0.27024389 #> 12     WLR FH(rho=0, gamma=0) -28.6984044 9.269404 3.0960355   350 -0.33262732 #> 13     WLR FH(rho=0, gamma=0) -22.9794888 8.798074 2.6118772   314 -0.29572618 #> 14     WLR FH(rho=0, gamma=0) -28.6984044 9.269404 3.0960355   350 -0.33262732 #> 15     WLR FH(rho=0, gamma=0) -28.6984044 9.269404 3.0960355   350 -0.33262732 #> 16     WLR FH(rho=0, gamma=0) -15.5450643 8.594257 1.8087735   300 -0.21024615 #> 17     WLR FH(rho=0, gamma=0) -20.9736871 9.267135 2.2632333   350 -0.24370326 #> 18     WLR FH(rho=0, gamma=0) -14.4459088 8.566737 1.6862790   298 -0.19661125 #> 19     WLR FH(rho=0, gamma=0) -20.9736871 9.267135 2.2632333   350 -0.24370326 #> 20     WLR FH(rho=0, gamma=0) -20.9736871 9.267135 2.2632333   350 -0.24370326 #> 21     WLR FH(rho=0, gamma=0) -35.7298623 8.956037 3.9894724   327 -0.44296572 #> 22     WLR FH(rho=0, gamma=0) -36.7020825 9.254444 3.9658873   350 -0.42531116 #> 23     WLR FH(rho=0, gamma=0) -33.0845277 8.779541 3.7683664   314 -0.42699651 #> 24     WLR FH(rho=0, gamma=0) -36.7020825 9.254444 3.9658873   350 -0.42531116 #> 25     WLR FH(rho=0, gamma=0) -36.7020825 9.254444 3.9658873   350 -0.42531116 #> 26     WLR FH(rho=0, gamma=0) -17.8702596 8.406896 2.1256668   290 -0.25207459 #> 27     WLR FH(rho=0, gamma=0) -23.6940561 9.255954 2.5598719   350 -0.27574411 #> 28     WLR FH(rho=0, gamma=0) -19.0565166 8.522547 2.2360118   298 -0.26159419 #> 29     WLR FH(rho=0, gamma=0) -23.6940561 9.255954 2.5598719   350 -0.27574411 #> 30     WLR FH(rho=0, gamma=0) -23.6940561 9.255954 2.5598719   350 -0.27574411 #> 31     WLR FH(rho=0, gamma=0)  -7.0509413 9.054989 0.7786803   330 -0.08604742 #> 32     WLR FH(rho=0, gamma=0) -11.8554453 9.293781 1.2756321   350 -0.13742953 #> 33     WLR FH(rho=0, gamma=0)  -6.5424439 8.878172 0.7369134   317 -0.08307238 #> 34     WLR FH(rho=0, gamma=0) -11.8554453 9.293781 1.2756321   350 -0.13742953 #> 35     WLR FH(rho=0, gamma=0) -11.8554453 9.293781 1.2756321   350 -0.13742953 #> 36     WLR FH(rho=0, gamma=0) -34.8234744 8.872071 3.9250672   323 -0.43866266 #> 37     WLR FH(rho=0, gamma=0) -34.7614655 9.230537 3.7659201   350 -0.40440234 #> 38     WLR FH(rho=0, gamma=0) -34.6324995 9.004425 3.8461644   333 -0.42332034 #> 39     WLR FH(rho=0, gamma=0) -34.7614655 9.230537 3.7659201   350 -0.40440234 #> 40     WLR FH(rho=0, gamma=0) -34.7614655 9.230537 3.7659201   350 -0.40440234 #> 41     WLR FH(rho=0, gamma=0) -30.7475093 8.820932 3.4857440   317 -0.39446809 #> 42     WLR FH(rho=0, gamma=0) -33.5914493 9.255431 3.6293770   350 -0.39043498 #> 43     WLR FH(rho=0, gamma=0) -30.0602424 8.778702 3.4242240   314 -0.38934144 #> 44     WLR FH(rho=0, gamma=0) -33.5914493 9.255431 3.6293770   350 -0.39043498 #> 45     WLR FH(rho=0, gamma=0) -33.5914493 9.255431 3.6293770   350 -0.39043498 #> 46     WLR FH(rho=0, gamma=0) -27.3641388 8.796324 3.1108606   312 -0.35560770 #> 47     WLR FH(rho=0, gamma=0) -31.5174359 9.281577 3.3956984   350 -0.36638432 #> 48     WLR FH(rho=0, gamma=0) -23.0716170 8.627495 2.6741964   300 -0.31148253 #> 49     WLR FH(rho=0, gamma=0) -31.5174359 9.281577 3.3956984   350 -0.36638432 #> 50     WLR FH(rho=0, gamma=0) -31.5174359 9.281577 3.3956984   350 -0.36638432 #> 51     WLR FH(rho=0, gamma=0) -30.9110110 8.730481 3.5405852   311 -0.40528560 #> 52     WLR FH(rho=0, gamma=0) -35.2405945 9.232274 3.8171086   350 -0.41168005 #> 53     WLR FH(rho=0, gamma=0) -29.0115844 8.632358 3.3607947   304 -0.38895635 #> 54     WLR FH(rho=0, gamma=0) -35.2405945 9.232274 3.8171086   350 -0.41168005 #> 55     WLR FH(rho=0, gamma=0) -35.2405945 9.232274 3.8171086   350 -0.41168005 #> 56     WLR FH(rho=0, gamma=0) -48.1321495 8.975568 5.3625744   334 -0.59244381 #> 57     WLR FH(rho=0, gamma=0) -50.3345007 9.160127 5.4949564   350 -0.59276243 #> 58     WLR FH(rho=0, gamma=0) -47.0829895 8.938771 5.2672775   331 -0.58452939 #> 59     WLR FH(rho=0, gamma=0) -50.3345007 9.160127 5.4949564   350 -0.59276243 #> 60     WLR FH(rho=0, gamma=0) -50.3345007 9.160127 5.4949564   350 -0.59276243 #> 61     WLR FH(rho=0, gamma=0) -43.3785589 9.052589 4.7918401   338 -0.52675920 #> 62     WLR FH(rho=0, gamma=0) -42.3918526 9.196295 4.6096662   350 -0.49750894 #> 63     WLR FH(rho=0, gamma=0) -40.8963942 8.928079 4.5806489   328 -0.51102684 #> 64     WLR FH(rho=0, gamma=0) -42.3918526 9.196295 4.6096662   350 -0.49750894 #> 65     WLR FH(rho=0, gamma=0) -42.3918526 9.196295 4.6096662   350 -0.49750894 #> 66     WLR FH(rho=0, gamma=0) -12.5335612 8.270098 1.5155274   275 -0.18303258 #> 67     WLR FH(rho=0, gamma=0) -25.7711264 9.287901 2.7746988   350 -0.29838922 #> 68     WLR FH(rho=0, gamma=0) -21.3248269 8.962848 2.3792467   324 -0.26522039 #> 69     WLR FH(rho=0, gamma=0) -25.7711264 9.287901 2.7746988   350 -0.29838922 #> 70     WLR FH(rho=0, gamma=0) -25.7711264 9.287901 2.7746988   350 -0.29838922 #> 71     WLR FH(rho=0, gamma=0) -23.7379517 8.651410 2.7438247   304 -0.31632293 #> 72     WLR FH(rho=0, gamma=0) -31.6025706 9.269531 3.4092955   350 -0.36635582 #> 73     WLR FH(rho=0, gamma=0) -23.9287643 8.680196 2.7567079   306 -0.31670472 #> 74     WLR FH(rho=0, gamma=0) -31.6025706 9.269531 3.4092955   350 -0.36635582 #> 75     WLR FH(rho=0, gamma=0) -31.6025706 9.269531 3.4092955   350 -0.36635582 #> 76     WLR FH(rho=0, gamma=0) -31.4735337 8.849698 3.5564529   318 -0.40052914 #> 77     WLR FH(rho=0, gamma=0) -34.7754312 9.272737 3.7502876   350 -0.40214354 #> 78     WLR FH(rho=0, gamma=0) -30.3728310 8.819829 3.4436985   316 -0.38907085 #> 79     WLR FH(rho=0, gamma=0) -34.7754312 9.272737 3.7502876   350 -0.40214354 #> 80     WLR FH(rho=0, gamma=0) -34.7754312 9.272737 3.7502876   350 -0.40214354 #> 81     WLR FH(rho=0, gamma=0) -27.8521453 8.619937 3.2311308   303 -0.37311943 #> 82     WLR FH(rho=0, gamma=0) -32.4552759 9.256665 3.5061522   350 -0.37629234 #> 83     WLR FH(rho=0, gamma=0) -28.7017380 8.697853 3.2998645   308 -0.37761899 #> 84     WLR FH(rho=0, gamma=0) -32.4552759 9.256665 3.5061522   350 -0.37629234 #> 85     WLR FH(rho=0, gamma=0) -32.4552759 9.256665 3.5061522   350 -0.37629234 #> 86     WLR FH(rho=0, gamma=0) -26.7882229 8.972136 2.9857129   327 -0.33405231 #> 87     WLR FH(rho=0, gamma=0) -25.8232049 9.266517 2.7867219   350 -0.30097164 #> 88     WLR FH(rho=0, gamma=0) -21.7179990 8.732339 2.4870771   308 -0.28592107 #> 89     WLR FH(rho=0, gamma=0) -25.8232049 9.266517 2.7867219   350 -0.30097164 #> 90     WLR FH(rho=0, gamma=0) -25.8232049 9.266517 2.7867219   350 -0.30097164 #> 91     WLR FH(rho=0, gamma=0) -16.6543596 8.768618 1.8993141   311 -0.21624668 #> 92     WLR FH(rho=0, gamma=0) -16.8725446 9.295078 1.8152127   350 -0.19475083 #> 93     WLR FH(rho=0, gamma=0) -15.0244100 8.637306 1.7394787   302 -0.20102561 #> 94     WLR FH(rho=0, gamma=0) -16.8725446 9.295078 1.8152127   350 -0.19475083 #> 95     WLR FH(rho=0, gamma=0) -16.8725446 9.295078 1.8152127   350 -0.19475083 #> 96     WLR FH(rho=0, gamma=0) -16.2918506 8.721234 1.8680671   306 -0.21449591 #> 97     WLR FH(rho=0, gamma=0) -17.9933565 9.322070 1.9301889   350 -0.20706120 #> 98     WLR FH(rho=0, gamma=0) -16.9317973 8.737864 1.9377502   307 -0.22211137 #> 99     WLR FH(rho=0, gamma=0) -17.9933565 9.322070 1.9301889   350 -0.20706120 #> 100    WLR FH(rho=0, gamma=0) -17.9933565 9.322070 1.9301889   350 -0.20706120 #> 101    WLR FH(rho=0, gamma=0) -10.3222660 9.197303 1.1223144   339 -0.12209815 #> 102    WLR FH(rho=0, gamma=0)  -9.8780180 9.337959 1.0578348   350 -0.11330337 #> 103    WLR FH(rho=0, gamma=0) -10.9492989 9.209522 1.1889107   340 -0.12918058 #> 104    WLR FH(rho=0, gamma=0)  -9.8780180 9.337959 1.0578348   350 -0.11330337 #> 105    WLR FH(rho=0, gamma=0)  -9.8780180 9.337959 1.0578348   350 -0.11330337 #> 106    WLR FH(rho=0, gamma=0) -32.5747303 8.786658 3.7072945   313 -0.42076185 #> 107    WLR FH(rho=0, gamma=0) -35.0635997 9.270084 3.7824467   350 -0.40562808 #> 108    WLR FH(rho=0, gamma=0) -31.8178125 8.561311 3.7164652   297 -0.43382629 #> 109    WLR FH(rho=0, gamma=0) -35.0635997 9.270084 3.7824467   350 -0.40562808 #> 110    WLR FH(rho=0, gamma=0) -35.0635997 9.270084 3.7824467   350 -0.40562808 #> 111    WLR FH(rho=0, gamma=0) -23.6761482 8.838287 2.6788165   318 -0.30253223 #> 112    WLR FH(rho=0, gamma=0) -29.9395274 9.248777 3.2371335   350 -0.34904631 #> 113    WLR FH(rho=0, gamma=0) -23.3343687 8.783025 2.6567575   313 -0.30198262 #> 114    WLR FH(rho=0, gamma=0) -29.9395274 9.248777 3.2371335   350 -0.34904631 #> 115    WLR FH(rho=0, gamma=0) -29.9395274 9.248777 3.2371335   350 -0.34904631 #> 116    WLR FH(rho=0, gamma=0) -36.8192707 8.749726 4.2080484   311 -0.48027125 #> 117    WLR FH(rho=0, gamma=0) -39.7294708 9.221951 4.3081417   350 -0.46378294 #> 118    WLR FH(rho=0, gamma=0) -35.9586301 8.739532 4.1144801   310 -0.47019131 #> 119    WLR FH(rho=0, gamma=0) -39.7294708 9.221951 4.3081417   350 -0.46378294 #> 120    WLR FH(rho=0, gamma=0) -39.7294708 9.221951 4.3081417   350 -0.46378294 #> 121    WLR FH(rho=0, gamma=0) -21.4168275 8.697338 2.4624578   309 -0.28261292 #> 122    WLR FH(rho=0, gamma=0) -20.8402767 9.256274 2.2514757   350 -0.24256953 #> 123    WLR FH(rho=0, gamma=0) -20.4934076 8.880617 2.3076558   323 -0.25921566 #> 124    WLR FH(rho=0, gamma=0) -20.8402767 9.256274 2.2514757   350 -0.24256953 #> 125    WLR FH(rho=0, gamma=0) -20.8402767 9.256274 2.2514757   350 -0.24256953 #> 126    WLR FH(rho=0, gamma=0) -33.9208613 8.812044 3.8493747   321 -0.43446252 #> 127    WLR FH(rho=0, gamma=0) -38.7123697 9.189954 4.2124662   350 -0.45503180 #> 128    WLR FH(rho=0, gamma=0) -32.7488326 8.778258 3.7306756   319 -0.42282777 #> 129    WLR FH(rho=0, gamma=0) -38.7123697 9.189954 4.2124662   350 -0.45503180 #> 130    WLR FH(rho=0, gamma=0) -38.7123697 9.189954 4.2124662   350 -0.45503180 #> 131    WLR FH(rho=0, gamma=0) -18.9542631 8.774471 2.1601602   313 -0.24548953 #> 132    WLR FH(rho=0, gamma=0) -19.8637821 9.277379 2.1410984   350 -0.23012157 #> 133    WLR FH(rho=0, gamma=0) -17.3763188 8.847982 1.9638737   318 -0.22132427 #> 134    WLR FH(rho=0, gamma=0) -19.8637821 9.277379 2.1410984   350 -0.23012157 #> 135    WLR FH(rho=0, gamma=0) -19.8637821 9.277379 2.1410984   350 -0.23012157 #> 136    WLR FH(rho=0, gamma=0) -16.7068083 8.785587 1.9016155   310 -0.21658268 #> 137    WLR FH(rho=0, gamma=0) -17.0994488 9.332407 1.8322657   350 -0.19618393 #> 138    WLR FH(rho=0, gamma=0) -17.6929966 8.855848 1.9978885   315 -0.22572172 #> 139    WLR FH(rho=0, gamma=0) -17.0994488 9.332407 1.8322657   350 -0.19618393 #> 140    WLR FH(rho=0, gamma=0) -17.0994488 9.332407 1.8322657   350 -0.19618393 #> 141    WLR FH(rho=0, gamma=0) -42.3336521 9.010366 4.6983277   336 -0.51718957 #> 142    WLR FH(rho=0, gamma=0) -40.3371501 9.186875 4.3907368   350 -0.47372737 #> 143    WLR FH(rho=0, gamma=0) -41.6927465 8.841731 4.7154506   324 -0.52913913 #> 144    WLR FH(rho=0, gamma=0) -40.3371501 9.186875 4.3907368   350 -0.47372737 #> 145    WLR FH(rho=0, gamma=0) -40.3371501 9.186875 4.3907368   350 -0.47372737 #> 146    WLR FH(rho=0, gamma=0) -19.4878321 8.581649 2.2708728   300 -0.26428285 #> 147    WLR FH(rho=0, gamma=0) -26.7739246 9.297486 2.8796949   350 -0.30871866 #> 148    WLR FH(rho=0, gamma=0) -22.0266202 8.770713 2.5113832   311 -0.28600656 #> 149    WLR FH(rho=0, gamma=0) -26.7739246 9.297486 2.8796949   350 -0.30871866 #> 150    WLR FH(rho=0, gamma=0) -26.7739246 9.297486 2.8796949   350 -0.30871866 #> 151    WLR FH(rho=0, gamma=0)  -8.9493826 8.756184 1.0220642   308 -0.11668833 #> 152    WLR FH(rho=0, gamma=0) -17.6073833 9.327134 1.8877592   350 -0.20232370 #> 153    WLR FH(rho=0, gamma=0)  -7.9334211 8.712405 0.9105891   305 -0.10448944 #> 154    WLR FH(rho=0, gamma=0) -17.6073833 9.327134 1.8877592   350 -0.20232370 #> 155    WLR FH(rho=0, gamma=0) -17.6073833 9.327134 1.8877592   350 -0.20232370 #> 156    WLR FH(rho=0, gamma=0) -17.7307987 8.544000 2.0752338   296 -0.24280771 #> 157    WLR FH(rho=0, gamma=0) -27.0152820 9.253341 2.9195165   350 -0.31498273 #> 158    WLR FH(rho=0, gamma=0) -22.3734300 8.691050 2.5743068   307 -0.29624047 #> 159    WLR FH(rho=0, gamma=0) -27.0152820 9.253341 2.9195165   350 -0.31498273 #> 160    WLR FH(rho=0, gamma=0) -27.0152820 9.253341 2.9195165   350 -0.31498273 #> 161    WLR FH(rho=0, gamma=0) -32.8696136 8.733455 3.7636438   312 -0.42771575 #> 162    WLR FH(rho=0, gamma=0) -37.5057092 9.213586 4.0706960   350 -0.43770216 #> 163    WLR FH(rho=0, gamma=0) -31.0132488 8.657688 3.5821630   306 -0.41076403 #> 164    WLR FH(rho=0, gamma=0) -37.5057092 9.213586 4.0706960   350 -0.43770216 #> 165    WLR FH(rho=0, gamma=0) -37.5057092 9.213586 4.0706960   350 -0.43770216 #> 166    WLR FH(rho=0, gamma=0) -33.6201811 8.820126 3.8117573   320 -0.43057178 #> 167    WLR FH(rho=0, gamma=0) -36.6146514 9.211397 3.9749291   350 -0.42909823 #> 168    WLR FH(rho=0, gamma=0) -31.4428565 8.726440 3.6031713   313 -0.41136245 #> 169    WLR FH(rho=0, gamma=0) -36.6146514 9.211397 3.9749291   350 -0.42909823 #> 170    WLR FH(rho=0, gamma=0) -36.6146514 9.211397 3.9749291   350 -0.42909823 #> 171    WLR FH(rho=0, gamma=0) -22.3080122 8.777709 2.5414390   312 -0.28985841 #> 172    WLR FH(rho=0, gamma=0) -29.0214100 9.315037 3.1155442   350 -0.33437028 #> 173    WLR FH(rho=0, gamma=0) -22.7393646 8.761924 2.5952480   310 -0.29661595 #> 174    WLR FH(rho=0, gamma=0) -29.0214100 9.315037 3.1155442   350 -0.33437028 #> 175    WLR FH(rho=0, gamma=0) -29.0214100 9.315037 3.1155442   350 -0.33437028 #> 176    WLR FH(rho=0, gamma=0) -30.5296970 9.054633 3.3717210   332 -0.37017877 #> 177    WLR FH(rho=0, gamma=0) -35.3351810 9.287386 3.8046422   350 -0.40703285 #> 178    WLR FH(rho=0, gamma=0) -25.5615987 8.507535 3.0045834   294 -0.35127341 #> 179    WLR FH(rho=0, gamma=0) -35.3351810 9.287386 3.8046422   350 -0.40703285 #> 180    WLR FH(rho=0, gamma=0) -35.3351810 9.287386 3.8046422   350 -0.40703285 #> 181    WLR FH(rho=0, gamma=0) -32.0886727 8.799964 3.6464551   315 -0.41235825 #> 182    WLR FH(rho=0, gamma=0) -38.8362794 9.248536 4.1991813   350 -0.45084618 #> 183    WLR FH(rho=0, gamma=0) -28.3268145 8.621840 3.2854719   302 -0.37925699 #> 184    WLR FH(rho=0, gamma=0) -38.8362794 9.248536 4.1991813   350 -0.45084618 #> 185    WLR FH(rho=0, gamma=0) -38.8362794 9.248536 4.1991813   350 -0.45084618 #> 186    WLR FH(rho=0, gamma=0) -36.5715225 8.884521 4.1163188   321 -0.46286662 #> 187    WLR FH(rho=0, gamma=0) -37.2892180 9.249808 4.0313505   350 -0.43341309 #> 188    WLR FH(rho=0, gamma=0) -33.2374803 8.677885 3.8301363   305 -0.44166833 #> 189    WLR FH(rho=0, gamma=0) -37.2892180 9.249808 4.0313505   350 -0.43341309 #> 190    WLR FH(rho=0, gamma=0) -37.2892180 9.249808 4.0313505   350 -0.43341309 #> 191    WLR FH(rho=0, gamma=0) -12.4186226 8.743398 1.4203428   309 -0.16241111 #> 192    WLR FH(rho=0, gamma=0) -12.7622574 9.302922 1.3718548   350 -0.14735013 #> 193    WLR FH(rho=0, gamma=0) -12.4266822 8.743426 1.4212601   309 -0.16251495 #> 194    WLR FH(rho=0, gamma=0) -12.7622574 9.302922 1.3718548   350 -0.14735013 #> 195    WLR FH(rho=0, gamma=0) -12.7622574 9.302922 1.3718548   350 -0.14735013 #> 196    WLR FH(rho=0, gamma=0) -15.5849030 8.585032 1.8153576   299 -0.21109104 #> 197    WLR FH(rho=0, gamma=0) -18.7307870 9.273230 2.0198774   350 -0.21733600 #> 198    WLR FH(rho=0, gamma=0) -16.8363504 8.786618 1.9161355   313 -0.21772362 #> 199    WLR FH(rho=0, gamma=0) -18.7307870 9.273230 2.0198774   350 -0.21733600 #> 200    WLR FH(rho=0, gamma=0) -18.7307870 9.273230 2.0198774   350 -0.21733600 #> 201    WLR FH(rho=0, gamma=0) -15.6966139 8.664844 1.8115287   306 -0.20903061 #> 202    WLR FH(rho=0, gamma=0) -24.4305155 9.281455 2.6321860   350 -0.28375303 #> 203    WLR FH(rho=0, gamma=0) -20.5865948 8.932866 2.3045902   325 -0.25819613 #> 204    WLR FH(rho=0, gamma=0) -24.4305155 9.281455 2.6321860   350 -0.28375303 #> 205    WLR FH(rho=0, gamma=0) -24.4305155 9.281455 2.6321860   350 -0.28375303 #> 206    WLR FH(rho=0, gamma=0) -24.3701211 8.919225 2.7323138   323 -0.30695753 #> 207    WLR FH(rho=0, gamma=0) -25.8468992 9.271371 2.7878186   350 -0.30055863 #> 208    WLR FH(rho=0, gamma=0) -19.7051091 8.594537 2.2927482   299 -0.26725365 #> 209    WLR FH(rho=0, gamma=0) -25.8468992 9.271371 2.7878186   350 -0.30055863 #> 210    WLR FH(rho=0, gamma=0) -25.8468992 9.271371 2.7878186   350 -0.30055863 #> 211    WLR FH(rho=0, gamma=0) -20.7703108 8.896869 2.3345641   320 -0.26207417 #> 212    WLR FH(rho=0, gamma=0) -23.0593264 9.294166 2.4810540   350 -0.26635387 #> 213    WLR FH(rho=0, gamma=0) -20.4188140 8.873175 2.3011847   318 -0.25905764 #> 214    WLR FH(rho=0, gamma=0) -23.0593264 9.294166 2.4810540   350 -0.26635387 #> 215    WLR FH(rho=0, gamma=0) -23.0593264 9.294166 2.4810540   350 -0.26635387 #> 216    WLR FH(rho=0, gamma=0)  -9.4581381 8.675215 1.0902482   302 -0.12571247 #> 217    WLR FH(rho=0, gamma=0) -11.9191983 9.341722 1.2759102   350 -0.13658592 #> 218    WLR FH(rho=0, gamma=0)  -9.8116987 8.949088 1.0963909   321 -0.12255923 #> 219    WLR FH(rho=0, gamma=0) -11.9191983 9.341722 1.2759102   350 -0.13658592 #> 220    WLR FH(rho=0, gamma=0) -11.9191983 9.341722 1.2759102   350 -0.13658592 #> 221    WLR FH(rho=0, gamma=0) -24.2655590 8.766301 2.7680499   313 -0.31544161 #> 222    WLR FH(rho=0, gamma=0) -30.0543959 9.248263 3.2497341   350 -0.35064277 #> 223    WLR FH(rho=0, gamma=0) -25.6011591 9.038467 2.8324669   333 -0.31283343 #> 224    WLR FH(rho=0, gamma=0) -30.0543959 9.248263 3.2497341   350 -0.35064277 #> 225    WLR FH(rho=0, gamma=0) -30.0543959 9.248263 3.2497341   350 -0.35064277 #> 226    WLR FH(rho=0, gamma=0)  -6.1156459 8.794579 0.6953881   311 -0.07912088 #> 227    WLR FH(rho=0, gamma=0)  -4.9280980 9.284472 0.5307893   350 -0.05718337 #> 228    WLR FH(rho=0, gamma=0)  -5.5638383 8.877137 0.6267604   317 -0.07063383 #> 229    WLR FH(rho=0, gamma=0)  -4.9280980 9.284472 0.5307893   350 -0.05718337 #> 230    WLR FH(rho=0, gamma=0)  -4.9280980 9.284472 0.5307893   350 -0.05718337 #> 231    WLR FH(rho=0, gamma=0) -24.9842532 8.648498 2.8888546   305 -0.33277908 #> 232    WLR FH(rho=0, gamma=0) -25.5842772 9.211499 2.7774281   350 -0.29976797 #> 233    WLR FH(rho=0, gamma=0) -25.0610595 8.645572 2.8987162   305 -0.33402892 #> 234    WLR FH(rho=0, gamma=0) -25.5842772 9.211499 2.7774281   350 -0.29976797 #> 235    WLR FH(rho=0, gamma=0) -25.5842772 9.211499 2.7774281   350 -0.29976797 #> 236    WLR FH(rho=0, gamma=0) -17.1997266 8.899854 1.9325854   320 -0.21716388 #> 237    WLR FH(rho=0, gamma=0) -19.5160802 9.305537 2.0972547   350 -0.22523687 #> 238    WLR FH(rho=0, gamma=0) -17.1671691 8.899786 1.9289417   320 -0.21675942 #> 239    WLR FH(rho=0, gamma=0) -19.5160802 9.305537 2.0972547   350 -0.22523687 #> 240    WLR FH(rho=0, gamma=0) -19.5160802 9.305537 2.0972547   350 -0.22523687 #> 241    WLR FH(rho=0, gamma=0) -10.0772762 8.816377 1.1430178   314 -0.12962775 #> 242    WLR FH(rho=0, gamma=0) -13.5566199 9.311732 1.4558645   350 -0.15629940 #> 243    WLR FH(rho=0, gamma=0) -11.8291282 8.674211 1.3637123   304 -0.15725195 #> 244    WLR FH(rho=0, gamma=0) -13.5566199 9.311732 1.4558645   350 -0.15629940 #> 245    WLR FH(rho=0, gamma=0) -13.5566199 9.311732 1.4558645   350 -0.15629940 #> 246    WLR FH(rho=0, gamma=0)  -9.9498381 8.727932 1.1399995   306 -0.13068069 #> 247    WLR FH(rho=0, gamma=0) -18.0787069 9.325042 1.9387265   350 -0.20807877 #> 248    WLR FH(rho=0, gamma=0)  -9.8474647 8.889298 1.1077888   317 -0.12466322 #> 249    WLR FH(rho=0, gamma=0) -18.0787069 9.325042 1.9387265   350 -0.20807877 #> 250    WLR FH(rho=0, gamma=0) -18.0787069 9.325042 1.9387265   350 -0.20807877 #> 251    WLR FH(rho=0, gamma=0) -27.5142853 8.743322 3.1468916   308 -0.36023023 #> 252    WLR FH(rho=0, gamma=0) -28.0374941 9.292246 3.0173000   350 -0.32369504 #> 253    WLR FH(rho=0, gamma=0) -28.3328345 8.813664 3.2146488   313 -0.36502686 #> 254    WLR FH(rho=0, gamma=0) -28.0374941 9.292246 3.0173000   350 -0.32369504 #> 255    WLR FH(rho=0, gamma=0) -28.0374941 9.292246 3.0173000   350 -0.32369504 #> 256    WLR FH(rho=0, gamma=0)  -0.9220231 8.860248 0.1040629   315 -0.01174531 #> 257    WLR FH(rho=0, gamma=0)  -6.3006438 9.336686 0.6748266   350 -0.07230410 #> 258    WLR FH(rho=0, gamma=0)  -2.9711679 9.055844 0.3280940   329 -0.03623614 #> 259    WLR FH(rho=0, gamma=0)  -6.3006438 9.336686 0.6748266   350 -0.07230410 #> 260    WLR FH(rho=0, gamma=0)  -6.3006438 9.336686 0.6748266   350 -0.07230410 #> 261    WLR FH(rho=0, gamma=0) -15.8778352 8.829094 1.7983539   314 -0.20364340 #> 262    WLR FH(rho=0, gamma=0) -24.3996969 9.288402 2.6268994   350 -0.28274960 #> 263    WLR FH(rho=0, gamma=0) -18.1370497 8.976176 2.0205763   325 -0.22507115 #> 264    WLR FH(rho=0, gamma=0) -24.3996969 9.288402 2.6268994   350 -0.28274960 #> 265    WLR FH(rho=0, gamma=0) -24.3996969 9.288402 2.6268994   350 -0.28274960 #> 266    WLR FH(rho=0, gamma=0) -19.2808119 8.662191 2.2258585   305 -0.25739330 #> 267    WLR FH(rho=0, gamma=0) -24.0832111 9.287617 2.5930452   350 -0.27908474 #> 268    WLR FH(rho=0, gamma=0) -18.9093948 8.837163 2.1397584   318 -0.24228978 #> 269    WLR FH(rho=0, gamma=0) -24.0832111 9.287617 2.5930452   350 -0.27908474 #> 270    WLR FH(rho=0, gamma=0) -24.0832111 9.287617 2.5930452   350 -0.27908474 #> 271    WLR FH(rho=0, gamma=0) -22.1900697 8.855518 2.5057901   321 -0.28287832 #> 272    WLR FH(rho=0, gamma=0) -25.8986315 9.244533 2.8015079   350 -0.30299889 #> 273    WLR FH(rho=0, gamma=0) -22.8636630 8.897950 2.5695428   324 -0.28869416 #> 274    WLR FH(rho=0, gamma=0) -25.8986315 9.244533 2.8015079   350 -0.30299889 #> 275    WLR FH(rho=0, gamma=0) -25.8986315 9.244533 2.8015079   350 -0.30299889 #> 276    WLR FH(rho=0, gamma=0) -20.8540097 9.076966 2.2974648   335 -0.25280041 #> 277    WLR FH(rho=0, gamma=0) -19.4027897 9.261272 2.0950458   350 -0.22584098 #> 278    WLR FH(rho=0, gamma=0) -17.5286071 8.935616 1.9616563   324 -0.21922321 #> 279    WLR FH(rho=0, gamma=0) -19.4027897 9.261272 2.0950458   350 -0.22584098 #> 280    WLR FH(rho=0, gamma=0) -19.4027897 9.261272 2.0950458   350 -0.22584098 #> 281    WLR FH(rho=0, gamma=0) -23.6000777 8.609437 2.7411871   300 -0.31788291 #> 282    WLR FH(rho=0, gamma=0) -32.5110651 9.269880 3.5071723   350 -0.37657321 #> 283    WLR FH(rho=0, gamma=0) -24.2079712 8.623443 2.8072279   301 -0.32503602 #> 284    WLR FH(rho=0, gamma=0) -32.5110651 9.269880 3.5071723   350 -0.37657321 #> 285    WLR FH(rho=0, gamma=0) -32.5110651 9.269880 3.5071723   350 -0.37657321 #> 286    WLR FH(rho=0, gamma=0) -20.7983230 8.859960 2.3474510   318 -0.26438918 #> 287    WLR FH(rho=0, gamma=0) -20.2144271 9.279368 2.1784271   350 -0.23403886 #> 288    WLR FH(rho=0, gamma=0) -21.2752964 8.876511 2.3968083   319 -0.26946334 #> 289    WLR FH(rho=0, gamma=0) -20.2144271 9.279368 2.1784271   350 -0.23403886 #> 290    WLR FH(rho=0, gamma=0) -20.2144271 9.279368 2.1784271   350 -0.23403886 #> 291    WLR FH(rho=0, gamma=0) -28.3693150 8.596777 3.2999945   299 -0.38379989 #> 292    WLR FH(rho=0, gamma=0) -32.6716177 9.283025 3.5195013   350 -0.37774753 #> 293    WLR FH(rho=0, gamma=0) -26.5955621 8.724288 3.0484508   308 -0.34883979 #> 294    WLR FH(rho=0, gamma=0) -32.6716177 9.283025 3.5195013   350 -0.37774753 #> 295    WLR FH(rho=0, gamma=0) -32.6716177 9.283025 3.5195013   350 -0.37774753 #> 296    WLR FH(rho=0, gamma=0) -20.1023966 9.026632 2.2270096   330 -0.24670874 #> 297    WLR FH(rho=0, gamma=0) -16.1423656 9.262324 1.7427986   350 -0.18795404 #> 298    WLR FH(rho=0, gamma=0) -19.7872376 9.036012 2.1898198   331 -0.24230264 #> 299    WLR FH(rho=0, gamma=0) -16.1423656 9.262324 1.7427986   350 -0.18795404 #> 300    WLR FH(rho=0, gamma=0) -16.1423656 9.262324 1.7427986   350 -0.18795404 #> 301    WLR FH(rho=0, gamma=0) -21.2849101 8.837465 2.4084860   317 -0.27231364 #> 302    WLR FH(rho=0, gamma=0) -27.9937093 9.260923 3.0227773   350 -0.32602460 #> 303    WLR FH(rho=0, gamma=0) -19.8043341 8.698733 2.2766919   306 -0.26150814 #> 304    WLR FH(rho=0, gamma=0) -27.9937093 9.260923 3.0227773   350 -0.32602460 #> 305    WLR FH(rho=0, gamma=0) -27.9937093 9.260923 3.0227773   350 -0.32602460 #> 306    WLR FH(rho=0, gamma=0) -38.0167975 8.672271 4.3837189   309 -0.50317572 #> 307    WLR FH(rho=0, gamma=0) -38.8017148 9.209929 4.2130310   350 -0.45344774 #> 308    WLR FH(rho=0, gamma=0) -38.7382981 8.646009 4.4804833   307 -0.51619903 #> 309    WLR FH(rho=0, gamma=0) -38.8017148 9.209929 4.2130310   350 -0.45344774 #> 310    WLR FH(rho=0, gamma=0) -38.8017148 9.209929 4.2130310   350 -0.45344774 #> 311    WLR FH(rho=0, gamma=0) -31.5500449 8.728973 3.6144053   312 -0.41218555 #> 312    WLR FH(rho=0, gamma=0) -33.5707879 9.228675 3.6376608   350 -0.39173072 #> 313    WLR FH(rho=0, gamma=0) -31.2245920 8.799806 3.5483274   317 -0.40131080 #> 314    WLR FH(rho=0, gamma=0) -33.5707879 9.228675 3.6376608   350 -0.39173072 #> 315    WLR FH(rho=0, gamma=0) -33.5707879 9.228675 3.6376608   350 -0.39173072 #> 316    WLR FH(rho=0, gamma=0)  -8.0914921 8.610966 0.9396730   300 -0.10920134 #> 317    WLR FH(rho=0, gamma=0) -14.6185351 9.290948 1.5734169   350 -0.16965109 #> 318    WLR FH(rho=0, gamma=0)  -7.7090075 8.667948 0.8893694   304 -0.10267838 #> 319    WLR FH(rho=0, gamma=0) -14.6185351 9.290948 1.5734169   350 -0.16965109 #> 320    WLR FH(rho=0, gamma=0) -14.6185351 9.290948 1.5734169   350 -0.16965109 #> 321    WLR FH(rho=0, gamma=0) -28.3636428 8.679257 3.2679806   308 -0.37406447 #> 322    WLR FH(rho=0, gamma=0) -36.5396329 9.217415 3.9641951   350 -0.42623585 #> 323    WLR FH(rho=0, gamma=0) -29.5475160 8.706788 3.3936184   310 -0.38724685 #> 324    WLR FH(rho=0, gamma=0) -36.5396329 9.217415 3.9641951   350 -0.42623585 #> 325    WLR FH(rho=0, gamma=0) -36.5396329 9.217415 3.9641951   350 -0.42623585 #> 326    WLR FH(rho=0, gamma=0) -27.3645461 8.532053 3.2072641   296 -0.37547819 #> 327    WLR FH(rho=0, gamma=0) -33.6722093 9.250005 3.6402369   350 -0.39185302 #> 328    WLR FH(rho=0, gamma=0) -28.1095050 8.963658 3.1359414   327 -0.34878440 #> 329    WLR FH(rho=0, gamma=0) -33.6722093 9.250005 3.6402369   350 -0.39185302 #> 330    WLR FH(rho=0, gamma=0) -33.6722093 9.250005 3.6402369   350 -0.39185302 #> 331    WLR FH(rho=0, gamma=0) -28.4810664 8.550020 3.3311113   302 -0.38928141 #> 332    WLR FH(rho=0, gamma=0) -34.1021208 9.198815 3.7072297   350 -0.40185339 #> 333    WLR FH(rho=0, gamma=0) -28.4518821 8.550155 3.3276454   302 -0.38888359 #> 334    WLR FH(rho=0, gamma=0) -34.1021208 9.198815 3.7072297   350 -0.40185339 #> 335    WLR FH(rho=0, gamma=0) -34.1021208 9.198815 3.7072297   350 -0.40185339 #> 336    WLR FH(rho=0, gamma=0) -19.0384150 8.773094 2.1700913   310 -0.24723023 #> 337    WLR FH(rho=0, gamma=0) -20.7336976 9.316450 2.2254934   350 -0.23843891 #> 338    WLR FH(rho=0, gamma=0) -18.1654084 8.801324 2.0639404   312 -0.23431749 #> 339    WLR FH(rho=0, gamma=0) -20.7336976 9.316450 2.2254934   350 -0.23843891 #> 340    WLR FH(rho=0, gamma=0) -20.7336976 9.316450 2.2254934   350 -0.23843891 #> 341    WLR FH(rho=0, gamma=0) -36.2145719 8.641944 4.1905587   306 -0.48133479 #> 342    WLR FH(rho=0, gamma=0) -44.8561430 9.221222 4.8644469   350 -0.52256152 #> 343    WLR FH(rho=0, gamma=0) -38.8078382 8.796943 4.4115140   318 -0.49735704 #> 344    WLR FH(rho=0, gamma=0) -44.8561430 9.221222 4.8644469   350 -0.52256152 #> 345    WLR FH(rho=0, gamma=0) -44.8561430 9.221222 4.8644469   350 -0.52256152 #> 346    WLR FH(rho=0, gamma=0) -12.2370463 9.013367 1.3576553   327 -0.15065680 #> 347    WLR FH(rho=0, gamma=0) -14.9133697 9.321771 1.5998429   350 -0.17163540 #> 348    WLR FH(rho=0, gamma=0) -12.9371145 9.025338 1.4334217   328 -0.15885893 #> 349    WLR FH(rho=0, gamma=0) -14.9133697 9.321771 1.5998429   350 -0.17163540 #> 350    WLR FH(rho=0, gamma=0) -14.9133697 9.321771 1.5998429   350 -0.17163540 #> 351    WLR FH(rho=0, gamma=0) -23.7809786 8.649382 2.7494426   303 -0.31793423 #> 352    WLR FH(rho=0, gamma=0) -28.6753790 9.259018 3.0970216   350 -0.33394744 #> 353    WLR FH(rho=0, gamma=0) -24.3861385 8.464995 2.8808213   290 -0.34087875 #> 354    WLR FH(rho=0, gamma=0) -28.6753790 9.259018 3.0970216   350 -0.33394744 #> 355    WLR FH(rho=0, gamma=0) -28.6753790 9.259018 3.0970216   350 -0.33394744 #> 356    WLR FH(rho=0, gamma=0) -29.3242147 8.794466 3.3343942   311 -0.38056054 #> 357    WLR FH(rho=0, gamma=0) -31.9000598 9.298081 3.4308219   350 -0.36874470 #> 358    WLR FH(rho=0, gamma=0) -28.3440620 8.899254 3.1849931   319 -0.35862222 #> 359    WLR FH(rho=0, gamma=0) -31.9000598 9.298081 3.4308219   350 -0.36874470 #> 360    WLR FH(rho=0, gamma=0) -31.9000598 9.298081 3.4308219   350 -0.36874470 #> 361    WLR FH(rho=0, gamma=0) -35.3461314 9.005879 3.9247843   331 -0.43374106 #> 362    WLR FH(rho=0, gamma=0) -34.9733191 9.251655 3.7802230   350 -0.40585114 #> 363    WLR FH(rho=0, gamma=0) -31.6251472 8.791565 3.5972149   315 -0.40753805 #> 364    WLR FH(rho=0, gamma=0) -34.9733191 9.251655 3.7802230   350 -0.40585114 #> 365    WLR FH(rho=0, gamma=0) -34.9733191 9.251655 3.7802230   350 -0.40585114 #> 366    WLR FH(rho=0, gamma=0) -15.4347160 8.500415 1.8157602   291 -0.21384627 #> 367    WLR FH(rho=0, gamma=0) -19.6433871 9.316694 2.1084074   350 -0.22632947 #> 368    WLR FH(rho=0, gamma=0) -13.4272582 8.696195 1.5440382   305 -0.17754614 #> 369    WLR FH(rho=0, gamma=0) -19.6433871 9.316694 2.1084074   350 -0.22632947 #> 370    WLR FH(rho=0, gamma=0) -19.6433871 9.316694 2.1084074   350 -0.22632947 #> 371    WLR FH(rho=0, gamma=0) -18.7436663 8.623776 2.1734871   301 -0.25100528 #> 372    WLR FH(rho=0, gamma=0) -26.9020076 9.292129 2.8951392   350 -0.31023621 #> 373    WLR FH(rho=0, gamma=0) -19.2071688 8.610025 2.2307913   300 -0.25804102 #> 374    WLR FH(rho=0, gamma=0) -26.9020076 9.292129 2.8951392   350 -0.31023621 #> 375    WLR FH(rho=0, gamma=0) -26.9020076 9.292129 2.8951392   350 -0.31023621 #> 376    WLR FH(rho=0, gamma=0) -35.3111091 8.905870 3.9649255   325 -0.44253408 #> 377    WLR FH(rho=0, gamma=0) -36.1314376 9.229447 3.9148000   350 -0.42038790 #> 378    WLR FH(rho=0, gamma=0) -36.4462738 8.837660 4.1239734   320 -0.46411619 #> 379    WLR FH(rho=0, gamma=0) -36.1314376 9.229447 3.9148000   350 -0.42038790 #> 380    WLR FH(rho=0, gamma=0) -36.1314376 9.229447 3.9148000   350 -0.42038790 #> 381    WLR FH(rho=0, gamma=0) -16.6404970 8.273907 2.0112018   277 -0.24321935 #> 382    WLR FH(rho=0, gamma=0) -29.9684548 9.273630 3.2315777   350 -0.34827060 #> 383    WLR FH(rho=0, gamma=0) -20.0382046 8.487676 2.3608587   292 -0.27841305 #> 384    WLR FH(rho=0, gamma=0) -29.9684548 9.273630 3.2315777   350 -0.34827060 #> 385    WLR FH(rho=0, gamma=0) -29.9684548 9.273630 3.2315777   350 -0.34827060 #> 386    WLR FH(rho=0, gamma=0) -10.1918884 8.802223 1.1578767   311 -0.13163622 #> 387    WLR FH(rho=0, gamma=0) -16.9915220 9.333177 1.8205507   350 -0.19524901 #> 388    WLR FH(rho=0, gamma=0)  -9.0809545 8.744116 1.0385217   307 -0.11883241 #> 389    WLR FH(rho=0, gamma=0) -16.9915220 9.333177 1.8205507   350 -0.19524901 #> 390    WLR FH(rho=0, gamma=0) -16.9915220 9.333177 1.8205507   350 -0.19524901 #> 391    WLR FH(rho=0, gamma=0) -32.7071203 8.767652 3.7304311   316 -0.42336530 #> 392    WLR FH(rho=0, gamma=0) -39.6991814 9.230717 4.3007688   350 -0.46295093 #> 393    WLR FH(rho=0, gamma=0) -32.2419684 8.584524 3.7558249   302 -0.43569144 #> 394    WLR FH(rho=0, gamma=0) -39.6991814 9.230717 4.3007688   350 -0.46295093 #> 395    WLR FH(rho=0, gamma=0) -39.6991814 9.230717 4.3007688   350 -0.46295093 #> 396    WLR FH(rho=0, gamma=0) -30.2340268 8.812418 3.4308435   315 -0.38811446 #> 397    WLR FH(rho=0, gamma=0) -37.1491710 9.250243 4.0160210   350 -0.43190231 #> 398    WLR FH(rho=0, gamma=0) -30.2214143 8.812557 3.4293581   315 -0.38794459 #> 399    WLR FH(rho=0, gamma=0) -37.1491710 9.250243 4.0160210   350 -0.43190231 #> 400    WLR FH(rho=0, gamma=0) -37.1491710 9.250243 4.0160210   350 -0.43190231 #> 401    WLR FH(rho=0, gamma=0) -26.1910959 8.388806 3.1221481   284 -0.37198839 #> 402    WLR FH(rho=0, gamma=0) -37.3801749 9.286799 4.0250873   350 -0.43194685 #> 403    WLR FH(rho=0, gamma=0) -26.2377712 8.520171 3.0794889   293 -0.36102236 #> 404    WLR FH(rho=0, gamma=0) -37.3801749 9.286799 4.0250873   350 -0.43194685 #> 405    WLR FH(rho=0, gamma=0) -37.3801749 9.286799 4.0250873   350 -0.43194685 #> 406    WLR FH(rho=0, gamma=0) -15.0210964 8.622376 1.7421064   300 -0.20192420 #> 407    WLR FH(rho=0, gamma=0) -21.5072036 9.290768 2.3149006   350 -0.24881469 #> 408    WLR FH(rho=0, gamma=0) -16.2064261 8.679142 1.8672843   304 -0.21504560 #> 409    WLR FH(rho=0, gamma=0) -21.5072036 9.290768 2.3149006   350 -0.24881469 #> 410    WLR FH(rho=0, gamma=0) -21.5072036 9.290768 2.3149006   350 -0.24881469 #> 411    WLR FH(rho=0, gamma=0) -21.6514790 9.036693 2.3959515   328 -0.26526608 #> 412    WLR FH(rho=0, gamma=0) -20.4129303 9.314820 2.1914466   350 -0.23510330 #> 413    WLR FH(rho=0, gamma=0) -21.7186851 8.842200 2.4562536   314 -0.27818709 #> 414    WLR FH(rho=0, gamma=0) -20.4129303 9.314820 2.1914466   350 -0.23510330 #> 415    WLR FH(rho=0, gamma=0) -20.4129303 9.314820 2.1914466   350 -0.23510330 #> 416    WLR FH(rho=0, gamma=0) -33.7249398 8.735209 3.8608052   311 -0.44157461 #> 417    WLR FH(rho=0, gamma=0) -36.0879548 9.252835 3.9002052   350 -0.41967250 #> 418    WLR FH(rho=0, gamma=0) -33.6476039 8.637485 3.8955324   304 -0.45094498 #> 419    WLR FH(rho=0, gamma=0) -36.0879548 9.252835 3.9002052   350 -0.41967250 #> 420    WLR FH(rho=0, gamma=0) -36.0879548 9.252835 3.9002052   350 -0.41967250 #> 421    WLR FH(rho=0, gamma=0) -28.0598232 8.878232 3.1605194   319 -0.35651471 #> 422    WLR FH(rho=0, gamma=0) -32.8377892 9.272687 3.5413457   350 -0.38149191 #> 423    WLR FH(rho=0, gamma=0) -27.7304977 8.891535 3.1187527   320 -0.35115956 #> 424    WLR FH(rho=0, gamma=0) -32.8377892 9.272687 3.5413457   350 -0.38149191 #> 425    WLR FH(rho=0, gamma=0) -32.8377892 9.272687 3.5413457   350 -0.38149191 #> 426    WLR FH(rho=0, gamma=0) -16.8796636 8.652162 1.9509186   302 -0.22646932 #> 427    WLR FH(rho=0, gamma=0) -21.7520137 9.290600 2.3412927   350 -0.25254519 #> 428    WLR FH(rho=0, gamma=0) -17.8883948 8.723562 2.0505838   307 -0.23608854 #> 429    WLR FH(rho=0, gamma=0) -21.7520137 9.290600 2.3412927   350 -0.25254519 #> 430    WLR FH(rho=0, gamma=0) -21.7520137 9.290600 2.3412927   350 -0.25254519 #> 431    WLR FH(rho=0, gamma=0) -30.7764712 8.720117 3.5293643   310 -0.40415776 #> 432    WLR FH(rho=0, gamma=0) -34.5457375 9.239966 3.7387300   350 -0.40258926 #> 433    WLR FH(rho=0, gamma=0) -29.5197099 8.641026 3.4162276   305 -0.39467379 #> 434    WLR FH(rho=0, gamma=0) -34.5457375 9.239966 3.7387300   350 -0.40258926 #> 435    WLR FH(rho=0, gamma=0) -34.5457375 9.239966 3.7387300   350 -0.40258926 #> 436    WLR FH(rho=0, gamma=0) -15.3083984 8.615245 1.7768964   302 -0.20610909 #> 437    WLR FH(rho=0, gamma=0) -18.6149864 9.291421 2.0034596   350 -0.21523088 #> 438    WLR FH(rho=0, gamma=0) -14.1780526 8.486168 1.6707249   292 -0.19677809 #> 439    WLR FH(rho=0, gamma=0) -18.6149864 9.291421 2.0034596   350 -0.21523088 #> 440    WLR FH(rho=0, gamma=0) -18.6149864 9.291421 2.0034596   350 -0.21523088 #> 441    WLR FH(rho=0, gamma=0) -37.6588438 8.588546 4.3847750   306 -0.50715388 #> 442    WLR FH(rho=0, gamma=0) -48.2316074 9.136277 5.2791312   350 -0.57198040 #> 443    WLR FH(rho=0, gamma=0) -37.0505446 8.678654 4.2691578   312 -0.48823835 #> 444    WLR FH(rho=0, gamma=0) -48.2316074 9.136277 5.2791312   350 -0.57198040 #> 445    WLR FH(rho=0, gamma=0) -48.2316074 9.136277 5.2791312   350 -0.57198040 #> 446    WLR FH(rho=0, gamma=0) -31.3178955 8.718445 3.5921423   310 -0.41064734 #> 447    WLR FH(rho=0, gamma=0) -31.3385454 9.234562 3.3936146   350 -0.36525270 #> 448    WLR FH(rho=0, gamma=0) -29.4467733 8.843447 3.3297847   319 -0.37487251 #> 449    WLR FH(rho=0, gamma=0) -31.3385454 9.234562 3.3936146   350 -0.36525270 #> 450    WLR FH(rho=0, gamma=0) -31.3385454 9.234562 3.3936146   350 -0.36525270 #> 451    WLR FH(rho=0, gamma=0) -20.7261096 8.994767 2.3042408   332 -0.25640419 #> 452    WLR FH(rho=0, gamma=0) -21.1788273 9.218017 2.2975470   350 -0.24929101 #> 453    WLR FH(rho=0, gamma=0) -20.5334548 8.944242 2.2957176   328 -0.25690650 #> 454    WLR FH(rho=0, gamma=0) -21.1788273 9.218017 2.2975470   350 -0.24929101 #> 455    WLR FH(rho=0, gamma=0) -21.1788273 9.218017 2.2975470   350 -0.24929101 #> 456    WLR FH(rho=0, gamma=0) -21.1948804 8.677903 2.4423964   304 -0.28093426 #> 457    WLR FH(rho=0, gamma=0) -28.7057042 9.293928 3.0886516   350 -0.33108930 #> 458    WLR FH(rho=0, gamma=0) -19.9158746 8.622416 2.3097788   300 -0.26736641 #> 459    WLR FH(rho=0, gamma=0) -28.7057042 9.293928 3.0886516   350 -0.33108930 #> 460    WLR FH(rho=0, gamma=0) -28.7057042 9.293928 3.0886516   350 -0.33108930 #> 461    WLR FH(rho=0, gamma=0) -30.8026800 8.675805 3.5504119   308 -0.40643765 #> 462    WLR FH(rho=0, gamma=0) -33.8214777 9.220600 3.6680344   350 -0.39380522 #> 463    WLR FH(rho=0, gamma=0) -29.7109833 8.413522 3.5313371   290 -0.41707013 #> 464    WLR FH(rho=0, gamma=0) -33.8214777 9.220600 3.6680344   350 -0.39380522 #> 465    WLR FH(rho=0, gamma=0) -33.8214777 9.220600 3.6680344   350 -0.39380522 #> 466    WLR FH(rho=0, gamma=0) -14.8926212 8.956359 1.6627986   325 -0.18549373 #> 467    WLR FH(rho=0, gamma=0) -16.7094922 9.305772 1.7956052   350 -0.19278341 #> 468    WLR FH(rho=0, gamma=0) -15.3230804 8.914635 1.7188679   322 -0.19266225 #> 469    WLR FH(rho=0, gamma=0) -16.7094922 9.305772 1.7956052   350 -0.19278341 #> 470    WLR FH(rho=0, gamma=0) -16.7094922 9.305772 1.7956052   350 -0.19278341 #> 471    WLR FH(rho=0, gamma=0) -34.7381647 8.608903 4.0351441   305 -0.46975762 #> 472    WLR FH(rho=0, gamma=0) -35.3079683 9.219775 3.8295910   350 -0.41391937 #> 473    WLR FH(rho=0, gamma=0) -33.0776295 8.493712 3.8943667   296 -0.45961010 #> 474    WLR FH(rho=0, gamma=0) -35.3079683 9.219775 3.8295910   350 -0.41391937 #> 475    WLR FH(rho=0, gamma=0) -35.3079683 9.219775 3.8295910   350 -0.41391937 #> 476    WLR FH(rho=0, gamma=0) -29.8788441 8.777301 3.4041040   315 -0.38712513 #> 477    WLR FH(rho=0, gamma=0) -38.5222224 9.228203 4.1744012   350 -0.45093611 #> 478    WLR FH(rho=0, gamma=0) -30.3654327 8.792151 3.4536978   316 -0.39217647 #> 479    WLR FH(rho=0, gamma=0) -38.5222224 9.228203 4.1744012   350 -0.45093611 #> 480    WLR FH(rho=0, gamma=0) -38.5222224 9.228203 4.1744012   350 -0.45093611 #> 481    WLR FH(rho=0, gamma=0) -16.2464302 8.928742 1.8195653   322 -0.20359274 #> 482    WLR FH(rho=0, gamma=0) -13.3050575 9.295157 1.4313967   350 -0.15377723 #> 483    WLR FH(rho=0, gamma=0) -16.7710964 8.942694 1.8753965   323 -0.20952779 #> 484    WLR FH(rho=0, gamma=0) -13.3050575 9.295157 1.4313967   350 -0.15377723 #> 485    WLR FH(rho=0, gamma=0) -13.3050575 9.295157 1.4313967   350 -0.15377723 #> 486    WLR FH(rho=0, gamma=0) -34.0449216 9.116042 3.7346165   338 -0.40799397 #> 487    WLR FH(rho=0, gamma=0) -34.7017497 9.261516 3.7468756   350 -0.40241159 #> 488    WLR FH(rho=0, gamma=0) -30.4212672 8.889081 3.4223187   321 -0.38388611 #> 489    WLR FH(rho=0, gamma=0) -34.7017497 9.261516 3.7468756   350 -0.40241159 #> 490    WLR FH(rho=0, gamma=0) -34.7017497 9.261516 3.7468756   350 -0.40241159 #> 491    WLR FH(rho=0, gamma=0) -17.8836796 8.418139 2.1244221   286 -0.25249284 #> 492    WLR FH(rho=0, gamma=0) -25.8594765 9.302088 2.7799647   350 -0.29835075 #> 493    WLR FH(rho=0, gamma=0) -18.9827582 8.767904 2.1650280   311 -0.24663524 #> 494    WLR FH(rho=0, gamma=0) -25.8594765 9.302088 2.7799647   350 -0.29835075 #> 495    WLR FH(rho=0, gamma=0) -25.8594765 9.302088 2.7799647   350 -0.29835075 #> 496    WLR FH(rho=0, gamma=0) -18.8356278 8.645086 2.1787671   302 -0.25193622 #> 497    WLR FH(rho=0, gamma=0) -23.5941053 9.281569 2.5420385   350 -0.27316591 #> 498    WLR FH(rho=0, gamma=0) -20.3968493 8.686215 2.3481862   305 -0.27033093 #> 499    WLR FH(rho=0, gamma=0) -23.5941053 9.281569 2.5420385   350 -0.27316591 #> 500    WLR FH(rho=0, gamma=0) -23.5941053 9.281569 2.5420385   350 -0.27316591 #>                                  cut duration sim #> 1                   Planned duration 30.00000   1 #> 2                    Targeted events 34.56252   1 #> 3                  Minimum follow-up 30.26592   1 #> 4   Max(planned duration, event cut) 34.56252   1 #> 5      Max(min follow-up, event cut) 34.56252   1 #> 6                   Planned duration 30.00000   2 #> 7                    Targeted events 31.32993   2 #> 8                  Minimum follow-up 30.19554   2 #> 9   Max(planned duration, event cut) 31.32993   2 #> 10     Max(min follow-up, event cut) 31.32993   2 #> 11                  Planned duration 30.00000   3 #> 12                   Targeted events 36.44080   3 #> 13                 Minimum follow-up 31.44128   3 #> 14  Max(planned duration, event cut) 36.44080   3 #> 15     Max(min follow-up, event cut) 36.44080   3 #> 16                  Planned duration 30.00000   4 #> 17                   Targeted events 34.65063   4 #> 18                 Minimum follow-up 29.90029   4 #> 19  Max(planned duration, event cut) 34.65063   4 #> 20     Max(min follow-up, event cut) 34.65063   4 #> 21                  Planned duration 30.00000   5 #> 22                   Targeted events 33.46261   5 #> 23                 Minimum follow-up 28.83239   5 #> 24  Max(planned duration, event cut) 33.46261   5 #> 25     Max(min follow-up, event cut) 33.46261   5 #> 26                  Planned duration 30.00000   6 #> 27                   Targeted events 36.65492   6 #> 28                 Minimum follow-up 30.98457   6 #> 29  Max(planned duration, event cut) 36.65492   6 #> 30     Max(min follow-up, event cut) 36.65492   6 #> 31                  Planned duration 30.00000   7 #> 32                   Targeted events 31.07340   7 #> 33                 Minimum follow-up 28.80649   7 #> 34  Max(planned duration, event cut) 31.07340   7 #> 35     Max(min follow-up, event cut) 31.07340   7 #> 36                  Planned duration 30.00000   8 #> 37                   Targeted events 33.95026   8 #> 38                 Minimum follow-up 31.19859   8 #> 39  Max(planned duration, event cut) 33.95026   8 #> 40     Max(min follow-up, event cut) 33.95026   8 #> 41                  Planned duration 30.00000   9 #> 42                   Targeted events 33.20459   9 #> 43                 Minimum follow-up 29.69966   9 #> 44  Max(planned duration, event cut) 33.20459   9 #> 45     Max(min follow-up, event cut) 33.20459   9 #> 46                  Planned duration 30.00000  10 #> 47                   Targeted events 34.49827  10 #> 48                 Minimum follow-up 28.50262  10 #> 49  Max(planned duration, event cut) 34.49827  10 #> 50     Max(min follow-up, event cut) 34.49827  10 #> 51                  Planned duration 30.00000  11 #> 52                   Targeted events 34.65074  11 #> 53                 Minimum follow-up 29.31876  11 #> 54  Max(planned duration, event cut) 34.65074  11 #> 55     Max(min follow-up, event cut) 34.65074  11 #> 56                  Planned duration 30.00000  12 #> 57                   Targeted events 32.44983  12 #> 58                 Minimum follow-up 29.65292  12 #> 59  Max(planned duration, event cut) 32.44983  12 #> 60     Max(min follow-up, event cut) 32.44983  12 #> 61                  Planned duration 30.00000  13 #> 62                   Targeted events 31.55883  13 #> 63                 Minimum follow-up 28.91997  13 #> 64  Max(planned duration, event cut) 31.55883  13 #> 65     Max(min follow-up, event cut) 31.55883  13 #> 66                  Planned duration 30.00000  14 #> 67                   Targeted events 35.79983  14 #> 68                 Minimum follow-up 33.72392  14 #> 69  Max(planned duration, event cut) 35.79983  14 #> 70     Max(min follow-up, event cut) 35.79983  14 #> 71                  Planned duration 30.00000  15 #> 72                   Targeted events 35.03286  15 #> 73                 Minimum follow-up 30.38550  15 #> 74  Max(planned duration, event cut) 35.03286  15 #> 75     Max(min follow-up, event cut) 35.03286  15 #> 76                  Planned duration 30.00000  16 #> 77                   Targeted events 34.98842  16 #> 78                 Minimum follow-up 29.75020  16 #> 79  Max(planned duration, event cut) 34.98842  16 #> 80     Max(min follow-up, event cut) 34.98842  16 #> 81                  Planned duration 30.00000  17 #> 82                   Targeted events 34.99259  17 #> 83                 Minimum follow-up 30.60927  17 #> 84  Max(planned duration, event cut) 34.99259  17 #> 85     Max(min follow-up, event cut) 34.99259  17 #> 86                  Planned duration 30.00000  18 #> 87                   Targeted events 33.31031  18 #> 88                 Minimum follow-up 28.31274  18 #> 89  Max(planned duration, event cut) 33.31031  18 #> 90     Max(min follow-up, event cut) 33.31031  18 #> 91                  Planned duration 30.00000  19 #> 92                   Targeted events 35.08991  19 #> 93                 Minimum follow-up 28.98224  19 #> 94  Max(planned duration, event cut) 35.08991  19 #> 95     Max(min follow-up, event cut) 35.08991  19 #> 96                  Planned duration 30.00000  20 #> 97                   Targeted events 36.42758  20 #> 98                 Minimum follow-up 30.30389  20 #> 99  Max(planned duration, event cut) 36.42758  20 #> 100    Max(min follow-up, event cut) 36.42758  20 #> 101                 Planned duration 30.00000  21 #> 102                  Targeted events 31.24966  21 #> 103                Minimum follow-up 30.17003  21 #> 104 Max(planned duration, event cut) 31.24966  21 #> 105    Max(min follow-up, event cut) 31.24966  21 #> 106                 Planned duration 30.00000  22 #> 107                  Targeted events 35.50895  22 #> 108                Minimum follow-up 28.10047  22 #> 109 Max(planned duration, event cut) 35.50895  22 #> 110    Max(min follow-up, event cut) 35.50895  22 #> 111                 Planned duration 30.00000  23 #> 112                  Targeted events 32.53926  23 #> 113                Minimum follow-up 29.50244  23 #> 114 Max(planned duration, event cut) 32.53926  23 #> 115    Max(min follow-up, event cut) 32.53926  23 #> 116                 Planned duration 30.00000  24 #> 117                  Targeted events 34.93207  24 #> 118                Minimum follow-up 29.68265  24 #> 119 Max(planned duration, event cut) 34.93207  24 #> 120    Max(min follow-up, event cut) 34.93207  24 #> 121                 Planned duration 30.00000  25 #> 122                  Targeted events 34.95328  25 #> 123                Minimum follow-up 31.35324  25 #> 124 Max(planned duration, event cut) 34.95328  25 #> 125    Max(min follow-up, event cut) 34.95328  25 #> 126                 Planned duration 30.00000  26 #> 127                  Targeted events 32.22708  26 #> 128                Minimum follow-up 29.50572  26 #> 129 Max(planned duration, event cut) 32.22708  26 #> 130    Max(min follow-up, event cut) 32.22708  26 #> 131                 Planned duration 30.00000  27 #> 132                  Targeted events 34.08638  27 #> 133                Minimum follow-up 30.70187  27 #> 134 Max(planned duration, event cut) 34.08638  27 #> 135    Max(min follow-up, event cut) 34.08638  27 #> 136                 Planned duration 30.00000  28 #> 137                  Targeted events 33.57268  28 #> 138                Minimum follow-up 30.35670  28 #> 139 Max(planned duration, event cut) 33.57268  28 #> 140    Max(min follow-up, event cut) 33.57268  28 #> 141                 Planned duration 30.00000  29 #> 142                  Targeted events 31.76390  29 #> 143                Minimum follow-up 28.44688  29 #> 144 Max(planned duration, event cut) 31.76390  29 #> 145    Max(min follow-up, event cut) 31.76390  29 #> 146                 Planned duration 30.00000  30 #> 147                  Targeted events 35.52284  30 #> 148                Minimum follow-up 31.28813  30 #> 149 Max(planned duration, event cut) 35.52284  30 #> 150    Max(min follow-up, event cut) 35.52284  30 #> 151                 Planned duration 30.00000  31 #> 152                  Targeted events 36.75499  31 #> 153                Minimum follow-up 29.59861  31 #> 154 Max(planned duration, event cut) 36.75499  31 #> 155    Max(min follow-up, event cut) 36.75499  31 #> 156                 Planned duration 30.00000  32 #> 157                  Targeted events 35.32287  32 #> 158                Minimum follow-up 30.87719  32 #> 159 Max(planned duration, event cut) 35.32287  32 #> 160    Max(min follow-up, event cut) 35.32287  32 #> 161                 Planned duration 30.00000  33 #> 162                  Targeted events 34.21867  33 #> 163                Minimum follow-up 28.99271  33 #> 164 Max(planned duration, event cut) 34.21867  33 #> 165    Max(min follow-up, event cut) 34.21867  33 #> 166                 Planned duration 30.00000  34 #> 167                  Targeted events 32.81083  34 #> 168                Minimum follow-up 29.61577  34 #> 169 Max(planned duration, event cut) 32.81083  34 #> 170    Max(min follow-up, event cut) 32.81083  34 #> 171                 Planned duration 30.00000  35 #> 172                  Targeted events 35.08037  35 #> 173                Minimum follow-up 29.74254  35 #> 174 Max(planned duration, event cut) 35.08037  35 #> 175    Max(min follow-up, event cut) 35.08037  35 #> 176                 Planned duration 30.00000  36 #> 177                  Targeted events 31.99763  36 #> 178                Minimum follow-up 27.73686  36 #> 179 Max(planned duration, event cut) 31.99763  36 #> 180    Max(min follow-up, event cut) 31.99763  36 #> 181                 Planned duration 30.00000  37 #> 182                  Targeted events 35.13270  37 #> 183                Minimum follow-up 28.39063  37 #> 184 Max(planned duration, event cut) 35.13270  37 #> 185    Max(min follow-up, event cut) 35.13270  37 #> 186                 Planned duration 30.00000  38 #> 187                  Targeted events 33.15620  38 #> 188                Minimum follow-up 28.16147  38 #> 189 Max(planned duration, event cut) 33.15620  38 #> 190    Max(min follow-up, event cut) 33.15620  38 #> 191                 Planned duration 30.00000  39 #> 192                  Targeted events 33.15477  39 #> 193                Minimum follow-up 29.98781  39 #> 194 Max(planned duration, event cut) 33.15477  39 #> 195    Max(min follow-up, event cut) 33.15477  39 #> 196                 Planned duration 30.00000  40 #> 197                  Targeted events 35.32938  40 #> 198                Minimum follow-up 30.93153  40 #> 199 Max(planned duration, event cut) 35.32938  40 #> 200    Max(min follow-up, event cut) 35.32938  40 #> 201                 Planned duration 30.00000  41 #> 202                  Targeted events 34.75173  41 #> 203                Minimum follow-up 31.36614  41 #> 204 Max(planned duration, event cut) 34.75173  41 #> 205    Max(min follow-up, event cut) 34.75173  41 #> 206                 Planned duration 30.00000  42 #> 207                  Targeted events 33.78014  42 #> 208                Minimum follow-up 27.71455  42 #> 209 Max(planned duration, event cut) 33.78014  42 #> 210    Max(min follow-up, event cut) 33.78014  42 #> 211                 Planned duration 30.00000  43 #> 212                  Targeted events 33.92332  43 #> 213                Minimum follow-up 29.67460  43 #> 214 Max(planned duration, event cut) 33.92332  43 #> 215    Max(min follow-up, event cut) 33.92332  43 #> 216                 Planned duration 30.00000  44 #> 217                  Targeted events 35.00782  44 #> 218                Minimum follow-up 31.53494  44 #> 219 Max(planned duration, event cut) 35.00782  44 #> 220    Max(min follow-up, event cut) 35.00782  44 #> 221                 Planned duration 30.00000  45 #> 222                  Targeted events 32.69217  45 #> 223                Minimum follow-up 31.19296  45 #> 224 Max(planned duration, event cut) 32.69217  45 #> 225    Max(min follow-up, event cut) 32.69217  45 #> 226                 Planned duration 30.00000  46 #> 227                  Targeted events 33.96500  46 #> 228                Minimum follow-up 30.39167  46 #> 229 Max(planned duration, event cut) 33.96500  46 #> 230    Max(min follow-up, event cut) 33.96500  46 #> 231                 Planned duration 30.00000  47 #> 232                  Targeted events 35.09326  47 #> 233                Minimum follow-up 30.13249  47 #> 234 Max(planned duration, event cut) 35.09326  47 #> 235    Max(min follow-up, event cut) 35.09326  47 #> 236                 Planned duration 30.00000  48 #> 237                  Targeted events 33.46691  48 #> 238                Minimum follow-up 29.99249  48 #> 239 Max(planned duration, event cut) 33.46691  48 #> 240    Max(min follow-up, event cut) 33.46691  48 #> 241                 Planned duration 30.00000  49 #> 242                  Targeted events 33.11491  49 #> 243                Minimum follow-up 29.11094  49 #> 244 Max(planned duration, event cut) 33.11491  49 #> 245    Max(min follow-up, event cut) 33.11491  49 #> 246                 Planned duration 30.00000  50 #> 247                  Targeted events 34.73370  50 #> 248                Minimum follow-up 31.10906  50 #> 249 Max(planned duration, event cut) 34.73370  50 #> 250    Max(min follow-up, event cut) 34.73370  50 #> 251                 Planned duration 30.00000  51 #> 252                  Targeted events 34.81528  51 #> 253                Minimum follow-up 30.57508  51 #> 254 Max(planned duration, event cut) 34.81528  51 #> 255    Max(min follow-up, event cut) 34.81528  51 #> 256                 Planned duration 30.00000  52 #> 257                  Targeted events 34.62794  52 #> 258                Minimum follow-up 31.18999  52 #> 259 Max(planned duration, event cut) 34.62794  52 #> 260    Max(min follow-up, event cut) 34.62794  52 #> 261                 Planned duration 30.00000  53 #> 262                  Targeted events 34.06656  53 #> 263                Minimum follow-up 31.30138  53 #> 264 Max(planned duration, event cut) 34.06656  53 #> 265    Max(min follow-up, event cut) 34.06656  53 #> 266                 Planned duration 30.00000  54 #> 267                  Targeted events 35.10337  54 #> 268                Minimum follow-up 31.32082  54 #> 269 Max(planned duration, event cut) 35.10337  54 #> 270    Max(min follow-up, event cut) 35.10337  54 #> 271                 Planned duration 30.00000  55 #> 272                  Targeted events 33.08402  55 #> 273                Minimum follow-up 30.35031  55 #> 274 Max(planned duration, event cut) 33.08402  55 #> 275    Max(min follow-up, event cut) 33.08402  55 #> 276                 Planned duration 30.00000  56 #> 277                  Targeted events 32.14236  56 #> 278                Minimum follow-up 29.27245  56 #> 279 Max(planned duration, event cut) 32.14236  56 #> 280    Max(min follow-up, event cut) 32.14236  56 #> 281                 Planned duration 30.00000  57 #> 282                  Targeted events 34.93451  57 #> 283                Minimum follow-up 30.10195  57 #> 284 Max(planned duration, event cut) 34.93451  57 #> 285    Max(min follow-up, event cut) 34.93451  57 #> 286                 Planned duration 30.00000  58 #> 287                  Targeted events 33.38745  58 #> 288                Minimum follow-up 30.22551  58 #> 289 Max(planned duration, event cut) 33.38745  58 #> 290    Max(min follow-up, event cut) 33.38745  58 #> 291                 Planned duration 30.00000  59 #> 292                  Targeted events 34.95228  59 #> 293                Minimum follow-up 30.65333  59 #> 294 Max(planned duration, event cut) 34.95228  59 #> 295    Max(min follow-up, event cut) 34.95228  59 #> 296                 Planned duration 30.00000  60 #> 297                  Targeted events 32.87052  60 #> 298                Minimum follow-up 30.32562  60 #> 299 Max(planned duration, event cut) 32.87052  60 #> 300    Max(min follow-up, event cut) 32.87052  60 #> 301                 Planned duration 30.00000  61 #> 302                  Targeted events 34.24457  61 #> 303                Minimum follow-up 29.30889  61 #> 304 Max(planned duration, event cut) 34.24457  61 #> 305    Max(min follow-up, event cut) 34.24457  61 #> 306                 Planned duration 30.00000  62 #> 307                  Targeted events 35.22550  62 #> 308                Minimum follow-up 29.93786  62 #> 309 Max(planned duration, event cut) 35.22550  62 #> 310    Max(min follow-up, event cut) 35.22550  62 #> 311                 Planned duration 30.00000  63 #> 312                  Targeted events 33.82268  63 #> 313                Minimum follow-up 30.43156  63 #> 314 Max(planned duration, event cut) 33.82268  63 #> 315    Max(min follow-up, event cut) 33.82268  63 #> 316                 Planned duration 30.00000  64 #> 317                  Targeted events 34.47059  64 #> 318                Minimum follow-up 30.41514  64 #> 319 Max(planned duration, event cut) 34.47059  64 #> 320    Max(min follow-up, event cut) 34.47059  64 #> 321                 Planned duration 30.00000  65 #> 322                  Targeted events 35.20960  65 #> 323                Minimum follow-up 30.13714  65 #> 324 Max(planned duration, event cut) 35.20960  65 #> 325    Max(min follow-up, event cut) 35.20960  65 #> 326                 Planned duration 30.00000  66 #> 327                  Targeted events 35.92377  66 #> 328                Minimum follow-up 32.40457  66 #> 329 Max(planned duration, event cut) 35.92377  66 #> 330    Max(min follow-up, event cut) 35.92377  66 #> 331                 Planned duration 30.00000  67 #> 332                  Targeted events 35.65085  67 #> 333                Minimum follow-up 30.06775  67 #> 334 Max(planned duration, event cut) 35.65085  67 #> 335    Max(min follow-up, event cut) 35.65085  67 #> 336                 Planned duration 30.00000  68 #> 337                  Targeted events 35.06020  68 #> 338                Minimum follow-up 30.37774  68 #> 339 Max(planned duration, event cut) 35.06020  68 #> 340    Max(min follow-up, event cut) 35.06020  68 #> 341                 Planned duration 30.00000  69 #> 342                  Targeted events 35.08805  69 #> 343                Minimum follow-up 32.06182  69 #> 344 Max(planned duration, event cut) 35.08805  69 #> 345    Max(min follow-up, event cut) 35.08805  69 #> 346                 Planned duration 30.00000  70 #> 347                  Targeted events 33.54823  70 #> 348                Minimum follow-up 30.38074  70 #> 349 Max(planned duration, event cut) 33.54823  70 #> 350    Max(min follow-up, event cut) 33.54823  70 #> 351                 Planned duration 30.00000  71 #> 352                  Targeted events 34.47262  71 #> 353                Minimum follow-up 29.08655  71 #> 354 Max(planned duration, event cut) 34.47262  71 #> 355    Max(min follow-up, event cut) 34.47262  71 #> 356                 Planned duration 30.00000  72 #> 357                  Targeted events 34.40623  72 #> 358                Minimum follow-up 30.65888  72 #> 359 Max(planned duration, event cut) 34.40623  72 #> 360    Max(min follow-up, event cut) 34.40623  72 #> 361                 Planned duration 30.00000  73 #> 362                  Targeted events 31.57970  73 #> 363                Minimum follow-up 28.33111  73 #> 364 Max(planned duration, event cut) 31.57970  73 #> 365    Max(min follow-up, event cut) 31.57970  73 #> 366                 Planned duration 30.00000  74 #> 367                  Targeted events 35.86374  74 #> 368                Minimum follow-up 31.07454  74 #> 369 Max(planned duration, event cut) 35.86374  74 #> 370    Max(min follow-up, event cut) 35.86374  74 #> 371                 Planned duration 30.00000  75 #> 372                  Targeted events 34.79521  75 #> 373                Minimum follow-up 29.95887  75 #> 374 Max(planned duration, event cut) 34.79521  75 #> 375    Max(min follow-up, event cut) 34.79521  75 #> 376                 Planned duration 30.00000  76 #> 377                  Targeted events 32.80305  76 #> 378                Minimum follow-up 29.38033  76 #> 379 Max(planned duration, event cut) 32.80305  76 #> 380    Max(min follow-up, event cut) 32.80305  76 #> 381                 Planned duration 30.00000  77 #> 382                  Targeted events 38.39885  77 #> 383                Minimum follow-up 31.65124  77 #> 384 Max(planned duration, event cut) 38.39885  77 #> 385    Max(min follow-up, event cut) 38.39885  77 #> 386                 Planned duration 30.00000  78 #> 387                  Targeted events 34.87496  78 #> 388                Minimum follow-up 29.66380  78 #> 389 Max(planned duration, event cut) 34.87496  78 #> 390    Max(min follow-up, event cut) 34.87496  78 #> 391                 Planned duration 30.00000  79 #> 392                  Targeted events 33.95847  79 #> 393                Minimum follow-up 28.89698  79 #> 394 Max(planned duration, event cut) 33.95847  79 #> 395    Max(min follow-up, event cut) 33.95847  79 #> 396                 Planned duration 30.00000  80 #> 397                  Targeted events 34.91475  80 #> 398                Minimum follow-up 30.02777  80 #> 399 Max(planned duration, event cut) 34.91475  80 #> 400    Max(min follow-up, event cut) 34.91475  80 #> 401                 Planned duration 30.00000  81 #> 402                  Targeted events 37.03746  81 #> 403                Minimum follow-up 31.02185  81 #> 404 Max(planned duration, event cut) 37.03746  81 #> 405    Max(min follow-up, event cut) 37.03746  81 #> 406                 Planned duration 30.00000  82 #> 407                  Targeted events 35.18807  82 #> 408                Minimum follow-up 30.18952  82 #> 409 Max(planned duration, event cut) 35.18807  82 #> 410    Max(min follow-up, event cut) 35.18807  82 #> 411                 Planned duration 30.00000  83 #> 412                  Targeted events 31.91792  83 #> 413                Minimum follow-up 28.76744  83 #> 414 Max(planned duration, event cut) 31.91792  83 #> 415    Max(min follow-up, event cut) 31.91792  83 #> 416                 Planned duration 30.00000  84 #> 417                  Targeted events 34.25827  84 #> 418                Minimum follow-up 29.59276  84 #> 419 Max(planned duration, event cut) 34.25827  84 #> 420    Max(min follow-up, event cut) 34.25827  84 #> 421                 Planned duration 30.00000  85 #> 422                  Targeted events 34.13983  85 #> 423                Minimum follow-up 30.05535  85 #> 424 Max(planned duration, event cut) 34.13983  85 #> 425    Max(min follow-up, event cut) 34.13983  85 #> 426                 Planned duration 30.00000  86 #> 427                  Targeted events 34.67392  86 #> 428                Minimum follow-up 30.52656  86 #> 429 Max(planned duration, event cut) 34.67392  86 #> 430    Max(min follow-up, event cut) 34.67392  86 #> 431                 Planned duration 30.00000  87 #> 432                  Targeted events 34.10374  87 #> 433                Minimum follow-up 29.31655  87 #> 434 Max(planned duration, event cut) 34.10374  87 #> 435    Max(min follow-up, event cut) 34.10374  87 #> 436                 Planned duration 30.00000  88 #> 437                  Targeted events 35.22186  88 #> 438                Minimum follow-up 28.80527  88 #> 439 Max(planned duration, event cut) 35.22186  88 #> 440    Max(min follow-up, event cut) 35.22186  88 #> 441                 Planned duration 30.00000  89 #> 442                  Targeted events 34.40650  89 #> 443                Minimum follow-up 30.46735  89 #> 444 Max(planned duration, event cut) 34.40650  89 #> 445    Max(min follow-up, event cut) 34.40650  89 #> 446                 Planned duration 30.00000  90 #> 447                  Targeted events 33.09799  90 #> 448                Minimum follow-up 30.95716  90 #> 449 Max(planned duration, event cut) 33.09799  90 #> 450    Max(min follow-up, event cut) 33.09799  90 #> 451                 Planned duration 30.00000  91 #> 452                  Targeted events 31.97511  91 #> 453                Minimum follow-up 29.74051  91 #> 454 Max(planned duration, event cut) 31.97511  91 #> 455    Max(min follow-up, event cut) 31.97511  91 #> 456                 Planned duration 30.00000  92 #> 457                  Targeted events 35.49273  92 #> 458                Minimum follow-up 29.67250  92 #> 459 Max(planned duration, event cut) 35.49273  92 #> 460    Max(min follow-up, event cut) 35.49273  92 #> 461                 Planned duration 30.00000  93 #> 462                  Targeted events 34.59404  93 #> 463                Minimum follow-up 28.35316  93 #> 464 Max(planned duration, event cut) 34.59404  93 #> 465    Max(min follow-up, event cut) 34.59404  93 #> 466                 Planned duration 30.00000  94 #> 467                  Targeted events 32.20619  94 #> 468                Minimum follow-up 29.88147  94 #> 469 Max(planned duration, event cut) 32.20619  94 #> 470    Max(min follow-up, event cut) 32.20619  94 #> 471                 Planned duration 30.00000  95 #> 472                  Targeted events 35.40507  95 #> 473                Minimum follow-up 28.56254  95 #> 474 Max(planned duration, event cut) 35.40507  95 #> 475    Max(min follow-up, event cut) 35.40507  95 #> 476                 Planned duration 30.00000  96 #> 477                  Targeted events 33.61292  96 #> 478                Minimum follow-up 30.03990  96 #> 479 Max(planned duration, event cut) 33.61292  96 #> 480    Max(min follow-up, event cut) 33.61292  96 #> 481                 Planned duration 30.00000  97 #> 482                  Targeted events 33.18038  97 #> 483                Minimum follow-up 30.12015  97 #> 484 Max(planned duration, event cut) 33.18038  97 #> 485    Max(min follow-up, event cut) 33.18038  97 #> 486                 Planned duration 30.00000  98 #> 487                  Targeted events 31.71537  98 #> 488                Minimum follow-up 28.45155  98 #> 489 Max(planned duration, event cut) 31.71537  98 #> 490    Max(min follow-up, event cut) 31.71537  98 #> 491                 Planned duration 30.00000  99 #> 492                  Targeted events 36.84463  99 #> 493                Minimum follow-up 33.34436  99 #> 494 Max(planned duration, event cut) 36.84463  99 #> 495    Max(min follow-up, event cut) 36.84463  99 #> 496                 Planned duration 30.00000 100 #> 497                  Targeted events 36.52875 100 #> 498                Minimum follow-up 30.73208 100 #> 499 Max(planned duration, event cut) 36.52875 100 #> 500    Max(min follow-up, event cut) 36.52875 100 # }"},{"path":"https://merck.github.io/simtrial/reference/sim_gs_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate group sequential designs with fixed sample size — sim_gs_n","title":"Simulate group sequential designs with fixed sample size — sim_gs_n","text":"function uses option \"stop\" error-handling behavior foreach loop. cause entire function stop errors encountered return first error encountered instead returning errors individual simulation.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_gs_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate group sequential designs with fixed sample size — sim_gs_n","text":"","code":"sim_gs_n(   n_sim = 1000,   sample_size = 500,   stratum = data.frame(stratum = \"All\", p = 1),   enroll_rate = data.frame(duration = c(2, 2, 10), rate = c(3, 6, 9)),   fail_rate = data.frame(stratum = \"All\", duration = c(3, 100), fail_rate = log(2)/c(9,     18), hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)),   block = rep(c(\"experimental\", \"control\"), 2),   test = wlr,   cut = NULL,   original_design = NULL,   ia_alpha_spending = c(\"min_planned_actual\", \"actual\"),   fa_alpha_spending = c(\"full_alpha\", \"info_frac\"),   ... )"},{"path":"https://merck.github.io/simtrial/reference/sim_gs_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate group sequential designs with fixed sample size — sim_gs_n","text":"n_sim Number simulations perform. sample_size Total sample size per simulation. stratum data frame stratum specified stratum, probability (incidence) stratum p. enroll_rate Piecewise constant enrollment rates time period. Note overall population enrollment rates stratum argument controls random distribution stratum. fail_rate Piecewise constant control group failure rates, hazard ratio experimental vs. control, dropout rates stratum time period. block sim_pw_surv(). Vector treatments included block. test One test functions wlr(), rmst(), milestone() (maxcombo() can applied ). single test function provided, applied cut. Alternatively list functions created create_test(). list form experimental currently limited. accepts one test per cutting (future multiple tests may accepted), tests must consistently return exact results (may flexible future). Importantly, note simulated data set always passed first positional argument test function provided. cut list cutting functions created create_cut(), see examples. original_design design object gsDesign2 package, required users want calculate updated bounds. default NULL leaving updated bounds uncalculated. ia_alpha_spending Spend alpha interim analysis based \"min_planned_actual\": minimal planned actual alpha spending. \"actual\": actual alpha spending. fa_alpha_spending targeted final event count achieved (-running final analysis), specify final spending. Generally, specified analysis plan. \"info_frac\" = spend final alpha according final information fraction \"full_alpha\" = spend full alpha final analysis. ... Arguments passed test function(s) provided argument test.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_gs_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate group sequential designs with fixed sample size — sim_gs_n","text":"data frame summarizing simulation ID, analysis date, z statistics p-values.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_gs_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate group sequential designs with fixed sample size — sim_gs_n","text":"WARNING: experimental function work--progress. function arguments change add additional features.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_gs_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate group sequential designs with fixed sample size — sim_gs_n","text":"","code":"library(gsDesign2)  # Parameters for enrollment enroll_rampup_duration <- 4 # Duration for enrollment ramp up enroll_duration <- 16 # Total enrollment duration enroll_rate <- define_enroll_rate(   duration = c(     enroll_rampup_duration,     enroll_duration - enroll_rampup_duration   ),   rate = c(10, 30) )  # Parameters for treatment effect delay_effect_duration <- 3 # Delay treatment effect in months median_ctrl <- 9 # Survival median of the control arm median_exp <- c(9, 14) # Survival median of the experimental arm dropout_rate <- 0.001 fail_rate <- define_fail_rate(   duration = c(delay_effect_duration, 100),   fail_rate = log(2) / median_ctrl,   hr = median_ctrl / median_exp,   dropout_rate = dropout_rate )  # Other related parameters alpha <- 0.025 # Type I error beta <- 0.1 # Type II error ratio <- 1 # Randomization ratio (experimental:control)  # Define cuttings of 2 IAs and 1 FA # IA1 # The 1st interim analysis will occur at the later of the following 3 conditions: # - At least 20 months have passed since the start of the study. # - At least 100 events have occurred. # - At least 20 months have elapsed after enrolling 200/400 subjects, with a #   minimum of 20 months follow-up. # However, if events accumulation is slow, we will wait for a maximum of 24 months. ia1_cut <- create_cut(   planned_calendar_time = 20,   target_event_overall = 100,   max_extension_for_target_event = 24,   min_n_overall = 200,   min_followup = 20 )  # IA2 # The 2nd interim analysis will occur at the later of the following 3 conditions: # - At least 32 months have passed since the start of the study. # - At least 200 events have occurred. # - At least 10 months after IA1. # However, if events accumulation is slow, we will wait for a maximum of 34 months. ia2_cut <- create_cut(   planned_calendar_time = 32,   target_event_overall = 200,   max_extension_for_target_event = 34,   min_time_after_previous_analysis = 10 )  # FA # The final analysis will occur at the later of the following 2 conditions: # - At least 45 months have passed since the start of the study. # - At least 350 events have occurred. fa_cut <- create_cut(   planned_calendar_time = 45,   target_event_overall = 350 )  # Example 1: regular logrank test at all 3 analyses sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = wlr,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   weight = fh(rho = 0, gamma = 0) ) #> Backend uses sequential processing. #>   sim_id method          parameter analysis cut_date   n event   estimate #> 1      1    WLR FH(rho=0, gamma=0)        1 24.00000 400   238 -14.341728 #> 2      1    WLR FH(rho=0, gamma=0)        2 32.00000 400   302 -25.890696 #> 3      1    WLR FH(rho=0, gamma=0)        3 47.15475 400   350 -31.002479 #> 4      2    WLR FH(rho=0, gamma=0)        1 24.00000 400   237 -28.176482 #> 5      2    WLR FH(rho=0, gamma=0)        2 32.00000 400   303 -27.607375 #> 6      2    WLR FH(rho=0, gamma=0)        3 45.20750 400   350 -31.998390 #> 7      3    WLR FH(rho=0, gamma=0)        1 24.00000 400   243  -8.083845 #> 8      3    WLR FH(rho=0, gamma=0)        2 32.00000 400   313 -18.518508 #> 9      3    WLR FH(rho=0, gamma=0)        3 45.00000 400   357 -15.358403 #>         se        z     info info0 #> 1 7.662756 1.871615 58.78481 59.25 #> 2 8.617322 3.004494 74.65232 75.50 #> 3 9.187449 3.374438 87.08857 87.50 #> 4 7.632234 3.691774 57.80591 59.25 #> 5 8.591683 3.213267 75.38614 75.75 #> 6 9.200596 3.477860 87.26857 87.50 #> 7 7.770050 1.040385 60.57613 60.75 #> 8 8.785069 2.107952 77.89776 78.25 #> 9 9.375340 1.638170 89.21569 89.25  # \\donttest{ # Example 2: weighted logrank test by FH(0, 0.5) at all 3 analyses sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = wlr,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   weight = fh(rho = 0, gamma = 0.5) ) #> Backend uses sequential processing. #>   sim_id method            parameter analysis cut_date   n event   estimate #> 1      1    WLR FH(rho=0, gamma=0.5)        1 24.00000 400   237 -14.458924 #> 2      1    WLR FH(rho=0, gamma=0.5)        2 32.00000 400   292 -16.365269 #> 3      1    WLR FH(rho=0, gamma=0.5)        3 47.13787 400   350 -17.603912 #> 4      2    WLR FH(rho=0, gamma=0.5)        1 24.00000 400   228  -6.217993 #> 5      2    WLR FH(rho=0, gamma=0.5)        2 32.00000 400   302 -14.879648 #> 6      2    WLR FH(rho=0, gamma=0.5)        3 45.00000 400   356 -19.941165 #> 7      3    WLR FH(rho=0, gamma=0.5)        1 24.00000 400   232 -18.771404 #> 8      3    WLR FH(rho=0, gamma=0.5)        2 32.00000 400   296 -22.955420 #> 9      3    WLR FH(rho=0, gamma=0.5)        3 45.00000 400   355 -31.838547 #>         se        z     info    info0 #> 1 4.195920 3.445948 16.89905 17.77081 #> 2 5.104649 3.205954 26.45812 26.70502 #> 3 6.091924 2.889713 38.31809 38.33033 #> 4 4.064090 1.529984 16.59433 16.63284 #> 5 5.300434 2.807251 28.37737 28.56080 #> 6 6.147001 3.244048 39.86389 39.86789 #> 7 4.094504 4.584536 16.45312 17.19726 #> 8 5.116139 4.486864 27.47104 27.62348 #> 9 5.976103 5.327643 39.70820 39.71523  # Example 3: weighted logrank test by MB(3) at all 3 analyses sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = wlr,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   weight = mb(delay = 3) ) #> Backend uses sequential processing. #>   sim_id method                       parameter analysis cut_date   n event #> 1      1    WLR MB(delay = 3, max_weight = Inf)        1 24.00000 400   219 #> 2      1    WLR MB(delay = 3, max_weight = Inf)        2 32.00000 400   289 #> 3      1    WLR MB(delay = 3, max_weight = Inf)        3 48.05091 400   350 #> 4      2    WLR MB(delay = 3, max_weight = Inf)        1 24.00000 400   246 #> 5      2    WLR MB(delay = 3, max_weight = Inf)        2 32.00000 400   312 #> 6      2    WLR MB(delay = 3, max_weight = Inf)        3 45.00000 400   359 #> 7      3    WLR MB(delay = 3, max_weight = Inf)        1 24.00000 400   255 #> 8      3    WLR MB(delay = 3, max_weight = Inf)        2 32.00000 400   307 #> 9      3    WLR MB(delay = 3, max_weight = Inf)        3 45.73872 400   350 #>    estimate        se        z      info     info0 #> 1 -21.56149  9.127796 2.362180  83.37872  84.02876 #> 2 -19.06355 10.616555 1.795644 113.88678 113.93178 #> 3 -20.32039 11.727229 1.732753 138.69425 138.70858 #> 4 -35.30840  9.559822 3.693415  91.07733  93.04918 #> 5 -43.82029 10.800501 4.057246 118.99073 120.16949 #> 6 -47.37567 11.512562 4.115128 138.26765 138.66062 #> 7 -15.28769  9.794462 1.560850  96.65626  96.85809 #> 8 -16.06341 10.836071 1.482402 118.14499 118.25449 #> 9 -25.92916 11.576048 2.239897 135.18593 135.53621  # Example 4: weighted logrank test by early zero (6) at all 3 analyses sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = wlr,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   weight = early_zero(6) ) #> Backend uses sequential processing. #>   sim_id method                                parameter analysis cut_date   n #> 1      1    WLR Xu 2017 with first 6 months of 0 weights        1 24.00000 400 #> 2      1    WLR Xu 2017 with first 6 months of 0 weights        2 32.00000 400 #> 3      1    WLR Xu 2017 with first 6 months of 0 weights        3 45.82652 400 #> 4      2    WLR Xu 2017 with first 6 months of 0 weights        1 24.00000 400 #> 5      2    WLR Xu 2017 with first 6 months of 0 weights        2 32.00000 400 #> 6      2    WLR Xu 2017 with first 6 months of 0 weights        3 49.28090 400 #> 7      3    WLR Xu 2017 with first 6 months of 0 weights        1 24.00000 400 #> 8      3    WLR Xu 2017 with first 6 months of 0 weights        2 32.00000 400 #> 9      3    WLR Xu 2017 with first 6 months of 0 weights        3 45.00000 400 #>   event  estimate       se        z     info info0 #> 1   246 -10.59987 5.155417 2.056065 26.22430 26.75 #> 2   303 -17.76063 6.355293 2.794621 40.39024 41.00 #> 3   350 -26.17475 7.141927 3.664942 52.12322 52.75 #> 4   224 -13.86612 5.032473 2.755329 24.31373 25.50 #> 5   294 -24.79518 6.505262 3.811558 41.51163 43.00 #> 6   350 -31.69640 7.360381 4.306354 56.36842 57.00 #> 7   236 -10.75188 5.038758 2.133835 25.91346 26.00 #> 8   302 -19.83549 6.346874 3.125239 42.47647 42.50 #> 9   353 -19.55176 7.165354 2.728653 54.99548 55.25  # Example 5: RMST at all 3 analyses sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = rmst,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   tau = 20 ) #> Backend uses sequential processing. #>   sim_id method parameter analysis cut_date   n event    estimate        se #> 1      1   RMST        20        1 24.00000 400   248  2.50301264 0.7518899 #> 2      1   RMST        20        2 32.00000 400   297  2.64873796 0.7354022 #> 3      1   RMST        20        3 49.48058 400   350  2.65073649 0.7360953 #> 4      2   RMST        20        1 24.00000 400   252  1.41183757 0.7595351 #> 5      2   RMST        20        2 32.00000 400   311  1.45891219 0.7383432 #> 6      2   RMST        20        3 45.00000 400   365  1.46871219 0.7379790 #> 7      3   RMST        20        1 24.00000 400   244 -0.17812793 0.7681930 #> 8      3   RMST        20        2 32.00000 400   309  0.03598688 0.7355750 #> 9      3   RMST        20        3 45.82981 400   350  0.04482531 0.7359993 #>             z #> 1  3.32896146 #> 2  3.60175433 #> 3  3.60107786 #> 4  1.85881819 #> 5  1.97592691 #> 6  1.99018154 #> 7 -0.23187914 #> 8  0.04892347 #> 9  0.06090401  # Example 6: Milestone at all 3 analyses sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = milestone,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   ms_time = 10 ) #> Backend uses sequential processing. #>   sim_id    method parameter analysis cut_date   n event  estimate        se #> 1      1 milestone        10        1       24 400   243 0.2532512 0.1476521 #> 2      1 milestone        10        2       32 400   304 0.2474294 0.1465762 #> 3      1 milestone        10        3       45 400   354 0.2474294 0.1465762 #> 4      2 milestone        10        1       24 400   259 0.3482071 0.1423805 #> 5      2 milestone        10        2       32 400   315 0.3481048 0.1423502 #> 6      2 milestone        10        3       45 400   363 0.3481048 0.1423502 #> 7      3 milestone        10        1       24 400   242 0.1988469 0.1467060 #> 8      3 milestone        10        2       32 400   311 0.1704664 0.1430125 #> 9      3 milestone        10        3       45 400   368 0.1704664 0.1430125 #>          z #> 1 1.715189 #> 2 1.688060 #> 3 1.688060 #> 4 2.445610 #> 5 2.445411 #> 6 2.445411 #> 7 1.355411 #> 8 1.191969 #> 9 1.191969 # }  # Warning: this example will be executable when we add info info0 to the milestone test # Example 7: WLR with fh(0, 0.5) test at IA1, # WLR with mb(6, Inf) at IA2, and milestone test at FA ia1_test <- create_test(wlr, weight = fh(rho = 0, gamma = 0.5)) ia2_test <- create_test(wlr, weight = mb(delay = 6, w_max = Inf)) fa_test <- create_test(milestone, ms_time = 10) if (FALSE) { # \\dontrun{ sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = list(ia1 = ia1_test, ia2 = ia2_test, fa = fa_test),   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut) ) } # }  # WARNING: Multiple tests per cut will be enabled in a future version. #          Currently does not work. # Example 8: At IA1, we conduct 3 tests, LR, WLR with fh(0, 0.5), and RMST test. # At IA2, we conduct 2 tests, LR and WLR with early zero (6). # At FA, we conduct 2 tests, LR and milestone test. ia1_test <- list(   test1 = create_test(wlr, weight = fh(rho = 0, gamma = 0)),   test2 = create_test(wlr, weight = fh(rho = 0, gamma = 0.5)),   test3 = create_test(rmst, tau = 20) ) ia2_test <- list(   test1 = create_test(wlr, weight = fh(rho = 0, gamma = 0)),   test2 = create_test(wlr, weight = early_zero(6)) ) fa_test <- list(   test1 = create_test(wlr, weight = fh(rho = 0, gamma = 0)),   test3 = create_test(milestone, ms_time = 20) ) if (FALSE) { # \\dontrun{ sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = list(ia1 = ia1_test, ia2 = ia2_test, fa = fa_test),   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut) ) } # }  # \\donttest{ # Example 9: regular logrank test at all 3 analyses in parallel plan(\"multisession\", workers = 2) sim_gs_n(   n_sim = 3,   sample_size = 400,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   test = wlr,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   weight = fh(rho = 0, gamma = 0) ) #> Using 2 cores with backend multisession #>   sim_id method          parameter analysis cut_date   n event   estimate #> 1      1    WLR FH(rho=0, gamma=0)        1       24 400   238 -12.713173 #> 2      1    WLR FH(rho=0, gamma=0)        2       32 400   298 -18.420232 #> 3      1    WLR FH(rho=0, gamma=0)        3       45 400   352 -23.852666 #> 4      2    WLR FH(rho=0, gamma=0)        1       24 400   252  -7.149188 #> 5      2    WLR FH(rho=0, gamma=0)        2       32 400   306 -14.941903 #> 6      2    WLR FH(rho=0, gamma=0)        3       45 400   356 -20.174083 #> 7      3    WLR FH(rho=0, gamma=0)        1       24 400   258 -17.450839 #> 8      3    WLR FH(rho=0, gamma=0)        2       32 400   319 -22.495646 #> 9      3    WLR FH(rho=0, gamma=0)        3       45 400   357 -27.876167 #>         se         z     info info0 #> 1 7.682310 1.6548633 59.23109 59.50 #> 2 8.593728 2.1434507 74.16443 74.50 #> 3 9.292240 2.5669447 87.81818 88.00 #> 4 7.926459 0.9019398 62.90079 63.00 #> 5 8.725428 1.7124550 76.17320 76.50 #> 6 9.346423 2.1584817 88.82022 89.00 #> 7 8.016516 2.1768607 63.94186 64.50 #> 8 8.887344 2.5312000 79.40439 79.75 #> 9 9.315263 2.9925261 88.82022 89.00 plan(\"sequential\")  # Example 10: group sequential design with updated bounds -- efficacy only x <- gs_design_ahr(analysis_time = 1:3*12) |> to_integer() sim_gs_n(   n_sim = 1,   sample_size = max(x$analysis$n),   enroll_rate = x$enroll_rate,   fail_rate = x$fail_rate,   test = wlr,   cut = list(ia1 = create_cut(planned_calendar_time = x$analysis$time[1]),              ia2 = create_cut(planned_calendar_time = x$analysis$time[2]),              fa = create_cut(planned_calendar_time = x$analysis$time[3])),   weight = fh(rho = 0, gamma = 0),   original_design = x ) #> Backend uses sequential processing. #>   sim_id method          parameter analysis cut_date   n event   estimate #> 1      1    WLR FH(rho=0, gamma=0)        1 12.00002 421    90  -2.835018 #> 2      1    WLR FH(rho=0, gamma=0)        2 23.99062 524   241  -9.823122 #> 3      1    WLR FH(rho=0, gamma=0)        3 35.93242 524   320 -17.474021 #>         se         z     info info0 planned_lower_bound planned_upper_bound #> 1 4.742932 0.5977352 22.40000 22.50          -1.7052708            3.870248 #> 2 7.760276 1.2658212 59.95021 60.25           0.9601286            2.356655 #> 3 8.937393 1.9551587 79.38750 80.00           2.0047523            2.009758 #>   updated_lower_bound updated_upper_bound #> 1          -2.0109114            4.074501 #> 2           0.9868377            2.356220 #> 3           1.9995136            2.006884  # Example 11: group sequential design with updated bounds -- efficacy & futility x <- gs_design_ahr(  alpha = 0.025, beta = 0.1, analysis_time = 1:3*12,  upper = gs_spending_bound, upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),  lower = gs_spending_bound, lpar = list(sf = gsDesign::sfHSD, param = -4, total_spend = 0.01),  test_upper = c(FALSE, TRUE, TRUE), test_lower = c(TRUE, FALSE, FALSE)) |> to_integer() sim_gs_n(   n_sim = 1,   sample_size = max(x$analysis$n),   enroll_rate = x$enroll_rate,   fail_rate = x$fail_rate,   test = wlr,   cut = list(ia1 = create_cut(planned_calendar_time = x$analysis$time[1]),              ia2 = create_cut(planned_calendar_time = x$analysis$time[2]),              fa = create_cut(planned_calendar_time = x$analysis$time[3])),   weight = fh(rho = 0, gamma = 0),   original_design = x ) #> Backend uses sequential processing. #>   sim_id method          parameter analysis cut_date   n event   estimate #> 1      1    WLR FH(rho=0, gamma=0)        1 11.95079 426    91  -1.846892 #> 2      1    WLR FH(rho=0, gamma=0)        2 23.95510 496   211 -12.647993 #> 3      1    WLR FH(rho=0, gamma=0)        3 35.96078 496   311 -19.050336 #>         se         z     info info0 planned_lower_bound planned_upper_bound #> 1 4.767196 0.3874169 22.72527 22.75           -2.319759                  NA #> 2 7.258625 1.7424778 52.22749 52.75                  NA            2.358356 #> 3 8.801474 2.1644485 77.24759 77.75                  NA            2.009328 #>   updated_lower_bound updated_upper_bound #> 1           -2.361836                 Inf #> 2                -Inf            2.450308 #> 3                -Inf            2.001302 # }"},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"sim_pw_surv() enables simulation clinical trial essentially arbitrary patterns enrollment, failure rates censoring. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure, dropout rate changes time. main purpose may generate trial can analyzed single point time using group sequential methods, routine can also used simulate adaptive trial design. Enrollment, failure, dropout rates specified treatment group, stratum time period. Fixed block randomization used; blocks must include treatments provided failure dropout specification. Default arguments set allow simple implementation non-proportional hazards assumption unstratified design.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"","code":"sim_pw_surv(   n = 100,   stratum = data.frame(stratum = \"All\", p = 1),   block = c(rep(\"control\", 2), rep(\"experimental\", 2)),   enroll_rate = data.frame(rate = 9, duration = 1),   fail_rate = data.frame(stratum = rep(\"All\", 4), period = rep(1:2, 2), treatment =     c(rep(\"control\", 2), rep(\"experimental\", 2)), duration = rep(c(3, 1), 2), rate =     log(2)/c(9, 9, 9, 18)),   dropout_rate = data.frame(stratum = rep(\"All\", 2), period = rep(1, 2), treatment =     c(\"control\", \"experimental\"), duration = rep(100, 2), rate = rep(0.001, 2)) )"},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"n Number observations. length(n) > 1, length taken number required. stratum data frame stratum specified stratum, probability (incidence) stratum p. block Vector treatments included block. Also used calculate attribute \"ratio\" (details see section Value ). enroll_rate Enrollment rates; see details examples. fail_rate Failure rates; see details examples; note treatments need input block. dropout_rate Dropout rates; see details examples; note treatments need input block.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"data frame following variables observation: stratum: Stratum observation. enroll_time: Enrollment time observation. treatment: Treatment group; one values input block. fail_time: Failure time generated using rpwexp(). dropout_time: Dropout time generated using rpwexp(). cte: Calendar time enrollment plus minimum failure time dropout time. fail: Indicator cte set using failure time; .e., 1 failure, 0 dropout. data frame also attribute \"ratio\", calculated number \"experimental\" treatments divided number \"control\" treatments input argument block.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"","code":"library(dplyr)  # Example 1 sim_pw_surv(n = 20) #>    stratum enroll_time    treatment  fail_time dropout_time       cte fail #> 1      All  0.02142839 experimental  0.3408276     98.58106  0.362256    1 #> 2      All  0.02391720      control 10.6974702    126.02694 10.721387    1 #> 3      All  0.12132222      control 12.2867886    222.00638 12.408111    1 #> 4      All  0.33721875 experimental 48.4943098   3940.42836 48.831529    1 #> 5      All  0.34688264      control  5.5165464    747.72368  5.863429    1 #> 6      All  0.40649620      control 46.7612306   1035.36115 47.167727    1 #> 7      All  0.47819083 experimental  4.6297940    591.70021  5.107985    1 #> 8      All  0.61818734 experimental 25.3045387   1074.12731 25.922726    1 #> 9      All  0.75531457      control 12.3506497    280.66035 13.105964    1 #> 10     All  0.77138700 experimental  8.2785049    460.90846  9.049892    1 #> 11     All  0.78564859      control 27.5026277    159.48258 28.288276    1 #> 12     All  0.86767983 experimental  1.6351292    480.78425  2.502809    1 #> 13     All  0.98040092      control 24.6939029   2312.83176 25.674304    1 #> 14     All  1.09322355      control  2.0823743    195.25467  3.175598    1 #> 15     All  1.37734513 experimental 19.0080405     80.18976 20.385386    1 #> 16     All  1.42045481 experimental  0.7551894    278.42173  2.175644    1 #> 17     All  1.66141361      control  2.5583299    204.01239  4.219743    1 #> 18     All  1.73594205 experimental 32.7148660   1376.63546 34.450808    1 #> 19     All  1.92466435 experimental  0.1472751    176.17803  2.071939    1 #> 20     All  1.96150812      control 10.4512454   2664.66156 12.412754    1  # Example 2 # 3:1 randomization sim_pw_surv(   n = 20,   block = c(rep(\"experimental\", 3), \"control\") ) #>    stratum enroll_time    treatment   fail_time dropout_time        cte fail #> 1      All   0.3217242 experimental   9.4928294   742.229574   9.814554    1 #> 2      All   0.3565670 experimental  12.4943694   685.656819  12.850936    1 #> 3      All   0.3830329      control   7.9711034  3357.369819   8.354136    1 #> 4      All   0.4244951 experimental  41.0686377  1134.605316  41.493133    1 #> 5      All   0.4762787 experimental 116.8281381  1848.415820 117.304417    1 #> 6      All   0.4887699      control  28.9180215   146.013236  29.406791    1 #> 7      All   0.6136093 experimental   1.1196077   162.507928   1.733217    1 #> 8      All   0.6891445 experimental  44.2434604     4.963087   5.652231    0 #> 9      All   0.7894425 experimental   4.5214569   456.380132   5.310899    1 #> 10     All   1.0188476      control   5.8872020  1544.620162   6.906050    1 #> 11     All   1.0209447 experimental   6.9775576   276.484136   7.998502    1 #> 12     All   1.2873632 experimental  14.8730426   426.240944  16.160406    1 #> 13     All   1.4099907 experimental   0.1715598    30.568471   1.581550    1 #> 14     All   1.4468614 experimental  10.0687941  3025.328402  11.515656    1 #> 15     All   1.4532458      control   2.4995260  1411.869284   3.952772    1 #> 16     All   1.5900233 experimental  17.4354083  1147.682266  19.025432    1 #> 17     All   1.6577903 experimental  99.0519123    76.763221  78.421012    0 #> 18     All   1.8990358 experimental  19.0166778   440.688450  20.915714    1 #> 19     All   2.1388782      control  19.5929947   286.458360  21.731873    1 #> 20     All   2.2620772 experimental   3.6437051  1873.164324   5.905782    1  # Example 3 # Simulate 2 stratum; will use defaults for blocking and enrollRates sim_pw_surv(   n = 20,   # 2 stratum,30% and 70% prevalence   stratum = data.frame(stratum = c(\"Low\", \"High\"), p = c(.3, .7)),   fail_rate = data.frame(     stratum = c(rep(\"Low\", 4), rep(\"High\", 4)),     period = rep(1:2, 4),     treatment = rep(c(       rep(\"control\", 2),       rep(\"experimental\", 2)     ), 2),     duration = rep(c(3, 1), 4),     rate = c(.03, .05, .03, .03, .05, .08, .07, .04)   ),   dropout_rate = data.frame(     stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),     period = rep(1, 4),     treatment = rep(c(\"control\", \"experimental\"), 2),     duration = rep(1, 4),     rate = rep(.001, 4)   ) ) #>    stratum enroll_time    treatment fail_time dropout_time       cte fail #> 1     High  0.05272381 experimental  9.066633    494.34540  9.119357    1 #> 2      Low  0.13566515 experimental 78.546249    128.42704 78.681914    1 #> 3     High  0.26260540 experimental 54.966515     21.84553 22.108138    0 #> 4     High  0.33482645      control  7.189508   2008.07518  7.524335    1 #> 5      Low  0.48250535      control 14.974977    517.85966 15.457482    1 #> 6     High  0.68305515      control  7.064524    513.65581  7.747579    1 #> 7     High  0.81710026      control 21.438898   1164.23533 22.255998    1 #> 8     High  1.07033538      control 19.713971   2212.00385 20.784306    1 #> 9      Low  1.41332672      control 19.401860   2560.64452 20.815187    1 #> 10    High  1.61703621 experimental 17.517759    699.12197 19.134795    1 #> 11    High  1.61704018 experimental  7.688537    788.59361  9.305577    1 #> 12     Low  1.68979094 experimental  8.225572     89.70154  9.915363    1 #> 13     Low  1.73695233      control  4.916503   1871.11105  6.653455    1 #> 14     Low  1.78646504      control  6.955286    276.59924  8.741751    1 #> 15    High  1.79986228 experimental 16.726290    382.11254 18.526153    1 #> 16     Low  1.80771972 experimental 40.504842    653.13538 42.312562    1 #> 17     Low  1.90859178 experimental  4.846215    170.22468  6.754807    1 #> 18    High  1.99798037      control 43.722842     23.72062 25.718601    0 #> 19    High  2.00729138      control 15.319417    661.56404 17.326709    1 #> 20    High  2.02787066 experimental 22.863487    134.13149 24.891357    1 # Example 4 # If you want a more rectangular entry for a data.frame fail_rate <- bind_rows(   data.frame(stratum = \"Low\", period = 1, treatment = \"control\", duration = 3, rate = .03),   data.frame(stratum = \"Low\", period = 1, treatment = \"experimental\", duration = 3, rate = .03),   data.frame(stratum = \"Low\", period = 2, treatment = \"experimental\", duration = 3, rate = .02),   data.frame(stratum = \"High\", period = 1, treatment = \"control\", duration = 3, rate = .05),   data.frame(stratum = \"High\", period = 1, treatment = \"experimental\", duration = 3, rate = .06),   data.frame(stratum = \"High\", period = 2, treatment = \"experimental\", duration = 3, rate = .03) )  dropout_rate <- bind_rows(   data.frame(stratum = \"Low\", period = 1, treatment = \"control\", duration = 3, rate = .001),   data.frame(stratum = \"Low\", period = 1, treatment = \"experimental\", duration = 3, rate = .001),   data.frame(stratum = \"High\", period = 1, treatment = \"control\", duration = 3, rate = .001),   data.frame(stratum = \"High\", period = 1, treatment = \"experimental\", duration = 3, rate = .001) )  sim_pw_surv(   n = 12,   stratum = data.frame(stratum = c(\"Low\", \"High\"), p = c(.3, .7)),   fail_rate = fail_rate,   dropout_rate = dropout_rate ) #>    stratum enroll_time    treatment fail_time dropout_time        cte fail #> 1      Low   0.1321033 experimental 49.865443   1562.73537  49.997547    1 #> 2     High   0.3007465 experimental 18.103313    117.95707  18.404059    1 #> 3     High   0.4960628      control 13.752074    908.18929  14.248136    1 #> 4     High   0.5495319 experimental 36.791951    599.65573  37.341483    1 #> 5      Low   0.7205039 experimental 22.158442   1352.21930  22.878946    1 #> 6     High   0.8137968      control 34.253180    930.71607  35.066977    1 #> 7     High   0.8824684      control  8.837317     13.13534   9.719785    1 #> 8     High   0.9442470 experimental 53.139230   1493.85426  54.083477    1 #> 9     High   0.9865067 experimental 57.256334   1265.50109  58.242841    1 #> 10     Low   1.2318692      control 41.671776    403.53936  42.903645    1 #> 11    High   1.2658735      control 56.696444     46.61400  47.879875    0 #> 12     Low   1.4219050      control 98.788315    553.18286 100.210220    1"},{"path":"https://merck.github.io/simtrial/reference/simtrial-package.html","id":null,"dir":"Reference","previous_headings":"","what":"simtrial: Clinical Trial Simulation — simtrial-package","title":"simtrial: Clinical Trial Simulation — simtrial-package","text":"Provides basic routines simulating clinical trial. primary intent provide tools generate trial simulations trials time event outcomes. Piecewise exponential failure rates piecewise constant enrollment rates underlying mechanism used simulate broad range scenarios presented Lin et al. (2020) doi:10.1080/19466315.2019.1697738 . However, basic generation data done using pipes allow maximum flexibility users meet different needs.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/simtrial-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"simtrial: Clinical Trial Simulation — simtrial-package","text":"Maintainer: Yujie Zhao yujie.zhao@merck.com Authors: Keaven Anderson keaven_anderson@merck.com John Blischak Yilong Zhang contributors: Nan Xiao [contributor] Jianxiao Yang [contributor] Lili Ling [contributor] Xintong Li [contributor] Ruixue Wang [contributor] Yi Cui [contributor] Ping Yang [contributor] Yalin Zhu [contributor] Heng Zhou [contributor] Amin Shirazi [contributor] Cole Manschot [contributor] Larry Leon [contributor] Merck & Co., Inc., Rahway, NJ, USA affiliates (02891sr49) [copyright holder]","code":""},{"path":"https://merck.github.io/simtrial/reference/summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of group sequential simulations. — summary.simtrial_gs_wlr","title":"Summary of group sequential simulations. — summary.simtrial_gs_wlr","text":"Summary group sequential simulations.","code":""},{"path":"https://merck.github.io/simtrial/reference/summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of group sequential simulations. — summary.simtrial_gs_wlr","text":"","code":"# S3 method for class 'simtrial_gs_wlr' summary(object, design = NULL, bound = NULL, ...)"},{"path":"https://merck.github.io/simtrial/reference/summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of group sequential simulations. — summary.simtrial_gs_wlr","text":"object Simulation results generated sim_gs_n() design Asymptotic design generated gsDesign2::gs_design_ahr(), gsDesign2::gs_power_ahr(), gsDesign2::gs_design_wlr(), gsDesign2::gs_power_wlr. bound boundaries. ... Additional parameters (used).","code":""},{"path":"https://merck.github.io/simtrial/reference/summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of group sequential simulations. — summary.simtrial_gs_wlr","text":"data frame","code":""},{"path":"https://merck.github.io/simtrial/reference/summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of group sequential simulations. — summary.simtrial_gs_wlr","text":"","code":"library(gsDesign2)  # Parameters for enrollment enroll_rampup_duration <- 4 # Duration for enrollment ramp up enroll_duration <- 16 # Total enrollment duration enroll_rate <- define_enroll_rate(   duration = c(     enroll_rampup_duration, enroll_duration - enroll_rampup_duration),  rate = c(10, 30))  # Parameters for treatment effect delay_effect_duration <- 3 # Delay treatment effect in months median_ctrl <- 9 # Survival median of the control arm median_exp <- c(9, 14) # Survival median of the experimental arm dropout_rate <- 0.001 fail_rate <- define_fail_rate(   duration = c(delay_effect_duration, 100),   fail_rate = log(2) / median_ctrl,   hr = median_ctrl / median_exp,   dropout_rate = dropout_rate)  # Other related parameters alpha <- 0.025 # Type I error beta <- 0.1 # Type II error ratio <- 1 # Randomization ratio (experimental:control)  # Build a one-sided group sequential design design <- gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, alpha = alpha, beta = beta,   analysis_time = c(12, 24, 36),   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = alpha),   lower = gs_b,   lpar = rep(-Inf, 3))  # Define cuttings of 2 IAs and 1 FA ia1_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[1])) ia2_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[2])) fa_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[3]))  # Run simulations simulation <- sim_gs_n(   n_sim = 3,   sample_size = ceiling(design$analysis$n[3]),   enroll_rate = design$enroll_rate,   fail_rate = design$fail_rate,   test = wlr,   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),   weight = fh(rho = 0, gamma = 0.5)) #> Backend uses sequential processing.  # Summarize simulations bound <- gsDesign::gsDesign(k = 3, test.type = 1, sfu = gsDesign::sfLDOF)$upper$bound simulation |> summary(bound = bound) #>   analysis    sim_n sim_event sim_time sim_upper_prob #> 1        1 356.6667        97 11.87400             NA #> 2        2 505.0000       305 24.66698              1 #> 3        3 505.0000       405 37.58585             NA  # Summarize simulation and compare with the planned design simulation |> summary(design = design) #>   analysis asy_upper_prob sim_upper_prob sim_event    sim_n sim_time asy_time #> 1        1   0.0001486592             NA        97 356.6667 11.87400       12 #> 2        2   0.5723210881              1       305 505.0000 24.66698       24 #> 3        3   0.8999997572             NA       405 505.0000 37.58585       36 #>      asy_n asy_event #> 1 353.0464  96.77449 #> 2 504.3520 304.00970 #> 3 504.3520 404.14162"},{"path":"https://merck.github.io/simtrial/reference/to_sim_pw_surv.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert enrollment and failure rates from sim_fixed_n() to sim_pw_surv() format — to_sim_pw_surv","title":"Convert enrollment and failure rates from sim_fixed_n() to sim_pw_surv() format — to_sim_pw_surv","text":"to_sim_pw_surv() converts failure rates dropout rates entered simpler format sim_fixed_n() used sim_pw_surv(). fail_rate argument sim_fixed_n() requires enrollment rates, failure rates hazard ratios dropout rates stratum 2-arm trial, sim_pw_surv() flexible less obvious flexible format. Since sim_fixed_n() automatically analyzes data sim_pw_surv() just produces simulation dataset, latter provides additional options analyze otherwise evaluate individual simulations ways sim_fixed_n() .","code":""},{"path":"https://merck.github.io/simtrial/reference/to_sim_pw_surv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert enrollment and failure rates from sim_fixed_n() to sim_pw_surv() format — to_sim_pw_surv","text":"","code":"to_sim_pw_surv(   fail_rate = data.frame(stratum = \"All\", duration = c(3, 100), fail_rate = log(2)/c(9,     18), hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)) )"},{"path":"https://merck.github.io/simtrial/reference/to_sim_pw_surv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert enrollment and failure rates from sim_fixed_n() to sim_pw_surv() format — to_sim_pw_surv","text":"fail_rate Piecewise constant control group failure rates, hazard ratio experimental vs. control, dropout rates stratum time period.","code":""},{"path":"https://merck.github.io/simtrial/reference/to_sim_pw_surv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert enrollment and failure rates from sim_fixed_n() to sim_pw_surv() format — to_sim_pw_surv","text":"list two data frame components formatted sim_pw_surv(): fail_rate dropout_rate.","code":""},{"path":"https://merck.github.io/simtrial/reference/to_sim_pw_surv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert enrollment and failure rates from sim_fixed_n() to sim_pw_surv() format — to_sim_pw_surv","text":"","code":"# Example 1 # Convert standard input to_sim_pw_surv() #> $fail_rate #>   stratum period    treatment duration       rate #> 1     All      1      control        3 0.07701635 #> 2     All      2      control      100 0.03850818 #> 3     All      1 experimental        3 0.06931472 #> 4     All      2 experimental      100 0.02310491 #>  #> $dropout_rate #>   stratum period    treatment duration  rate #> 1     All      1      control        3 0.001 #> 2     All      2      control      100 0.001 #> 3     All      1 experimental        3 0.001 #> 4     All      2 experimental      100 0.001 #>   # Stratified example fail_rate <- data.frame(   stratum = c(rep(\"Low\", 3), rep(\"High\", 3)),   duration = rep(c(4, 10, 100), 2),   fail_rate = c(     .04, .1, .06,     .08, .16, .12   ),   hr = c(     1.5, .5, 2 / 3,     2, 10 / 16, 10 / 12   ),   dropout_rate = .01 )  x <- to_sim_pw_surv(fail_rate)  # Do a single simulation with the above rates # Enroll 300 patients in ~12 months at constant rate sim <- sim_pw_surv(   n = 300,   stratum = data.frame(stratum = c(\"Low\", \"High\"), p = c(.6, .4)),   enroll_rate = data.frame(duration = 12, rate = 300 / 12),   fail_rate = x$fail_rate,   dropout_rate = x$dropout_rate )  # Cut after 200 events and do a stratified logrank test sim |>   cut_data_by_event(200) |> # Cut data   wlr(weight = fh(rho = 0, gamma = 0)) # Stratified logrank #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0)\" #>  #> $estimate #> [1] 2.340246 #>  #> $se #> [1] 6.972734 #>  #> $z #> [1] -0.3356281 #>  #> $info #> [1] 49.92 #>  #> $info0 #> [1] 50 #>"},{"path":"https://merck.github.io/simtrial/reference/wlr.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted logrank test — wlr","title":"Weighted logrank test — wlr","text":"Weighted logrank test","code":""},{"path":"https://merck.github.io/simtrial/reference/wlr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weighted logrank test — wlr","text":"","code":"wlr(data, weight, return_variance = FALSE, ratio = NULL, formula = NULL)  # Default S3 method wlr(data, weight, return_variance = FALSE, ratio = NULL, formula = NULL)  # S3 method for class 'tte_data' wlr(data, weight, return_variance = FALSE, ratio = NULL, formula = NULL)  # S3 method for class 'counting_process' wlr(data, weight, return_variance = FALSE, ratio = NULL, formula = NULL)"},{"path":"https://merck.github.io/simtrial/reference/wlr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weighted logrank test — wlr","text":"data Dataset (generated sim_pw_surv()) cut counting_process(), cut_data_by_date(), cut_data_by_event(). weight Weighting functions, fh(), mb(), early_zero(). return_variance logical flag , TRUE, adds columns estimated variance weighted sum observed minus expected; see details; Default: FALSE. ratio randomization ratio (experimental:control). data generated simtrial, data = sim_pw_surv(...) |> cut_data_by_date(...) data = sim_pw_surv(...) |> cut_data_by_event(...) data = sim_pw_surv(...) |> cut_data_by_date(...) |> counting_process(...) data = sim_pw_surv(...) |> cut_data_by_event(...) |> counting_process(...) need input ratio, simtrial gets ratio via block arguments sim_pw_surv(). data custom dataset (see Example 2) , Users suggested input planned randomization ratio ratio; , simtrial takes empirical randomization ratio. formula formula specify columns contain time--event, event, treatment, stratum variables. used default S3 method classes aleady required column names. stratified designs, formula form Surv(tte, event) ~ treatment + strata(stratum), tte, event, treatment, stratum column names data time--event measurement, event status, treatment group, stratum, respectively. unstratified designs, formula can omit stratum column: Surv(tte, event) ~ treatment.","code":""},{"path":"https://merck.github.io/simtrial/reference/wlr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weighted logrank test — wlr","text":"list containing test method (method), parameters test method (parameter), point estimate treatment effect (estimate), standardized error treatment effect (se), Z-score (z), p-values (p_value).","code":""},{"path":"https://merck.github.io/simtrial/reference/wlr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Weighted logrank test — wlr","text":"\\(z\\) - Standardized normal Fleming-Harrington weighted logrank test. \\(\\) - Stratum index. \\(d_i\\) - Number distinct times events occurred stratum \\(\\). \\(t_{ij}\\) - Ordered times events stratum \\(\\), \\(j = 1, 2, \\ldots, d_i\\) observed; observation, \\(t_{ij}\\) represents time post study entry. \\(O_{ij.}\\) - Total number events stratum \\(\\) occurred time \\(t_{ij}\\). \\(O_{ije}\\) - Total number events stratum \\(\\) experimental treatment group occurred time \\(t_{ij}\\). \\(N_{ij.}\\) - Total number study subjects stratum \\(\\) followed least duration. \\(E_{ije}\\) - Expected observations experimental treatment group given random selection \\(O_{ij.}\\) stratum \\(\\) risk time \\(t_{ij}\\). \\(V_{ije}\\) - Hypergeometric variance \\(E_{ije}\\) produced Var counting_process(). \\(N_{ije}\\) - Total number study subjects stratum \\(\\) experimental treatment group followed least duration \\(t_{ij}\\). \\(E_{ije}\\) - Expected observations experimental group stratum \\(\\) time \\(t_{ij}\\) conditioning overall number events risk populations time sampling risk observations without replacement: $$E_{ije} = O_{ij.} N_{ije}/N_{ij.}$$ \\(S_{ij}\\) - Kaplan-Meier estimate survival combined treatment groups immediately prior time \\(t_{ij}\\). \\(\\rho, \\gamma\\) - Real parameters Fleming-Harrington test. \\(X_i\\) - Numerator signed logrank test stratum \\(\\) $$X_i = \\sum_{j=1}^{d_{}} S_{ij}^\\rho(1-S_{ij}^\\gamma)(O_{ije}-E_{ije})$$ \\(V_{ij}\\) - Variance used denominator Fleming-Harrington weighted logrank tests $$V_i = \\sum_{j=1}^{d_{}} (S_{ij}^\\rho(1-S_{ij}^\\gamma))^2V_{ij})$$ stratified Fleming-Harrington weighted logrank test computed : $$z = \\sum_i X_i/\\sqrt{\\sum_i V_i}.$$","code":""},{"path":"https://merck.github.io/simtrial/reference/wlr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weighted logrank test — wlr","text":"","code":"# ---------------------- # #      Example 1         # #  Use dataset generated # #     by simtrial        # # ---------------------- # x <- sim_pw_surv(n = 200) |> cut_data_by_event(100)  # Example 1A: WLR test with FH wights x |> wlr(weight = fh(rho = 0, gamma = 0.5)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -8.982144 #>  #> $se #> [1] 2.598847 #>  #> $z #> [1] 3.456203 #>  #> $info #> [1] 6.622735 #>  #> $info0 #> [1] 7.11092 #>  x |> wlr(weight = fh(rho = 0, gamma = 0.5), return_variance = TRUE) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -8.982144 #>  #> $se #> [1] 2.598847 #>  #> $z #> [1] 3.456203 #>  #> $info #> [1] 6.622735 #>  #> $info0 #> [1] 7.11092 #>   # Example 1B: WLR test with MB wights x |> wlr(weight = mb(delay = 4, w_max = 2)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"MB(delay = 4, max_weight = 2)\" #>  #> $estimate #> [1] -17.35719 #>  #> $se #> [1] 6.009561 #>  #> $z #> [1] 2.888262 #>  #> $info #> [1] 35.45611 #>  #> $info0 #> [1] 37.12714 #>   # Example 1C: WLR test with early zero wights x |> wlr(weight = early_zero(early_period = 4)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"Xu 2017 with first 4 months of 0 weights\" #>  #> $estimate #> [1] -16.35958 #>  #> $se #> [1] 3.658775 #>  #> $z #> [1] 4.471326 #>  #> $info #> [1] 11.42857 #>  #> $info0 #> [1] 14 #>   # Example 1D # For increased computational speed when running many WLR tests, you can # pre-compute the counting_process() step first, and then pass the result of # counting_process() directly to wlr() x <- x |> counting_process(arm = \"experimental\") x |> wlr(weight = fh(rho = 0, gamma = 1)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=1)\" #>  #> $estimate #> [1] -6.044199 #>  #> $se #> [1] 1.645134 #>  #> $z #> [1] 3.673987 #>  #> $info #> [1] 2.737818 #>  #> $info0 #> [1] 2.918227 #>  x |> wlr(weight = mb(delay = 4, w_max = 2)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"MB(delay = 4, max_weight = 2)\" #>  #> $estimate #> [1] -17.35719 #>  #> $se #> [1] 6.009561 #>  #> $z #> [1] 2.888262 #>  #> $info #> [1] 35.45611 #>  #> $info0 #> [1] 37.12714 #>  x |> wlr(weight = early_zero(early_period = 4)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"Xu 2017 with first 4 months of 0 weights\" #>  #> $estimate #> [1] -16.35958 #>  #> $se #> [1] 3.658775 #>  #> $z #> [1] 4.471326 #>  #> $info #> [1] 11.42857 #>  #> $info0 #> [1] 14 #>   # ---------------------- # #      Example 2         # #  Use cumsum dataset    # # ---------------------- # x <- data.frame(treatment = ifelse(ex1_delayed_effect$trt == 1, \"experimental\", \"control\"),                 stratum = rep(\"All\", nrow(ex1_delayed_effect)),                 tte = ex1_delayed_effect$month,                 event = ex1_delayed_effect$evntd)  # Users can specify the randomization ratio to calculate the statistical information under H0 x |> wlr(weight = fh(rho = 0, gamma = 0.5), ratio = 2) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -12.28665 #>  #> $se #> [1] 3.716574 #>  #> $z #> [1] 3.305908 #>  #> $info #> [1] 16.60727 #>  #> $info0 #> [1] 15.27192 #>   x |>   counting_process(arm = \"experimental\") |>   wlr(weight = fh(rho = 0, gamma = 0.5), ratio = 2) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -12.28665 #>  #> $se #> [1] 3.716574 #>  #> $z #> [1] 3.305908 #>  #> $info #> [1] 16.60727 #>  #> $info0 #> [1] 15.27192 #>   # If users don't provide the randomization ratio, we will calculate the emperical ratio x |> wlr(weight = fh(rho = 0, gamma = 0.5)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -12.28665 #>  #> $se #> [1] 3.716574 #>  #> $z #> [1] 3.305908 #>  #> $info #> [1] 16.60727 #>  #> $info0 #> [1] 15.31399 #>   x |>   counting_process(arm = \"experimental\") |>   wlr(weight = fh(rho = 0, gamma = 0.5)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -12.28665 #>  #> $se #> [1] 3.716574 #>  #> $z #> [1] 3.305908 #>  #> $info #> [1] 16.60727 #>  #> $info0 #> [1] 15.31399 #>   # ---------------------- # #      Example 3         # #  Use formula           # # ---------------------- # library(\"survival\")  # Unstratified design x <- sim_pw_surv(n = 200) |> cut_data_by_event(100) |> as.data.frame() colnames(x) <- c(\"tte\", \"evnt\", \"strtm\", \"trtmnt\") wlr(x, weight = fh(0, 0.5), formula = Surv(tte, evnt) ~ trtmnt) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -8.151712 #>  #> $se #> [1] 2.559737 #>  #> $z #> [1] 3.184589 #>  #> $info #> [1] 6.588311 #>  #> $info0 #> [1] 6.955264 #>   # Stratified design x$strtm <- sample(c(\"s1\", \"s2\"), size = nrow(x), replace = TRUE) wlr(x, weight = fh(0, 0.5), formula = Surv(tte, evnt) ~ trtmnt + strata(strtm)) #> $method #> [1] \"WLR\" #>  #> $parameter #> [1] \"FH(rho=0, gamma=0.5)\" #>  #> $estimate #> [1] -7.446813 #>  #> $se #> [1] 2.571142 #>  #> $z #> [1] 2.896306 #>  #> $info #> [1] 6.562729 #>  #> $info0 #> [1] 6.925405 #>"},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-101","dir":"Changelog","previous_headings":"","what":"simtrial 1.0.1","title":"simtrial 1.0.1","text":"CRAN release: 2025-09-11","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"statistical-improvements-1-0-1","dir":"Changelog","previous_headings":"","what":"Statistical improvements","title":"simtrial 1.0.1","text":"example stratified group sequential design added sim_gs_n() function (#336, #343, thanks @LittleBeannie).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"computational-improvements-1-0-1","dir":"Changelog","previous_headings":"","what":"Computational improvements","title":"simtrial 1.0.1","text":"dplyr syntax sim_gs_n() replaced data.table syntax better speed (#339, thanks @jdblischak). parallelelly package version temporarily downgraded v1.44.0 successful macOC build. (#341, #338, thanks @jdblischak).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-100","dir":"Changelog","previous_headings":"","what":"simtrial 1.0.0","title":"simtrial 1.0.0","text":"CRAN release: 2025-06-11","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"statistical-improvements-1-0-0","dir":"Changelog","previous_headings":"","what":"Statistical improvements","title":"simtrial 1.0.0","text":"Provide updated boundary objects generated sim_gs_n() (#255, thanks @LittleBeannie). Users can now pass formula call wlr() function (#280, thanks @jdblischak). wlr() now S3 class method tte_data class counting_process class (@276, #280, @281, thanks @jdblischak) randomization ratio output attributes sim_pw_surv() (#279, #311 thanks @LittleBeannie @jdblischak).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"documentation-1-0-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"simtrial 1.0.0","text":"Add 3 vignettes introducing simulation fixed group sequential design via single function call sim_fixed_n() sim_gs_n() ground (#302, #316, thanks @LittleBeannie). Add vignette discussing potential discrepancies simtrial survdiff (#308, thanks @larry-leon). Update parallel vignette address data.table multithreading (#319, thanks @jdblischak).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"speed-improvements-1-0-0","dir":"Changelog","previous_headings":"","what":"Speed improvements","title":"simtrial 1.0.0","text":"Optimize parallel simulation speed sim_fixed_n() sim_gs_n() replacing foreach(.combine = \"rbind\") manual data frame combination (#318, thanks @nanxstats).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-042","dir":"Changelog","previous_headings":"","what":"simtrial 0.4.2","title":"simtrial 0.4.2","text":"CRAN release: 2024-11-18","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"statistical-improvements-0-4-2","dir":"Changelog","previous_headings":"","what":"Statistical improvements","title":"simtrial 0.4.2","text":"Summary function sim_gs_n() available (#268, thanks @LittleBeannie). denominator milestone test Z-score corrected (#270, thanks @LittleBeannie). Statistical information added output sim_gs_n() (#273, thanks @LittleBeannie). randomization ratio built attribute sim_pw_surv() passed wlr() test (#281, #285 thanks @LittleBeannie @jdblischak). sign Z-score unified positive numbers (#272, #286, thanks @LittleBeannie @jdblischak).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"computational-improvements-0-4-2","dir":"Changelog","previous_headings":"","what":"Computational improvements","title":"simtrial 0.4.2","text":"source code summary() rewritten tibble data.frame data.table, optimized use little memory possible avoiding making unnecessary temporary copies data frames. results code efficient time memory use. (#289, thanks @jdblischak). sim_fixed_n() function updated allow parallel simulations (#249, #252, #253, #262, thanks @cmansch @jdblischak).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"bug-fixes-0-4-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"simtrial 0.4.2","text":"Fixed bug cut functions parallel (#261, thanks @cmansch).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"coding-improvements-0-4-2","dir":"Changelog","previous_headings":"","what":"Coding improvements","title":"simtrial 0.4.2","text":"wlr() function enhanced S3 generic accept counting process time--event data input (#276, #277, thanks @jdblischak).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"documentation-0-4-2","dir":"Changelog","previous_headings":"","what":"Documentation","title":"simtrial 0.4.2","text":"Use KaTeX pkgdown math rendering (#263, thanks @nanxstats).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"tests-0-4-2","dir":"Changelog","previous_headings":"","what":"Tests","title":"simtrial 0.4.2","text":"Regression tests summary() added (#282, thanks @jdblischak).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-041","dir":"Changelog","previous_headings":"","what":"simtrial 0.4.1","title":"simtrial 0.4.1","text":"CRAN release: 2024-05-03","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"improvements-0-4-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"simtrial 0.4.1","text":"Pass noSuggests checks running code examples, tests, vignettes conditionally Suggests dependencies installed (#243).","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"simtrial 0.4.0","text":"rmst() introduces RMST test (#188, thanks, @LittleBeannie). milestone() introduces milestone test (#199, #204, #211, #237, thanks, @LittleBeannie). sim_gs_n() provides experimental implementation fixed sample size group sequential design simulation, unit tests upcoming (#195, #201, #208, #212, thanks, @LittleBeannie @jdblischak). create_cut() allows users create custom interim final analyses cuttings based specific requirements (#201, #221, thanks, @jdblischak). create_test() enables users create various testing approaches interim final analyses (#215, #221, thanks, @jdblischak). multitest() gives users option perform multiple tests simulated dataset (#215, thanks, @jdblischak). Note: function still experimental may improved future releases, created prior standardization test functions #227. Test outputs (logrank, weighted logrank, RMST, milestone, MaxCombo) now unified list including method, parameter, estimate, se, z-value, p-value (#227, thanks, @LittleBeannie).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"bug-fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"simtrial 0.4.0","text":"Fixed incorrect weights generated early_zero() stratified designs (#233, thanks, @LittleBeannie).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"documentation-0-4-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"simtrial 0.4.0","text":"Enhanced documentation get_analysis_date() (#186, thanks, @LittleBeannie).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"dependency-0-4-0","dir":"Changelog","previous_headings":"","what":"Dependency","title":"simtrial 0.4.0","text":"Removed dependency bshazard package archived CRAN (#234, thanks, @nanxstats).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-032","dir":"Changelog","previous_headings":"","what":"simtrial 0.3.2","title":"simtrial 0.3.2","text":"CRAN release: 2023-12-11 release makes minor improvements auxiliary code side-effects.","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"improvements-0-3-2","dir":"Changelog","previous_headings":"","what":"Improvements","title":"simtrial 0.3.2","text":"Remove code sets options() within vignette(\"modest-wlrt\"). Updated code used generating image assets. scripts now write tempdir() instead package directory.","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-031","dir":"Changelog","previous_headings":"","what":"simtrial 0.3.1","title":"simtrial 0.3.1","text":"release introduces significant changes API, improves simulation performance substantially, adds new features documentation.","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"significant-user-visible-changes-0-3-1","dir":"Changelog","previous_headings":"","what":"Significant user-visible changes","title":"simtrial 0.3.1","text":"Complete overhaul API. Function argument names now use snake case consistency readability. See function reference updated naming scheme. Detailed change history available merged pull requests (thanks, @LittleBeannie, @lili-ling-msd, @XintongLi2023). Dataset names updated snake case (thanks, @nanxstats, #164). base pipe operator now used throughout package. magrittr pipe longer re-exported (thanks, @nanxstats, #146).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"improvements-0-3-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"simtrial 0.3.1","text":"Rewritten table backend simtrial functions using data.table, achieving 3x 5x speedup compared previous implementation (thanks, @jdblischak, #111). sim_fixed_n() now utilizes %dofuture% operator parallelization, enhancing flexibility reproducibility (thanks, @cmansch, #110). rpwexp() adopts inverse CDF method random number generation, naive methods now internal functions (thanks, @jianxiaoyang, #15 #174). sim_fixed_n() optimized skip Breslow’s method absence ties (thanks, @jdblischak, #130). internal function computing Z statistics Fleming-Harrington weighted logrank tests now named wlr_z_stat() (thanks, @elong0527, #105).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"new-features-0-3-1","dir":"Changelog","previous_headings":"","what":"New features","title":"simtrial 0.3.1","text":"early_zero_weight() added weighting function early data removal (thanks, @LittleBeannie, #123). get_analysis_date() added calculate interim/final analysis dates various conditions (thanks, @LittleBeannie, #122).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"documentation-0-3-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"simtrial 0.3.1","text":"New vignette(\"workflow\") providing overview data manipulations involved TTE simulations (thanks, @keaven, #99). New vignette(\"parallel\") demonstrating parallelization workflow coding best practices (thanks, @cmansch, #113 #134).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"miscellaneous-0-3-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"simtrial 0.3.1","text":"Added hex sticker logo generative art design package (thanks, @keaven, #158).","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-022","dir":"Changelog","previous_headings":"","what":"simtrial 0.2.2","title":"simtrial 0.2.2","text":"GitHub release February 2023. version enables parallel computation simfix().","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-021","dir":"Changelog","previous_headings":"","what":"simtrial 0.2.1","title":"simtrial 0.2.1","text":"GitHub release May 2022. version supports Biometrical Journal paper “unified framework weighted parametric group sequential design (WPGSD)” Keaven M. Anderson, Zifang Guo, Jing Zhao, Linda Z. Sun.","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-020","dir":"Changelog","previous_headings":"","what":"simtrial 0.2.0","title":"simtrial 0.2.0","text":"Internal development release August 2020. Updated vignettes website. Prepared Regulatory/Industry training session September.","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-0179004","dir":"Changelog","previous_headings":"","what":"simtrial 0.1.7.9004","title":"simtrial 0.1.7.9004","text":"Internal development release February 2020. Added wMB() compute Magirr-Burman weights. Added vignette demonstrate working different weighting schemes. Replaced Depends Imports DESCRIPTION.","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-0179003","dir":"Changelog","previous_headings":"","what":"simtrial 0.1.7.9003","title":"simtrial 0.1.7.9003","text":"Internal development release November 2019. Incorporated new functions simplify use (simfix(), simfix2simPWSurv(), pMaxCombo()). Removed hgraph() intent put release gsDesign. Limited 2 essential vignettes. Added continuous integration/continuous deployment (YAML) pkgdown website generation. Limited dependencies essential; removed convenience functions related core package functionality.","code":""}]
