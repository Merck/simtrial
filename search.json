[{"path":"https://merck.github.io/simtrial/articles/modestWLRTVignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using the Magirr-Burman weights for testing","text":"Magirr Burman (2019) implemented modestly weighted logrank test following claim: Tests new class can constructed high power delayed-onset treatment effect scenario, well almost efficient standard logrank test proportional hazards. implemented package modestWLRT. Since implementation relatively straightforward, added functionality simtrial package explain use wMB() function. consider two examples: single stratum example compare results modestWLRT package. stratified example implemented modestWLRT. Packages used follows:","code":"library(simtrial) library(dplyr) library(survival)"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/modestWLRTVignette.html","id":"magirr-and-burman-delayed-effect-example","dir":"Articles","previous_headings":"Single stratum examples","what":"Magirr and Burman delayed effect example","title":"Using the Magirr-Burman weights for testing","text":"First, specify study duration, sample size enrollment rates. enrollment rate assumed constant enrollment period targeted sample size reached. failure rates, consider delayed treatment effect example Magirr Burman (2019). control group exponential failure rate median 15 months. initial 6 months, underlying hazard ratio one followed hazard ratio 0.7 thereafter. differs Magirr Burman (2019) delayed effect assumptions assume hazard ratio 0.5 6 months. Now generate single dataset characteristics cut data analysis 36 months post start enrollment. plot Kaplan-Meier curves resulting dataset (red curve experimental treatment, black control):  perform logrank weighted logrank tests follows: Now MaxCombo test compoenent tests, p-value Next, consider Magirr Burman (2019) modestly weighted logrank test -weighting specifid first 6 months. requires generating weights computing test. Finally, consider weighted logrank tests less -weighting. Results quite similar results greater -weighting. Check vs tenFH(). Now MaxCombo test compoenent tests, p-value ","code":"studyDuration <- 36 sampleSize <- 200 enrollRates <- tibble::tibble(duration = 12, rate = 200 / 12) failRates <- tibble::tribble(   ~Stratum, ~duration, ~failRate, ~hr, ~dropoutRate,   \"All\", 6, log(2) / 15, 1, 0,   \"All\", 36, log(2) / 15, .7, 0 ) set.seed(7783) xpar <- simfix2simPWSurv(failRates) MBdelay <- simPWSurv(   n = sampleSize,   strata = tibble::tibble(Stratum = \"All\", p = 1),   block = c(rep(\"Control\", 2), rep(\"Experimental\", 2)),   enrollRates = enrollRates,   failRates = xpar$failRates,   dropoutRates = xpar$dropoutRates ) %>%   cutData(studyDuration) fit <- survfit(Surv(tte, event) ~ Treatment, data = MBdelay) plot(fit, col = 1:2, mark = \"|\", xaxt = \"n\") axis(1, xaxp = c(0, 36, 6)) xx <- MBdelay %>%   tensurv(txval = \"Experimental\") %>%   tenFHcorr(rg = tibble(rho = c(0, 0, 1), gamma = c(0, 1, 1))) %>%   mutate(p = pnorm(Z)) xx #>   rho gamma          Z        V1        V2        V3 #> 1   0     0 -0.8626673 1.0000000 0.8630152 0.9254035 #> 2   0     1 -1.4086898 0.8630152 1.0000000 0.9731757 #> 3   1     1 -1.1451643 0.9254035 0.9731757 1.0000000 #>            p #> 1 0.19416020 #> 2 0.07946346 #> 3 0.12607055 xx %>% pMaxCombo() #> [1] 0.1142327 ZMB <- MBdelay %>%   tensurv(txval = \"Experimental\") %>%   wMB(6) %>%   summarize(S = sum(OminusE * wMB), V = sum(Var * wMB^2), Z = S / sqrt(V)) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$Z) #> [1] 0.1802602 xx <- MBdelay %>%   tensurv(txval = \"Experimental\") %>%   tenFHcorr(rg = tibble(rho = c(0, 0, .5), gamma = c(0, .5, .5))) %>%   mutate(p = pnorm(Z)) xx #>   rho gamma          Z        V1        V2        V3 #> 1 0.0   0.0 -0.8626673 1.0000000 0.9403634 0.9654105 #> 2 0.0   0.5 -1.2587243 0.9403634 1.0000000 0.9918447 #> 3 0.5   0.5 -1.1104867 0.9654105 0.9918447 1.0000000 #>           p #> 1 0.1941602 #> 2 0.1040650 #> 3 0.1333947 xx <- MBdelay %>%   tensurv(txval = \"Experimental\") %>%   tenFH(rg = tibble(rho = c(0, 0, .5), gamma = c(0, .5, .5))) xx #> # A tibble: 3 × 3 #>     rho gamma      Z #>   <dbl> <dbl>  <dbl> #> 1   0     0   -0.863 #> 2   0     0.5 -1.26  #> 3   0.5   0.5 -1.11 xx <- MBdelay %>%   tensurv(txval = \"Experimental\") %>%   tenFHcorr(rg = tibble(rho = c(0, 0, .5, .5), gamma = c(0, .5, .5, 0))) %>%   mutate(p = pnorm(Z)) xx #>   rho gamma          Z        V1        V2        V3 #> 1 0.0   0.0 -0.8626673 1.0000000 0.9403634 0.9654105 #> 2 0.0   0.5 -1.2587243 0.9403634 1.0000000 0.9918447 #> 3 0.5   0.5 -1.1104867 0.9654105 0.9918447 1.0000000 #> 4 0.5   0.0 -0.6681079 0.9907477 0.8871792 0.9272057 #>          V4         p #> 1 0.9907477 0.1941602 #> 2 0.8871792 0.1040650 #> 3 0.9272057 0.1333947 #> 4 1.0000000 0.2520324 xx %>% pMaxCombo() #> [1] 0.1404057"},{"path":"https://merck.github.io/simtrial/articles/modestWLRTVignette.html","id":"freidlin-and-korn-strong-null-hypothesis-example","dir":"Articles","previous_headings":"Single stratum examples","what":"Freidlin and Korn strong null hypothesis example","title":"Using the Magirr-Burman weights for testing","text":"underlying survival worse experimental group uniformly worse experimental group end study. presented Freidlin Korn (2019). case, hazard ratio 16 1/10 1 year (1.2 months), followed hazard ratio First, specify study duration, sample size enrollment rates. enrollment rate assumed constant enrollment period targeted sample size reached. failure rates, consider delayed treatment effect example Magirr Burman (2019). control group exponential failure rate median 15 months. initial 6 months, underlying hazard ratio one followed hazard ratio 0.7 thereafter. differs Magirr Burman (2019) delayed effect assumptions assume hazard ratio 0.5 6 months. Now generate single dataset characteristics cut data analysis 36 months post start enrollment. plot Kaplan-Meier curves resulting dataset (red curve experimental treatment, black control):  perform logrank weighted logrank tests follows: Now MaxCombo test compoenent tests, p-value Next, consider Magirr Burman (2019) modestly weighted logrank test -weighting specifid first 6 months. requires generating weights computing test. Finally, consider weighted logrank tests less -weighting. Results quite similar results greater -weighting. Now MaxCombo test compoenent tests, p-value ","code":"studyDuration <- 5 sampleSize <- 2000 enrollDuration <- .0001 enrollRates <- tibble::tibble(duration = enrollDuration, rate = sampleSize / enrollDuration) failRates <- tibble::tibble(   Stratum = \"All\",   failRate = 0.25,   dropoutRate = 0,   hr = c(4 / .25, .19 / .25),   duration = c(.1, 4.9) ) set.seed(7783) xpar <- simfix2simPWSurv(failRates) FHwn <- simPWSurv(   n = sampleSize,   strata = tibble::tibble(Stratum = \"All\", p = 1),   block = c(rep(\"Control\", 2), rep(\"Experimental\", 2)),   enrollRates = enrollRates,   failRates = xpar$failRates,   dropoutRates = xpar$dropoutRates ) %>%   cutData(studyDuration) fit <- survfit(Surv(tte, event) ~ Treatment, data = FHwn) plot(fit, col = 1:2, mark = \"|\", xaxt = \"n\") axis(1, xaxp = c(0, 36, 6)) xx <- FHwn %>%   tensurv(txval = \"Experimental\") %>%   tenFHcorr(rg = tibble(rho = c(0, 0, 1), gamma = c(0, 1, 1))) %>%   mutate(p = pnorm(Z)) xx #>   rho gamma         Z        V1        V2        V3 #> 1   0     0  4.808526 1.0000000 0.8652115 0.9356769 #> 2   0     1 -3.204735 0.8652115 1.0000000 0.9580098 #> 3   1     1 -1.220445 0.9356769 0.9580098 1.0000000 #>              p #> 1 0.9999992398 #> 2 0.0006759349 #> 3 0.1111481087 xx %>% pMaxCombo() #> [1] 0.001256683 ZMB <- FHwn %>%   tensurv(txval = \"Experimental\") %>%   wMB(6) %>%   summarize(S = sum(OminusE * wMB), V = sum(Var * wMB^2), Z = S / sqrt(V)) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$Z) #> [1] 0.6189718 xx <- FHwn %>%   tensurv(txval = \"Experimental\") %>%   tenFHcorr(rg = tibble(rho = c(0, 0, .5), gamma = c(0, .5, .5))) %>%   mutate(p = pnorm(Z)) xx #>   rho gamma          Z        V1        V2        V3 #> 1 0.0   0.0  4.8085258 1.0000000 0.9421013 0.9709414 #> 2 0.0   0.5 -0.6919228 0.9421013 1.0000000 0.9872682 #> 3 0.5   0.5  0.9278452 0.9709414 0.9872682 1.0000000 #>           p #> 1 0.9999992 #> 2 0.2444929 #> 3 0.8232561 xx %>% pMaxCombo() #> [1] 0.2915952"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/pMaxComboVignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Computing p-values for Fleming-Harring weighted logrank tests and the MaxCombo test","text":"vignette demonstrates use simple routine simulations testing using Fleming-Harrington weighted logrank tests MaxCombo test. addition, demonstrate perform tests dataset generated simulation routines within package. Note p-values computed one-sided small values indicating experimental treatment favored.","code":""},{"path":"https://merck.github.io/simtrial/articles/pMaxComboVignette.html","id":"defining-the-test","dir":"Articles","previous_headings":"","what":"Defining the test","title":"Computing p-values for Fleming-Harring weighted logrank tests and the MaxCombo test","text":"MaxCombo test posed maximum multiple Fleming-Harrington weighted logrank tests (Harrington Fleming (1982), Fleming Harrington (2011)). Combination tests looking maximum selected tests class also proposed; see Lee (2007), Roychoudhury et al. (2019), Lin et al. (2019). Fleming-Harrington class indexed parameters \\(\\rho\\ge 0\\) \\(\\gamma\\ge 0\\). denote FH(\\(\\rho,\\gamma\\)). class includes logrank test FH(0,0). tests interest include: FH(0,1): test -weights early events FH(1,0): test -weights late events FH(1,1): test -weights events increasingly quantiles differ median","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/pMaxComboVignette.html","id":"generating-test-statistics-with-simfix","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Generating test statistics with simfix()","title":"Computing p-values for Fleming-Harring weighted logrank tests and the MaxCombo test","text":"begin single trial simulation generated routine simfix() using default arguments routine. simfix() produces one record per test data cutoff method per simulation. choose 3 tests (logrank=FH(0,0), FH(0,1) FH(1,1)). one test chosen correlation tests computed shown Karrison (2016), case columns V1, V2, V3. columns rho, gamma indicate \\(\\rho\\) \\(\\gamma\\) used compute test. Z FH(\\(\\rho,\\gamma\\)) normal test statistic variance 1 negative value favoring experimental treatment. variable cut indicates data cut analysis, case maximum targeted minimum follow-last enrollment date targeted event count reached. Sim sequential index simulations performed. format, MaxCombo p-value per Karrison (2016), Roychoudhury et al. (2019) can computed follows (note need package mvtnorm installed):","code":"library(simtrial) library(knitr) library(dplyr) x <- simfix(nsim = 1, timingType = 5, rg = tibble::tibble(rho = c(0, 0, 1), gamma = c(0, 1, 1))) #> Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. #> Using compatibility `.name_repair`. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. x %>% kable(digits = 2) pMaxCombo(x) #> [1] 4.673241e-07"},{"path":"https://merck.github.io/simtrial/articles/pMaxComboVignette.html","id":"generating-data-with-simtrialsimpwsurv","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Generating data with simtrial::simPWSurv()","title":"Computing p-values for Fleming-Harring weighted logrank tests and the MaxCombo test","text":"begin another simulation generated simtrial::simPWSurv(). , use defaults routine. generated, need cut data analysis. cut 75 events. Now can analyze data. begin s show can done single line. case, use 4 test combination suggested Lin et al. (2019), Roychoudhury et al. (2019). Now compute p-value : Suppose want p-value just based logrank FH(0,1) FH(1,0) suggested Lee (2007). remove rows columns associated FH(0,0) FH(1,1) apply pMaxCombo().","code":"s <- simPWSurv(n = 100) head(s) %>% kable(digits = 2) x <- s %>% cutDataAtCount(75) head(x) %>% kable(digits = 2) Z <- s %>%   cutDataAtCount(75) %>%   tensurv(txval = \"Experimental\") %>%   tenFHcorr(rg = tibble(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1))) Z %>% kable(digits = 2) pMaxCombo(Z) #> [1] 0.07016387 pMaxCombo(Z %>% select(-c(V1, V4)) %>% filter((rho == 0 & gamma == 1) | (rho == 1 & gamma == 0))) #> [1] 0.06411663"},{"path":"https://merck.github.io/simtrial/articles/pMaxComboVignette.html","id":"using-survival-data-in-another-format","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Using survival data in another format","title":"Computing p-values for Fleming-Harring weighted logrank tests and the MaxCombo test","text":"trial generated simfix(), process slightly involved. consider survival data simtrial format show transformation needed. case use small aml dataset survival package. rename variables create stratum variable follows: Now analyze data MaxCombo logrank FH(0,1) compute p-value.","code":"library(survival) head(aml) %>% kable() x <- aml %>% transmute(tte = time, event = status, Stratum = \"All\", Treatment = as.character(x)) head(x) %>% kable() x %>%   tensurv(txval = \"Maintained\") %>%   tenFHcorr(rg = tibble(rho = 0, gamma = c(0, 1))) %>%   pMaxCombo() #> [1] 0.0491509"},{"path":"https://merck.github.io/simtrial/articles/pMaxComboVignette.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Computing p-values for Fleming-Harring weighted logrank tests and the MaxCombo test","text":"now consider example simulation pMaxCombo() help file demonstrate simulate power MaxCombo test. However, increase number simulations 100 case; larger number used (e.g., 1000) better estimate design properties. test \\(\\alpha=0.001\\) level. note use group_map produces list p-values simulation. nice something worked like dplyr::summarize() avoid unlist() allow evaluating, say, multiple data cutoff methods. latter can done without re-run simulations follows, demonstrated smaller number simulations. Now compute p-value separately cut type, first targeted event count. Now use later targeted events minimum follow-cutoffs.","code":"# Only use cut events + min follow-up xx <- simfix(nsim = 100, timingType = 5, rg = tibble(rho = c(0, 0, 1), gamma = c(0, 1, 1))) # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up p <- unlist(xx %>% group_by(Sim) %>% group_map(pMaxCombo)) mean(p < .001) #> [1] 0.8 # Only use cuts for events and events + min follow-up xx <- simfix(nsim = 100, timingType = c(2, 5), rg = tibble(rho = 0, gamma = c(0, 1))) head(xx) %>% kable(digits = 2) # Subset to targeted events cutoff tests p <- unlist(xx %>% filter(cut == \"Targeted events\") %>% group_by(Sim) %>% group_map(pMaxCombo)) mean(p < .025) #> [1] 0.94 # Subset to targeted events cutoff tests p <- unlist(xx %>% filter(cut != \"Targeted events\") %>% group_by(Sim) %>% group_map(pMaxCombo)) mean(p < .025) #> [1] 0.93"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Basic tools for time-to-event trial simulation and testing","text":"vignette demonstrates lower-level routines simtrial package specifically related trial generation statistical testing. routines follows: fixedBlockRand - fixed block randomization rpwenroll - random inter-arrival times piecewise constant enrollment rates rpwexp - piecewise exponential failure rate generation cutData - cut data analysis specified calendar time cutDataAtCount - cut data analysis specified event count, including ties cutoff date getCutDateForCount - find date event count reached tensurv - pre-process survival data counting process format Application demonstrated using higher-level routines simPWSurv() simfix() generate simulations weighted logrank analysis stratified design. intent write routines spirit tidyverse approach (alternately referred data wrangling, tidy data, R Data Science, split-apply-combine). objectives easily documentable validated package easy use efficient broadly-useful tool simulation time--event clinical trials. package extended many ways future, including: Weighted logrank weighted Kaplan-Meier analyses One-step, hazard ratio estimator (first-order approximation PH) Randomization schemes stratified, fixed-block Poisson mixture survival distribution generation","code":"library(simtrial) library(knitr) library(tibble) library(dplyr)"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"randomization","dir":"Articles","previous_headings":"","what":"Randomization","title":"Basic tools for time-to-event trial simulation and testing","text":"Fixed block randomization arbitrary block contents performed demonstrated . case block size 5 one string repeated twice block three strings appearing . normally, default blocks size four:","code":"fixedBlockRand(n = 10, block = c(\"A\", \"Dog\", \"Cat\", \"Cat\")) #>  [1] \"Dog\" \"A\"   \"Cat\" \"Cat\" \"Cat\" \"Dog\" \"A\"   \"Cat\" \"A\"   \"Cat\" fixedBlockRand(n = 20) #>  [1] 1 0 1 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"enrollment","dir":"Articles","previous_headings":"","what":"Enrollment","title":"Basic tools for time-to-event trial simulation and testing","text":"Piecewise constant enrollment can randomly generated follows. Note duration specifies interval durations constant rates; final rate extended long needed generate specified number observations.","code":"rpwenroll(n = 20, enrollRates = tibble(   duration = c(1, 2),   rate = c(2, 5) )) #>  [1] 0.1593017 0.6342606 1.4151218 1.4259828 1.5907695 1.6315804 1.7345880 #>  [8] 1.8014941 2.2188548 2.2697770 3.2104772 3.4778307 3.5674335 3.6605239 #> [15] 3.8143586 4.0507451 4.1146122 4.6374154 4.7821577 5.3792406"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"time-to-event-and-time-to-dropout","dir":"Articles","previous_headings":"","what":"Time-to-event and time-to-dropout","title":"Basic tools for time-to-event trial simulation and testing","text":"Time--event time--dropout random number generation observations generated piecewise exponential failure times. large number observations, log-plot time--failure","code":"x <- rpwexp(10000,   failRates = tibble(     rate = c(1, 3, 10),     duration = c(.5, .5, 1)   ) ) plot(sort(x), (10000:1) / 10001,   log = \"y\",   main = \"PW Exponential simulated survival curve\",   xlab = \"Time\", ylab = \"P{Survival}\" )"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"generating-a-trial","dir":"Articles","previous_headings":"","what":"Generating a trial","title":"Basic tools for time-to-event trial simulation and testing","text":"Ideally, might done routine generation randomization, time--event data done modular fashion plugged general trial generation routine. now, stratified randomization, piecewise constant enrollment, fixed block randomization piecewise exponential failure rates support flexible set trial generation options time--event endpoint trials. present, follow format carefully little checking input developed -date. methods used demonstrated , combined single routine generate trial. Note generated output dataset, cte calendar time event dropout, whichever comes first, fail indicator cte represents event time. First set input variables make later call simPWSurv() straightforward read.","code":"strata <- tibble(Stratum = c(\"Negative\", \"Positive\"), p = c(.5, .5))  block <- c(rep(\"Control\", 2), rep(\"Experimental\", 2))  enrollRates <- tibble(rate = c(3, 6, 9), duration = c(3, 2, 1))  failRates <- tibble(   Stratum = c(rep(\"Negative\", 4), rep(\"Positive\", 4)),   period = rep(1:2, 4),   Treatment = rep(c(rep(\"Control\", 2), rep(\"Experimental\", 2)), 2),   duration = rep(c(3, 1), 4),   rate = log(2) / c(4, 9, 4.5, 10, 4, 9, 8, 18) ) dropoutRates <- tibble(   Stratum = c(rep(\"Negative\", 4), rep(\"Positive\", 4)),   period = rep(1:2, 4),   Treatment = rep(c(rep(\"Control\", 2), rep(\"Experimental\", 2)), 2),   duration = rep(c(3, 1), 4),   rate = rep(c(.001, .001), 4) ) x <- simPWSurv(   n = 400,   strata = strata,   block = block,   enrollRates = enrollRates,   failRates = failRates,   dropoutRates = dropoutRates ) head(x) %>% kable(digits = 2)"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"cutting-data-for-analysis","dir":"Articles","previous_headings":"","what":"Cutting data for analysis","title":"Basic tools for time-to-event trial simulation and testing","text":"two ways cut data generated dataset x . first uses calendar cutoff date. output includes time randomization event dropout (tte), indicator represents event (event), stratum observation generated (Stratum) treatment group assigned (Treatment). Observations enrolled input cutDate deleted events censoring x cutDate censored specified cutDate. instance, wish cut entire dataset 50 events observed Positive stratum can use getCutDateForCount function follows: Perhaps common way cut data event count overall population, done using cutDataAtCount function. Note tied events date cte count reached, included. Also, count never reached, event times included cut - indication error.","code":"y <- cutData(x, cutDate = 5) head(y) %>% kable(digits = 2) cut50Positive <- getCutDateForCount(filter(x, Stratum == \"Positive\"), 50) y50Positive <- cutData(x, cut50Positive) with(y50Positive, table(Stratum, event)) #>           event #> Stratum     0  1 #>   Negative 58 66 #>   Positive 43 50 y150 <- cutDataAtCount(x, 150) table(y150$event, y150$Treatment) #>     #>     Control Experimental #>   0      49           49 #>   1      75           75"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"generating-a-counting-process-dataset","dir":"Articles","previous_headings":"","what":"Generating a counting process dataset","title":"Basic tools for time-to-event trial simulation and testing","text":"cut data analysis, can create dataset simple use weighted logrank tests. slightly complex version developed future enable Kaplan-Meier-based tests. take dataset y150 process format. counting process format discussed next section compute weighted logrank test.","code":"ten150 <- tensurv(y150, txval = \"Experimental\") head(ten150) %>% kable(digits = 2)"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"logrank-and-weighted-logrank-testing","dir":"Articles","previous_headings":"","what":"Logrank and weighted logrank testing","title":"Basic tools for time-to-event trial simulation and testing","text":"Now stratified logrank stratified weighted logrank tests easily generated based counting process format. record counting process dataset represents tte one events occurs; results stratum-specific. Included observation number events overall (events) experimental treatment group (txevents), number risk overall (atrisk) experimental treatment group (txatrisk) just tte, combined treatment group Kaplan-Meier survival estimate (left-continuous) tte, observed events experimental group minus expected tte based assumption risk observations equally likely event time, variance quantity (Var). generate stratified logrank test corresponding one-sided p-value, simply following: Fleming-Harrington \\(\\rho=1\\), \\(\\gamma=2\\) nearly simple. compute z-statistic corresponding one-sided p-value. Fleming-Harrington tests, routine built tests : wanted take minimum MaxCombo test, first use tenFHcorr compute correlation matrix Z-statistics follows. Note ordering rg g argument list opposite . correlation matrix Z-values now V1-V4. can compute p-value MaxCombo follows using pmvnorm function mvtnorm package. Note arguments GenzBretz stringent defaults; also used stringent parameters example help file.","code":"z <- with(ten150, sum(OminusE) / sqrt(sum(Var))) c(z, pnorm(z)) #> [1] -0.1810390  0.4281685 xx <- mutate(ten150, w = S * (1 - S)^2) z <- with(xx, sum(OminusE * w) / sum(sqrt(Var * w^2))) c(z, pnorm(z)) #> [1] -0.02994472  0.48805557 tenFH(x = ten150, rg = tibble(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1))) %>% kable(digits = 2) x <- ten150 %>% tenFHcorr(rg = tibble(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1))) #> Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. #> Using compatibility `.name_repair`. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. x %>% kable(digits = 2) # Compute p-value for MaxCombo pMaxCombo(x) #> [1] 0.4778071"},{"path":"https://merck.github.io/simtrial/articles/simtrialroutines.html","id":"simplification-for-2-arm-trials","dir":"Articles","previous_headings":"","what":"Simplification for 2-arm trials","title":"Basic tools for time-to-event trial simulation and testing","text":"simfix() routine combines much go straight generating tests individual trials cutting data analyzing need done separately. argument structure meant simpler simPWSurv(). Now simulate trial 2 times cut data analysis based timingType = 1:5 translates : planned study duration, targeted event count achieved, planned minimum follow-enrollment complete, maximum 1 2, maximum 2 3. look carefully, asking cutoff planned number events different data cutoff methods. explain, note generally want sampleSize match enrollment specified enrollRates: targeted enrollment takes, average, 30 months longer sum enrollment durations enrollRates (14 months) input enrollment rates. achieve input sampleSize 500, final enrollment rate assumed steady state extends simulation targeted enrollment achieved. planned duration trial taken 30 months specified totalDuration. targeted minimum follow-thus, implicit last subject enrolled 16 months prior duration given cutoff “Minimum follow-” cutoff simulations . planned duration cutoff given totalDuration argument results much earlier cutoff.","code":"strata <- tibble(Stratum = \"All\", p = 1) enrollRates <- tibble(   duration = c(2, 2, 10),   rate = c(3, 6, 9) ) failRates <- tibble(   Stratum = \"All\",   duration = c(3, 100),   failRate = log(2) / c(9, 18),   hr = c(0.9, 0.6),   dropoutRate = rep(0.001, 2) ) block <- rep(c(\"Experimental\", \"Control\"), 2) rg <- tibble(rho = 0, gamma = 0) simfix(   nsim = 2, # Number of simulations   sampleSize = 500, # Trial sample size   targetEvents = 350, # Targeted events at analysis   strata = strata, # Study strata   enrollRates = enrollRates, # Enrollment rates   failRates = failRates, # Failure rates   totalDuration = 30, # Planned trial duration   block = block, # Block for treatment   timingType = 1:5, # Use all possible data cutoff methods   rg = rg # FH test(s) to use; in this case, logrank ) %>% kable(digits = 2) enrollRates %>% summarize(\"Targeted enrollment based on input enrollment rates\" = sum(duration * rate)) #> # A tibble: 1 × 1 #>   `Targeted enrollment based on input enrollment rates` #>                                                   <dbl> #> 1                                                   108 totalDuration <- 30 # From above totalDuration - sum(enrollRates$duration) #> [1] 16"},{"path":"https://merck.github.io/simtrial/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Keaven Anderson. Author. Yilong Zhang. Author, maintainer. Amin Shirazi. Contributor. Ruixue Wang. Contributor. Yi Cui. Contributor. Ping Yang. Contributor. Yalin Zhu. Contributor. Heng Zhou. Contributor. Merck & Co., Inc., Rahway, NJ, USA affiliates. Copyright holder.","code":""},{"path":"https://merck.github.io/simtrial/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson K, Zhang Y (2022). simtrial: Clinical Trial Simulation. https://merck.github.io/simtrial/, https://github.com/Merck/simtrial.","code":"@Manual{,   title = {simtrial: Clinical Trial Simulation},   author = {Keaven Anderson and Yilong Zhang},   year = {2022},   note = {https://merck.github.io/simtrial/, https://github.com/Merck/simtrial}, }"},{"path":[]},{"path":"https://merck.github.io/simtrial/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Clinical Trial Simulation","text":"can install GitHub:","code":"remotes::install_github(\"Merck/simtrial\")"},{"path":"https://merck.github.io/simtrial/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Clinical Trial Simulation","text":"simtrial small package built initially focus evaluating weighted logrank tests combination tests based tests. intent use tidyverse (data wrangling) programming procedures package easy qualify use regulated environment. Initial areas focus : Generating time--event data stratified trials using piecewise constant enrollment piecewise exponential failure rates. proportional non-proportional hazards supported. proportional hazards, assumptions along lines used Lachin Foulkes implemented gsDesign deriving group sequential designs. Setting data cutoffs (interim final) analyses. Support weighted logrank tests arbitrary weighting schemes, specifically supporting Fleming-Harrington set tests, including logrank test.","code":""},{"path":"https://merck.github.io/simtrial/index.html","id":"future-developments","dir":"","previous_headings":"","what":"Future developments","title":"Clinical Trial Simulation","text":"Expectations future development include: Provide test suite document package fit use regulatory environment. examples.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"","code":"data(Ex1delayedEffect)"},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"Data frame 4 variables: id sequential numbering unique identifiers month time--event event 1 event, 0 censored trt 1 experimental, 0 control","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"TBD","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"","code":"library(survival) data(Ex1delayedEffect) km1 <- with(Ex1delayedEffect,survfit(Surv(month,evntd)~trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 121     86   5.04    4.18    6.21 #> trt=1 240    132   7.66    6.54    9.48 plot(km1)  with(subset(Ex1delayedEffect,trt==1),survfit(Surv(month,evntd)~trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 240    132   7.66    6.54    9.48 with(subset(Ex1delayedEffect,trt==0),survfit(Surv(month,evntd)~trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 121     86   5.04    4.18    6.21"},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"","code":"data(Ex2delayedEffect)"},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"Data frame 4 variables: id sequential numbering unique identifiers month time--event event 1 event, 0 censored trt 1 experimental, 0 control","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"TBD","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"","code":"library(survival) data(Ex2delayedEffect) km1 <- with(Ex2delayedEffect,survfit(Surv(month,evntd)~trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 137    123   2.84    2.18    3.50 #> trt=1 135    105   3.45    2.13    5.07 plot(km1)  with(subset(Ex2delayedEffect,trt==1),survfit(Surv(month,evntd)~trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 135    105   3.45    2.13    5.07 with(subset(Ex2delayedEffect,trt==0),survfit(Surv(month,evntd)~trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 137    123   2.84    2.18     3.5"},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"","code":"data(Ex3curewithph)"},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"Data frame 4 variables: id sequential numbering unique identifiers month time--event event 1 event, 0 censored trt 1 experimental, 0 control","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"TBD","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"","code":"library(survival) data(Ex3curewithph) km1 <- with(Ex3curewithph,survfit(Surv(month,evntd)~trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 137    101   1.05   0.523    1.74 #> trt=1 143     86   1.74   1.158    3.13 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"","code":"data(Ex4belly)"},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"Data frame 4 variables: id sequential numbering unique identifiers month time--event event 1 event, 0 censored trt 1 experimental, 0 control","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"TBD","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"","code":"library(survival) data(Ex4belly) km1 <- with(Ex4belly,survfit(Surv(month,evntd)~trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 387    339   5.40    4.61    5.55 #> trt=1 387    327   6.42    5.81    6.91 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"","code":"data(Ex5widening)"},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"Data frame 4 variables: id sequential numbering unique identifiers month time--event event 1 event, 0 censored trt 1 experimental, 0 control","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"TBD","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"","code":"library(survival) data(Ex5widening) km1 <- with(Ex5widening,survfit(Surv(month,evntd)~trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> trt=0 79     65   8.16    6.65    10.3 #> trt=1 86     48  19.97   17.07    26.6 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"","code":"data(Ex6crossing)"},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"Data frame 4 variables: id sequential numbering unique identifiers month time--event event 1 event, 0 censored trt 1 experimental, 0 control","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"TBD","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"","code":"library(survival) data(Ex6crossing) km1 <- with(Ex6crossing,survfit(Surv(month,evntd)~trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 145    111  10.66    8.83    12.5 #> trt=1 145    113   9.92    7.38    14.3 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated survival dataset with delayed treatment effect — MBdelayed","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"Magirr Burman (2019) considered several scenarios modestly weighted logrank test. One delayed treatment effect hazard ratio 1 6 months followed hazard ratio 1/2 thereafter. scenario enrolled 200 patients uniformly 12 months cut data analysis 36 months enrollment opened. dataset generated simtrial::simPWSurv() function scenario.","code":""},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"","code":"MBdelayed"},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"tibble 200 rows xx columns tte time event","code":""},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"Magirr, Dominic, Carl‐Fredrik Burman. \"Modestly weighted logrank tests.\" Statistics Medicine 38.20 (2019): 3782-3790.","code":""},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"","code":"library(tidyr) library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(survival) library(mvtnorm) fit <- survfit(Surv(tte, event) ~ Treatment, data = MBdelayed)  # Plot survival plot(fit, lty=1:2)  legend(\"topright\", legend = c(\"Control\", \"Experimental\"), lty = 1:2)   # Set up time, event, number of event dataset for testing # with arbitrary weights ten <- MBdelayed %>% tensurv(txval = \"Experimental\") head(ten) #> # A tibble: 6 × 9 #> # Groups:   Stratum [1] #>   Stratum events txevents    tte atrisk txatrisk     S OminusE   Var #>   <chr>    <dbl>    <dbl>  <dbl>  <dbl>    <int> <dbl>   <dbl> <dbl> #> 1 All          1        1 0.0917    200      100 1       0.5   0.25  #> 2 All          1        1 0.181     199       99 0.995   0.503 0.250 #> 3 All          1        1 0.322     198       98 0.99    0.505 0.250 #> 4 All          1        0 0.330     197       97 0.985  -0.492 0.250 #> 5 All          1        0 0.597     196       97 0.98   -0.495 0.250 #> 6 All          1        0 0.755     195       97 0.975  -0.497 0.250  # MaxCombo with logrank, FH(0,1), FH(1,1) ten %>% tenFHcorr(rg=tibble(rho=c(0, 0, 1), gamma=c(0, 1, 1))) %>%         pMaxCombo() #> Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. #> Using compatibility `.name_repair`. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. #> [1] 0.0009947884  # Magirr-Burman modestly down-weighted rank test with 6 month delay # First, add weights ten <- ten %>% wMB(6) head(ten) #> # A tibble: 6 × 10 #>   Stratum events txevents    tte atrisk txatrisk     S OminusE   Var   wMB #>   <chr>    <dbl>    <dbl>  <dbl>  <dbl>    <int> <dbl>   <dbl> <dbl> <dbl> #> 1 All          1        1 0.0917    200      100 1       0.5   0.25   1    #> 2 All          1        1 0.181     199       99 0.995   0.503 0.250  1.01 #> 3 All          1        1 0.322     198       98 0.99    0.505 0.250  1.01 #> 4 All          1        0 0.330     197       97 0.985  -0.492 0.250  1.02 #> 5 All          1        0 0.597     196       97 0.98   -0.495 0.250  1.02 #> 6 All          1        0 0.755     195       97 0.975  -0.497 0.250  1.03  # Now compute test based on these weights ten %>% summarise(S = sum(OminusE*wMB),                   V = sum(Var*wMB^2),                   Z = S/sqrt(V)) %>%         mutate(p=pnorm(Z)) #> # A tibble: 1 × 4 #>       S     V     Z       p #>   <dbl> <dbl> <dbl>   <dbl> #> 1 -20.4  55.3 -2.74 0.00304  # Create 0 weights for first 6 months ten <- ten %>% mutate(w6 = 1 * (tte >= 6)) ten %>% summarise(S = sum(OminusE*w6),                   V = sum(Var*w6^2),                   Z = S/sqrt(V)) %>%          mutate(p=pnorm(Z)) #> # A tibble: 1 × 4 #>       S     V     Z        p #>   <dbl> <dbl> <dbl>    <dbl> #> 1 -16.8  21.5 -3.62 0.000147          # Generate another dataset ds <- simPWSurv(n = 200,                 enrollRates = tibble(rate = 200 / 12, duration = 12),                 failRates = tribble(                    ~Stratum, ~Period, ~Treatment,     ~duration, ~rate,                    \"All\",        1,   \"Control\",      42,        log(2) / 15,                    \"All\",        1,   \"Experimental\", 6,         log(2) / 15,                    \"All\",        2,   \"Experimental\", 36,        log(2) / 15 * 0.6),                 dropoutRates = tribble(                    ~Stratum, ~Period, ~Treatment,     ~duration, ~rate,                    \"All\",        1,   \"Control\",      42,        0,                    \"All\",        1,   \"Experimental\", 42,        0)        ) # Cut data at 24 months after final enrollment MBdelayed2 <- ds %>% cutData(max(ds$enrollTime) + 24)"},{"path":"https://merck.github.io/simtrial/reference/cutData.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a Dataset for Analysis at a Specified Date — cutData","title":"Cut a Dataset for Analysis at a Specified Date — cutData","text":"Cut Dataset Analysis Specified Date","code":""},{"path":"https://merck.github.io/simtrial/reference/cutData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a Dataset for Analysis at a Specified Date — cutData","text":"","code":"cutData(x, cutDate)"},{"path":"https://merck.github.io/simtrial/reference/cutData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a Dataset for Analysis at a Specified Date — cutData","text":"x time--event dataset, e.g., generated simPWSurv cutDate date relative start randomization (cte input dataset) dataset cut analysis","code":""},{"path":"https://merck.github.io/simtrial/reference/cutData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a Dataset for Analysis at a Specified Date — cutData","text":"dataset ready survival analysis","code":""},{"path":"https://merck.github.io/simtrial/reference/cutData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a Dataset for Analysis at a Specified Date — cutData","text":"","code":"# Use default enrollment and event rates and cut at calendar time 5 after start # of randomization library(dplyr) simPWSurv(n=20) %>% cutData(5) #> # A tibble: 20 × 4 #> # Groups:   Stratum, Treatment [2] #>      tte event Stratum Treatment    #>    <dbl> <dbl> <chr>   <chr>        #>  1 4.83      0 All     Control      #>  2 4.81      0 All     Experimental #>  3 4.55      0 All     Control      #>  4 4.39      0 All     Experimental #>  5 4.38      0 All     Control      #>  6 4.11      0 All     Experimental #>  7 4.07      0 All     Experimental #>  8 4.05      0 All     Control      #>  9 4.04      0 All     Experimental #> 10 3.99      0 All     Experimental #> 11 3.79      0 All     Control      #> 12 3.69      0 All     Control      #> 13 2.18      1 All     Control      #> 14 3.61      0 All     Experimental #> 15 3.58      0 All     Experimental #> 16 3.51      0 All     Control      #> 17 3.51      0 All     Experimental #> 18 0.797     1 All     Experimental #> 19 3.16      0 All     Control      #> 20 3.04      0 All     Control"},{"path":"https://merck.github.io/simtrial/reference/cutDataAtCount.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a Dataset for Analysis at a Specified Event Count — cutDataAtCount","title":"Cut a Dataset for Analysis at a Specified Event Count — cutDataAtCount","text":"cutDataAtCount takes time--event data set cuts data event count reached.","code":""},{"path":"https://merck.github.io/simtrial/reference/cutDataAtCount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a Dataset for Analysis at a Specified Event Count — cutDataAtCount","text":"","code":"cutDataAtCount(x, count)"},{"path":"https://merck.github.io/simtrial/reference/cutDataAtCount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a Dataset for Analysis at a Specified Event Count — cutDataAtCount","text":"x time--event dataset, e.g., generated simPWSurv count event count data cutoff made","code":""},{"path":"https://merck.github.io/simtrial/reference/cutDataAtCount.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a Dataset for Analysis at a Specified Event Count — cutDataAtCount","text":"tibble ready survival analysis, including culumns time event (tte), event, stratum treatment.","code":""},{"path":"https://merck.github.io/simtrial/reference/cutDataAtCount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a Dataset for Analysis at a Specified Event Count — cutDataAtCount","text":"","code":"library(tidyr) # Use default enrollment and event rates at cut at 100 events x <- simPWSurv(n=200) %>% cutDataAtCount(100) table(x$event,x$Treatment) #>     #>     Control Experimental #>   0      42           58 #>   1      58           42"},{"path":"https://merck.github.io/simtrial/reference/fixedBlockRand.html","id":null,"dir":"Reference","previous_headings":"","what":"Permuted fixed block randomization — fixedBlockRand","title":"Permuted fixed block randomization — fixedBlockRand","text":"Fixed block randomization. block input repeat treatment code number times included within block. final block partial block n exact multiple block length.","code":""},{"path":"https://merck.github.io/simtrial/reference/fixedBlockRand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permuted fixed block randomization — fixedBlockRand","text":"","code":"fixedBlockRand(n = 10, block = c(0, 0, 1, 1))"},{"path":"https://merck.github.io/simtrial/reference/fixedBlockRand.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permuted fixed block randomization — fixedBlockRand","text":"n sample size randomized block Vector treatments included block","code":""},{"path":"https://merck.github.io/simtrial/reference/fixedBlockRand.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permuted fixed block randomization — fixedBlockRand","text":"treatment group sequence (vector) length n treatments block permuted within block block size equal length block","code":""},{"path":"https://merck.github.io/simtrial/reference/fixedBlockRand.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permuted fixed block randomization — fixedBlockRand","text":"","code":"library(dplyr) # 2:1 randomization with block size 3, treatments \"A\" and \"B\" tibble(x=1:10) %>% mutate(Treatment=fixedBlockRand(block=c(\"A\",\"B\",\"B\"))) #> # A tibble: 10 × 2 #>        x Treatment #>    <int> <chr>     #>  1     1 B         #>  2     2 B         #>  3     3 A         #>  4     4 B         #>  5     5 A         #>  6     6 B         #>  7     7 B         #>  8     8 A         #>  9     9 B         #> 10    10 B         # Stratified randomization tibble(Stratum=c(rep(\"A\",10),rep(\"B\",10))) %>% group_by(Stratum) %>% mutate(Treatment=fixedBlockRand()) #> # A tibble: 20 × 2 #> # Groups:   Stratum [2] #>    Stratum Treatment #>    <chr>       <dbl> #>  1 A               1 #>  2 A               1 #>  3 A               0 #>  4 A               0 #>  5 A               1 #>  6 A               0 #>  7 A               0 #>  8 A               1 #>  9 A               0 #> 10 A               1 #> 11 B               1 #> 12 B               0 #> 13 B               0 #> 14 B               1 #> 15 B               0 #> 16 B               1 #> 17 B               0 #> 18 B               1 #> 19 B               1 #> 20 B               0"},{"path":"https://merck.github.io/simtrial/reference/getCutDateForCount.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Date at Which an Event Count is Reached — getCutDateForCount","title":"Get Date at Which an Event Count is Reached — getCutDateForCount","text":"Get Date Event Count Reached","code":""},{"path":"https://merck.github.io/simtrial/reference/getCutDateForCount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Date at Which an Event Count is Reached — getCutDateForCount","text":"","code":"getCutDateForCount(x, count)"},{"path":"https://merck.github.io/simtrial/reference/getCutDateForCount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Date at Which an Event Count is Reached — getCutDateForCount","text":"x time--event dataset, e.g., generated simPWSurv count event count dataset cut analysis","code":""},{"path":"https://merck.github.io/simtrial/reference/getCutDateForCount.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Date at Which an Event Count is Reached — getCutDateForCount","text":"numeric value cte input dataset targeted event count reached, final event count never reached, final cte event occurs.","code":""},{"path":"https://merck.github.io/simtrial/reference/getCutDateForCount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Date at Which an Event Count is Reached — getCutDateForCount","text":"","code":"library(dplyr) # Use default enrollment and calendar cut date for 50 events in Positive stratum x <- simPWSurv(n=200,                strata = tibble::tibble(Stratum=c(\"Positive\",\"Negative\"), p = c(.5, .5)),                failRates = tibble::tibble(Stratum = rep(c(\"Positive\",\"Negative\"),2),                                           period = rep(1, 4),                                           Treatment = c(rep(\"Control\", 2),                                                         rep(\"Experimental\", 2)),                                           duration = rep(1, 4),                                           rate = log(2) / c(6, 9, 9, 12)                                           ),                dropoutRates = tibble::tibble(Stratum = rep(c(\"Positive\",\"Negative\"),2),                                              period = rep(1, 4),                                              Treatment = c(rep(\"Control\", 2),                                                            rep(\"Experimental\", 2)),                                              duration = rep(1, 4),                                              rate = rep(.001, 4)                                             )               ) d <- getCutDateForCount(filter(x,Stratum==\"Positive\"),count=50) y <- cutData(x,cutDate=d) table(y$Stratum,y$event) #>            #>             0  1 #>   Negative 53 42 #>   Positive 44 50"},{"path":"https://merck.github.io/simtrial/reference/pMaxCombo.html","id":null,"dir":"Reference","previous_headings":"","what":"MaxCombo p-value — pMaxCombo","title":"MaxCombo p-value — pMaxCombo","text":"pMaxCombo() computes p-values MaxCombo test based output simtrial::tenFHcorr(). still experimental stage intended use simtrial::simfix() trial simulation routine. However, can also used analyze clinical trial data provided ADaM ADTTE format.","code":""},{"path":"https://merck.github.io/simtrial/reference/pMaxCombo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MaxCombo p-value — pMaxCombo","text":"","code":"pMaxCombo(Z, dummyvar, algorithm = GenzBretz(maxpts = 50000, abseps = 1e-05))"},{"path":"https://merck.github.io/simtrial/reference/pMaxCombo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MaxCombo p-value — pMaxCombo","text":"Z dataset output tenFHcorr(); see examples. dummyvar dummy input allows group_map() used compute p-values multiple simulations. algorithm passed directly algorithm argument mvtnorm::pmvnorm()","code":""},{"path":"https://merck.github.io/simtrial/reference/pMaxCombo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MaxCombo p-value — pMaxCombo","text":"numeric p-value","code":""},{"path":"https://merck.github.io/simtrial/reference/pMaxCombo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MaxCombo p-value — pMaxCombo","text":"","code":"library(tidyr) x <- simfix(nsim=1,timingType=5,rg=tibble::tibble(rho=c(0,0,1),gamma=c(0,1,1))) head(x) #>   Events       lnhr rho gamma         Z        V1        V2        V3 #> 1    358 -0.4732358   0     0 -4.444008 1.0000000 0.8536460 0.9335361 #> 2    358 -0.4732358   0     1 -4.961917 0.8536460 1.0000000 0.9344299 #> 3    358 -0.4732358   1     1 -5.154735 0.9335361 0.9344299 1.0000000 #>                             cut Duration Sim #> 1 Max(min follow-up, event cut) 72.06292   1 #> 2 Max(min follow-up, event cut) 72.06292   1 #> 3 Max(min follow-up, event cut) 72.06292   1 pMaxCombo(x) #> [1] 1.269962e-07 # Only use cuts for events, events + min follow-up xx <- simfix(nsim=100,timingType=5,rg=tibble::tibble(rho=c(0,0,1),gamma=c(0,1,1))) head(xx) #>   Events       lnhr rho gamma         Z        V1        V2        V3 #> 1    359 -0.3880754   0     0 -3.664528 1.0000000 0.8527970 0.9336387 #> 2    359 -0.3880754   0     1 -4.012084 0.8527970 1.0000000 0.9271514 #> 3    359 -0.3880754   1     1 -4.079676 0.9336387 0.9271514 1.0000000 #> 4    364 -0.3853280   0     0 -3.657905 1.0000000 0.8550036 0.9345809 #> 5    364 -0.3853280   0     1 -4.015353 0.8550036 1.0000000 0.9308244 #> 6    364 -0.3853280   1     1 -4.087843 0.9345809 0.9308244 1.0000000 #>                             cut Duration Sim #> 1 Max(min follow-up, event cut) 76.23990   1 #> 2 Max(min follow-up, event cut) 76.23990   1 #> 3 Max(min follow-up, event cut) 76.23990   1 #> 4 Max(min follow-up, event cut) 73.02375   2 #> 5 Max(min follow-up, event cut) 73.02375   2 #> 6 Max(min follow-up, event cut) 73.02375   2 # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up p <- unlist(xx %>%  dplyr::group_by(Sim) %>% dplyr::group_map(pMaxCombo)) mean(p<.025) #> [1] 0.99"},{"path":"https://merck.github.io/simtrial/reference/pwexpfit.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise exponential survival estimation — pwexpfit","title":"Piecewise exponential survival estimation — pwexpfit","text":"Computes survival function, density function, -2*log-likelihood based input dataset intervals piecewise constant failure rates. Initial version assumes observations right censored events .","code":""},{"path":"https://merck.github.io/simtrial/reference/pwexpfit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise exponential survival estimation — pwexpfit","text":"","code":"pwexpfit(   Srv = Surv(time = Ex1delayedEffect$month, event = Ex1delayedEffect$evntd),   intervals = array(3, 3) )"},{"path":"https://merck.github.io/simtrial/reference/pwexpfit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise exponential survival estimation — pwexpfit","text":"Srv input survival object (see Surv); note 0=censored, 1=event Surv intervals Vector containing positive values indicating interval lengths exponential rates assumed. Note final infinite interval added events occur final interval specified.","code":""},{"path":"https://merck.github.io/simtrial/reference/pwexpfit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise exponential survival estimation — pwexpfit","text":"matrix rows containing interval length, estimated rate, -2*log-likelihood interval.","code":""},{"path":"https://merck.github.io/simtrial/reference/pwexpfit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise exponential survival estimation — pwexpfit","text":"","code":"# use default arguments for delayed effect example dataset (Ex1delayedEffect) library(survival) rateall <- pwexpfit() rateall #>   intervals     TTOT events       rate     m2ll #> 1         3 937.1785     97 0.10350216 634.0236 #> 2         3 605.3572     71 0.11728612 446.3257 #> 3         3 346.8482     30 0.08649317 206.8614 #> 4       Inf 254.1148     20 0.07870458 141.6822 # Estimate by treatment effect rate1 <- with(subset(Ex1delayedEffect,trt==1), pwexpfit(Surv(month,evntd))) rate0 <- with(subset(Ex1delayedEffect,trt==0), pwexpfit(Surv(month,evntd))) rate1 #>   intervals     TTOT events       rate      m2ll #> 1         3 620.4375     64 0.10315302 418.75734 #> 2         3 415.8482     36 0.08657005 248.16970 #> 3         3 256.2053     19 0.07415927 136.85853 #> 4       Inf 205.4186     13 0.06328542  97.76261 rate0 #>   intervals      TTOT events      rate      m2ll #> 1         3 316.74106     33 0.1041861 215.26408 #> 2         3 189.50899     35 0.1846878 188.23619 #> 3         3  90.64288     11 0.1213554  68.39871 #> 4       Inf  48.69624      7 0.1437483  41.15568 rate1$rate/rate0$rate #> [1] 0.9900847 0.4687372 0.6110917 0.4402517 # chi-square test for (any) treatment effect (8 - 4 parameters = 4 df) pchisq(sum(rateall$m2ll)-sum(rate1$m2ll+rate0$m2ll), df = 4, lower.tail=FALSE) #> [1] 0.006424744 # compare with logrank survdiff(formula = Surv(month, evntd) ~ trt, data = Ex1delayedEffect) #> Call: #> survdiff(formula = Surv(month, evntd) ~ trt, data = Ex1delayedEffect) #>  #>         N Observed Expected (O-E)^2/E (O-E)^2/V #> trt=0 121       86     67.7      4.97      7.35 #> trt=1 240      132    150.3      2.24      7.35 #>  #>  Chisq= 7.3  on 1 degrees of freedom, p= 0.007  # simple model with 3 rates same for each for 3 months, # different for each treatment after months rate1a <- with(subset(Ex1delayedEffect,trt==1), pwexpfit(Surv(month,evntd),3)) rate0a <- with(subset(Ex1delayedEffect,trt==0), pwexpfit(Surv(month,evntd),3)) rate1a$rate/rate0a$rate #> [1] 0.9900847 0.4808339 m2ll0 <- rateall$m2ll[1]+rate1a$m2ll[2]+rate0a$m2ll[2] m2ll1 <- sum(rate0$m2ll)+sum(rate1$m2ll) # as a measure of strength, chi-square examines improvement in likelihood pchisq(m2ll0-m2ll1, 5, lower.tail=FALSE) #> [1] 0.741822"},{"path":"https://merck.github.io/simtrial/reference/rpwenroll.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Piecewise Exponential Enrollment — rpwenroll","title":"Generate Piecewise Exponential Enrollment — rpwenroll","text":"piecewise exponential enrollment rate generation enrollment rate distribution can easily approximated. rpwenroll() support simulation Lachin Foulkes (1986) sample size method (fixed trial duration) well Kim Tsiatis(1990) method (fixed enrollment rates either fixed enrollment duration fixed minimum follow-); see gsDesign.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwenroll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Piecewise Exponential Enrollment — rpwenroll","text":"","code":"rpwenroll(   n = NULL,   enrollRates = tibble::tibble(duration = c(1, 2), rate = c(2, 5)) )"},{"path":"https://merck.github.io/simtrial/reference/rpwenroll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Piecewise Exponential Enrollment — rpwenroll","text":"n Number observations. Default NULL yields random enrollment size. enrollRates tibble containing period duration (duration) enrollment rate (rate) specified enrollment periods. necessary, last period extended ensure enrollment specified n.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwenroll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Piecewise Exponential Enrollment — rpwenroll","text":"vector random enrollment times.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwenroll.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Piecewise Exponential Enrollment — rpwenroll","text":"","code":"# piecewise uniform (piecewise exponential inter-arrival times) for 10k patients enrollment # enrollment rates of 5 for time 0-100, 15 for 100-300, and 30 thereafter x <- rpwenroll(n=10000, enrollRates=tibble::tibble(rate = c(5, 15, 30), duration = c(100,200,100))) plot(x,1:10000,      main=\"Piecewise uniform enrollment simulation\",xlab=\"Time\",      ylab=\"Enrollment\")  # exponential enrollment x <- rpwenroll(10000, enrollRates=tibble::tibble(rate = .03, duration = 1)) plot(x,1:10000,main=\"Simulated exponential inter-arrival times\",      xlab=\"Time\",ylab=\"Enrollment\")"},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":null,"dir":"Reference","previous_headings":"","what":"The Piecewise Exponential Distribution — rpwexp","title":"The Piecewise Exponential Distribution — rpwexp","text":"piecewise exponential distribution allows simple method specify distribtuion hazard rate changes time. likely useful conditions failure rates change, also simulations may delayed treatment effect treatment effect otherwise changing (e.g., decreasing) time. rpwexp() support simulation Lachin Foulkes (1986) sample size method (fixed trial duration) well Kim Tsiatis(1990) method (fixed enrollment rates either fixed enrollment duration fixed minimum follow-); see gsDesign.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Piecewise Exponential Distribution — rpwexp","text":"","code":"rpwexp(n = 100, failRates = tibble(duration = c(1, 1), rate = c(10, 20)))"},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Piecewise Exponential Distribution — rpwexp","text":"n Number observations generated. failRates tibble containing duration rate variables. rate specifies failure rates corresponding interval duration specified duration. final interval extended infinite ensure observations generated.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Piecewise Exponential Distribution — rpwexp","text":"Using cumulative=TRUE option, enrollment times piecewise constant time can generated.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Piecewise Exponential Distribution — rpwexp","text":"","code":"# get 10k piecewise exponential failure times # failure rates are 1 for time 0-.5, 3 for time .5 - 1 and 10 for >1. # intervals specifies duration of each failure rate interval # with the final interval running to infinity x <- rpwexp(10000, failRates=tibble::tibble(rate = c(1, 3, 10), duration = c(.5,.5,1))) plot(sort(x),(10000:1)/10001,log=\"y\", main=\"PW Exponential simulated survival curve\", xlab=\"Time\",ylab=\"P{Survival}\")  # exponential failure times x <- rpwexp(10000, failRates=tibble::tibble(rate = 5, duration=1))  plot(sort(x),(10000:1)/10001,log=\"y\", main=\"Exponential simulated survival curve\",      xlab=\"Time\",ylab=\"P{Survival}\")"},{"path":"https://merck.github.io/simtrial/reference/rpwexpRcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"The Piecewise Exponential Distribution in C++ — rpwexpRcpp","title":"The Piecewise Exponential Distribution in C++ — rpwexpRcpp","text":"Piecewise Exponential Distribution C++","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexpRcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Piecewise Exponential Distribution in C++ — rpwexpRcpp","text":"","code":"rpwexpRcpp(n, failRates)"},{"path":"https://merck.github.io/simtrial/reference/rpwexpRcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Piecewise Exponential Distribution in C++ — rpwexpRcpp","text":"n Number observations generated. failRates dataframe containing duration rate variables.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexpinvRcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"The Piecewise Exponential Distribution using inverse CDF method in C++ — rpwexpinvRcpp","title":"The Piecewise Exponential Distribution using inverse CDF method in C++ — rpwexpinvRcpp","text":"Piecewise Exponential Distribution using inverse CDF method C++","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexpinvRcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Piecewise Exponential Distribution using inverse CDF method in C++ — rpwexpinvRcpp","text":"","code":"rpwexpinvRcpp(n, failRates)"},{"path":"https://merck.github.io/simtrial/reference/rpwexpinvRcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Piecewise Exponential Distribution using inverse CDF method in C++ — rpwexpinvRcpp","text":"n Number observations generated. failRates dataframe containing duration rate variables.","code":""},{"path":"https://merck.github.io/simtrial/reference/simPWSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv","text":"simPWSurv enables simulation clinical trial essentially arbitrary patterns enrollment, failure rates censoring. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rate changes time. main purpose may generate trial can analyzed single point time using group sequential methods, routine can also used simulate adaptive trial design. Enrollment, failure dropout rates specified treatment group, stratum time period. Fixed block randomization used; blocks must include treatments provided failure dropout specification. Default arguments set allow simple implementation non-proportional hazards assumption unstratified design.","code":""},{"path":"https://merck.github.io/simtrial/reference/simPWSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv","text":"","code":"simPWSurv(   n = 100,   strata = tibble::tibble(Stratum = \"All\", p = 1),   block = c(rep(\"Control\", 2), rep(\"Experimental\", 2)),   enrollRates = tibble::tibble(rate = 9, duration = 1),   failRates = tibble::tibble(Stratum = rep(\"All\", 4), period = rep(1:2, 2), Treatment =     c(rep(\"Control\", 2), rep(\"Experimental\", 2)), duration = rep(c(3, 1), 2), rate =     log(2)/c(9, 9, 9, 18)),   dropoutRates = tibble::tibble(Stratum = rep(\"All\", 2), period = rep(1, 2), Treatment =     c(\"Control\", \"Experimental\"), duration = rep(100, 2), rate = rep(0.001, 2)) )"},{"path":"https://merck.github.io/simtrial/reference/simPWSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv","text":"n Number observations. length(n) > 1, length taken number required. strata tibble strata specified Stratum, probability (incidence) stratum p block Vector treatments included  block enrollRates Enrollment rates; see details examples failRates Failure rates; see details examples; note treatments need input block dropoutRates Dropout rates; see details examples; note treatments need input block","code":""},{"path":"https://merck.github.io/simtrial/reference/simPWSurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv","text":"tibble following variables observation Stratum, enrollTime (enrollment time observation), Treatment (treatment group; one values input block), failTime (failure time generated using rpwexp()), dropoutTime (dropout time generated using rpwexp()), cte (calendar time enrollment plot minimum failure time dropout time), fail (indicator cte set using failure time; .e., 1 failure, 0 dropout).","code":""},{"path":"https://merck.github.io/simtrial/reference/simPWSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv","text":"","code":"library(dplyr) # Tests  simPWSurv(n=20) #> # A tibble: 20 × 7 #> # Groups:   Stratum, Treatment [2] #>    Stratum enrollTime Treatment    failTime dropoutTime    cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl>  <dbl> <dbl> #>  1 All         0.0917 Experimental   26.7          292. 26.8       1 #>  2 All         0.113  Experimental   35.6         2659. 35.7       1 #>  3 All         0.144  Control         4.42        3461.  4.56      1 #>  4 All         0.314  Control        29.5         1093. 29.9       1 #>  5 All         0.389  Experimental    0.451        101.  0.840     1 #>  6 All         0.740  Control        16.8         1267. 17.6       1 #>  7 All         0.852  Experimental   66.6         1476. 67.4       1 #>  8 All         1.22   Control         7.54         137.  8.76      1 #>  9 All         1.33   Control         1.87         601.  3.20      1 #> 10 All         1.38   Experimental   20.0          848. 21.3       1 #> 11 All         1.55   Control         5.05        1628.  6.61      1 #> 12 All         1.73   Experimental   31.8          360. 33.5       1 #> 13 All         1.84   Control        11.1         1072. 12.9       1 #> 14 All         2.00   Experimental   42.1          327. 44.1       1 #> 15 All         2.01   Control        17.7          246. 19.7       1 #> 16 All         2.23   Experimental   51.1          413. 53.3       1 #> 17 All         2.29   Experimental   76.7          660. 79.0       1 #> 18 All         2.52   Control         1.09         716.  3.62      1 #> 19 All         2.54   Control        14.3          353. 16.8       1 #> 20 All         2.73   Experimental    1.11         178.  3.85      1  # 3:1 randomization  simPWSurv(n=20,block=c(rep(\"Experimental\",3),\"Control\")) #> # A tibble: 20 × 7 #> # Groups:   Stratum, Treatment [2] #>    Stratum enrollTime Treatment    failTime dropoutTime    cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl>  <dbl> <dbl> #>  1 All          0.103 Control         5.12        168.    5.22     1 #>  2 All          0.281 Experimental    5.91        419.    6.19     1 #>  3 All          0.326 Experimental    1.41        722.    1.73     1 #>  4 All          0.380 Experimental  113.          247.  114.       1 #>  5 All          0.442 Experimental   24.0         368.   24.4      1 #>  6 All          0.443 Control         1.71        371.    2.15     1 #>  7 All          0.445 Experimental   10.3         442.   10.8      1 #>  8 All          0.491 Experimental    4.80        159.    5.29     1 #>  9 All          0.714 Experimental    6.01       1746.    6.72     1 #> 10 All          0.778 Experimental   35.7         293.   36.5      1 #> 11 All          0.907 Control        29.6          30.0  30.5      1 #> 12 All          0.949 Experimental   45.0        4263.   46.0      1 #> 13 All          1.10  Control        13.6         532.   14.7      1 #> 14 All          1.21  Experimental   17.8         418.   19.0      1 #> 15 All          1.35  Experimental    1.96         51.5   3.31     1 #> 16 All          1.49  Experimental    0.520       179.    2.01     1 #> 17 All          1.54  Experimental   19.8         368.   21.3      1 #> 18 All          1.58  Experimental   48.7        6033.   50.2      1 #> 19 All          1.69  Control         4.37        173.    6.05     1 #> 20 All          1.74  Experimental   23.5        2087.   25.3      1  # Simulate 2 strata; will use defaults for blocking and enrollRates simPWSurv(n=20,           # 2 strata,30% and 70% prevalence           strata=tibble::tibble(Stratum=c(\"Low\",\"High\"),p=c(.3,.7)),           failRates=tibble::tibble(Stratum=c(rep(\"Low\",4),rep(\"High\",4)),                                    period=rep(1:2,4),                                    Treatment=rep(c(rep(\"Control\",2),rep(\"Experimental\",2)),2),                                    duration=rep(c(3,1),4),                                    rate=c(.03,.05,.03,.03,.05,.08,.07,.04)),           dropoutRates=tibble::tibble(Stratum=c(rep(\"Low\",2),rep(\"High\",2)),                                       period=rep(1,4),                                       Treatment=rep(c(\"Control\",\"Experimental\"),2),                                       duration=rep(1,4),                                       rate=rep(.001,4)) ) #> # A tibble: 20 × 7 #> # Groups:   Stratum, Treatment [4] #>    Stratum enrollTime Treatment    failTime dropoutTime   cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl> <dbl> <dbl> #>  1 High        0.0330 Experimental    10.7       2147.  10.7      1 #>  2 High        0.170  Control         34.5       2363.  34.6      1 #>  3 High        0.186  Experimental     1.49       620.   1.68     1 #>  4 High        0.365  Control          5.86       399.   6.22     1 #>  5 High        0.406  Control         22.7       1180.  23.1      1 #>  6 High        0.537  Experimental    29.5       1474.  30.1      1 #>  7 High        0.616  Control         39.2        365.  39.9      1 #>  8 Low         0.618  Experimental    10.3         79.8 10.9      1 #>  9 High        0.670  Experimental     9.10       170.   9.77     1 #> 10 High        0.687  Control          6.30      1173.   6.99     1 #> 11 High        1.06   Experimental    40.1        536.  41.1      1 #> 12 High        1.08   Experimental    34.8        491.  35.9      1 #> 13 Low         1.18   Control          1.07      1181.   2.24     1 #> 14 High        1.22   Control         26.6        252.  27.8      1 #> 15 High        1.30   Control          9.08        80.4 10.4      1 #> 16 High        1.42   Experimental    20.9        230.  22.3      1 #> 17 High        1.55   Control          2.17       911.   3.72     1 #> 18 High        1.59   Experimental     5.97       709.   7.56     1 #> 19 High        1.62   Control         22.6        540.  24.2      1 #> 20 High        1.79   Experimental     9.09      2104.  10.9      1  # If you want a more rectangular entry for a tibble failRates <- bind_rows(    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Control\"     ,duration=3,rate=.03),    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Experimental\",duration=3,rate=.03),    tibble(Stratum=\"Low\" ,period=2,Treatment=\"Experimental\",duration=3,rate=.02),    tibble(Stratum=\"High\",period=1,Treatment=\"Control\"     ,duration=3,rate=.05),    tibble(Stratum=\"High\",period=1,Treatment=\"Experimental\",duration=3,rate=.06),    tibble(Stratum=\"High\",period=2,Treatment=\"Experimental\",duration=3,rate=.03) ) dropoutRates <- bind_rows(    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Control\"     ,duration=3,rate=.001),    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Experimental\",duration=3,rate=.001),    tibble(Stratum=\"High\",period=1,Treatment=\"Control\"     ,duration=3,rate=.001),    tibble(Stratum=\"High\",period=1,Treatment=\"Experimental\",duration=3,rate=.001) ) simPWSurv(n=12,strata=tibble(Stratum=c(\"Low\",\"High\"),p=c(.3,.7)),          failRates=failRates,dropoutRates=dropoutRates) #> # A tibble: 12 × 7 #> # Groups:   Stratum, Treatment [4] #>    Stratum enrollTime Treatment    failTime dropoutTime   cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl> <dbl> <dbl> #>  1 High        0.0361 Control         25.0       2590.  25.1      1 #>  2 Low         0.0647 Experimental     6.20       325.   6.27     1 #>  3 Low         0.161  Control         13.7         91.5 13.8      1 #>  4 High        0.199  Experimental    53.5        142.  53.7      1 #>  5 High        0.224  Experimental    76.6        887.  76.8      1 #>  6 High        0.237  Control         25.7         19.0 19.3      0 #>  7 High        0.278  Experimental     2.80       170.   3.08     1 #>  8 Low         0.298  Control          9.81       644.  10.1      1 #>  9 High        0.573  Control          9.04       478.   9.61     1 #> 10 Low         0.831  Experimental    62.8       3865.  63.6      1 #> 11 Low         0.854  Experimental    72.7        419.  73.5      1 #> 12 High        0.957  Control         22.1         16.1 17.1      0"},{"path":"https://merck.github.io/simtrial/reference/simPWSurv_.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv_","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv_","text":"simPWSurv_ enables simulation clinical trial essentially arbitrary patterns enrollment, failure rates censoring. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rate changes time. main purpose may generate trial can analyzed single point time using group sequential methods, routine can also used simulate adaptive trial design. Enrollment, failure dropout rates specified treatment group, stratum time period. Fixed block randomization used; blocks must include treatments provided failure dropout specification. Default arguments set allow simple implementation non-proportional hazards assumption unstratified design.","code":""},{"path":"https://merck.github.io/simtrial/reference/simPWSurv_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv_","text":"","code":"simPWSurv_(   n = 100,   strata = tibble::tibble(Stratum = \"All\", p = 1),   block = c(rep(\"Control\", 2), rep(\"Experimental\", 2)),   enrollRates = tibble::tibble(rate = 9, duration = 1),   failRates = tibble::tibble(Stratum = rep(\"All\", 4), period = rep(1:2, 2), Treatment =     c(rep(\"Control\", 2), rep(\"Experimental\", 2)), duration = rep(c(3, 1), 2), rate =     log(2)/c(9, 9, 9, 18)),   dropoutRates = tibble::tibble(Stratum = rep(\"All\", 2), period = rep(1, 2), Treatment =     c(\"Control\", \"Experimental\"), duration = rep(100, 2), rate = rep(0.001, 2)) )"},{"path":"https://merck.github.io/simtrial/reference/simPWSurv_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv_","text":"n Number observations. length(n) > 1, length taken number required. strata tibble strata specified Stratum, probability (incidence) stratum p block Vector treatments included  block enrollRates Enrollment rates; see details examples failRates Failure rates; see details examples; note treatments need input block dropoutRates Dropout rates; see details examples; note treatments need input block","code":""},{"path":"https://merck.github.io/simtrial/reference/simPWSurv_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv_","text":"tibble following variables observation Stratum, enrollTime (enrollment time observation), Treatment (treatment group; one values input block), failTime (failure time generated using rpwexp()), dropoutTime (dropout time generated using rpwexp()), cte (calendar time enrollment plot minimum failure time dropout time), fail (indicator cte set using failure time; .e., 1 failure, 0 dropout).","code":""},{"path":"https://merck.github.io/simtrial/reference/simPWSurv_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a stratified time-to-event outcome randomized trial — simPWSurv_","text":"","code":"library(dplyr) # Tests  simtrial:::simPWSurv_(n=20) #> # A tibble: 20 × 7 #> # Groups:   Stratum, Treatment [2] #>    Stratum enrollTime Treatment    failTime dropoutTime    cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl>  <dbl> <dbl> #>  1 All          0.227 Experimental    64.2       517.    64.4      1 #>  2 All          0.340 Experimental    80.0      1019.    80.4      1 #>  3 All          0.426 Control         20.7       743.    21.1      1 #>  4 All          0.478 Control         41.2       884.    41.7      1 #>  5 All          0.528 Experimental     3.21     2950.     3.74     1 #>  6 All          0.537 Control          4.08      440.     4.62     1 #>  7 All          0.559 Control          3.34      239.     3.90     1 #>  8 All          0.688 Experimental     7.19      284.     7.88     1 #>  9 All          0.784 Control         13.6      2477.    14.4      1 #> 10 All          0.859 Control         16.4         9.92  10.8      0 #> 11 All          0.925 Experimental     1.04      867.     1.97     1 #> 12 All          0.950 Experimental    22.7      1103.    23.6      1 #> 13 All          0.950 Experimental     2.15      264.     3.10     1 #> 14 All          1.00  Control         16.2       196.    17.2      1 #> 15 All          1.03  Control          1.72      621.     2.75     1 #> 16 All          1.36  Experimental    99.9      2983.   101.       1 #> 17 All          1.73  Control          2.38     1189.     4.11     1 #> 18 All          2.03  Control          8.22     1573.    10.2      1 #> 19 All          2.07  Experimental    39.4       330.    41.5      1 #> 20 All          2.08  Experimental    25.4      1136.    27.5      1  # 3:1 randomization  simtrial:::simPWSurv_(n=20,block=c(rep(\"Experimental\",3),\"Control\")) #> # A tibble: 20 × 7 #> # Groups:   Stratum, Treatment [2] #>    Stratum enrollTime Treatment    failTime dropoutTime   cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl> <dbl> <dbl> #>  1 All          0.197 Control         29.9         103. 30.1      1 #>  2 All          0.266 Experimental     4.63        440.  4.90     1 #>  3 All          0.336 Experimental    22.6        1095. 22.9      1 #>  4 All          0.514 Experimental     2.63       2741.  3.14     1 #>  5 All          0.557 Control         19.0         285. 19.5      1 #>  6 All          0.691 Experimental    21.7         629. 22.4      1 #>  7 All          0.741 Experimental    13.9         461. 14.7      1 #>  8 All          0.834 Experimental    39.6         276. 40.4      1 #>  9 All          1.14  Experimental     7.72        317.  8.87     1 #> 10 All          1.18  Experimental    33.3        1616. 34.5      1 #> 11 All          1.19  Control          1.39        791.  2.57     1 #> 12 All          1.21  Experimental     5.46        564.  6.66     1 #> 13 All          1.23  Experimental     9.60        486. 10.8      1 #> 14 All          1.30  Experimental    37.1        1532. 38.4      1 #> 15 All          1.35  Experimental    31.0        1847. 32.3      1 #> 16 All          1.45  Control          5.40        164.  6.84     1 #> 17 All          1.59  Experimental     2.77       1545.  4.36     1 #> 18 All          1.69  Control         21.2        2859. 22.9      1 #> 19 All          1.75  Experimental     6.14        294.  7.90     1 #> 20 All          1.82  Experimental     8.82        574. 10.6      1  # Simulate 2 strata; will use defaults for blocking and enrollRates simtrial:::simPWSurv_(n=20,           # 2 strata,30% and 70% prevalence           strata=tibble::tibble(Stratum=c(\"Low\",\"High\"),p=c(.3,.7)),           failRates=tibble::tibble(Stratum=c(rep(\"Low\",4),rep(\"High\",4)),                                    period=rep(1:2,4),                                    Treatment=rep(c(rep(\"Control\",2),rep(\"Experimental\",2)),2),                                    duration=rep(c(3,1),4),                                    rate=c(.03,.05,.03,.03,.05,.08,.07,.04)),           dropoutRates=tibble::tibble(Stratum=c(rep(\"Low\",2),rep(\"High\",2)),                                       period=rep(1,4),                                       Treatment=rep(c(\"Control\",\"Experimental\"),2),                                       duration=rep(1,4),                                       rate=rep(.001,4)) ) #> # A tibble: 20 × 7 #> # Groups:   Stratum, Treatment [4] #>    Stratum enrollTime Treatment    failTime dropoutTime     cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl>   <dbl> <dbl> #>  1 High        0.0295 Control         0.422      1560.    0.451     1 #>  2 High        0.195  Experimental   47.1         513.   47.3       1 #>  3 High        0.259  Experimental    9.62        612.    9.88      1 #>  4 High        0.346  Control         0.108        89.1   0.454     1 #>  5 High        0.386  Control         6.37       2033.    6.75      1 #>  6 Low         0.439  Control        13.9        1469.   14.4       1 #>  7 High        0.488  Experimental    7.37        575.    7.85      1 #>  8 Low         0.635  Control        13.7         209.   14.4       1 #>  9 High        0.855  Experimental    4.52        669.    5.37      1 #> 10 High        0.922  Control         0.134      1009.    1.06      1 #> 11 High        1.04   Control        30.7         466.   31.8       1 #> 12 High        1.06   Control        13.9         297.   14.9       1 #> 13 High        1.41   Experimental    7.39        676.    8.80      1 #> 14 Low         1.43   Experimental  119.          361.  121.        1 #> 15 High        1.55   Experimental   18.4          21.4  20.0       1 #> 16 High        1.61   Experimental   67.3        2766.   68.9       1 #> 17 Low         1.68   Experimental    6.41         64.0   8.09      1 #> 18 Low         1.70   Control         8.70        538.   10.4       1 #> 19 Low         1.75   Control         9.12        133.   10.9       1 #> 20 High        1.76   Experimental   38.6        1809.   40.3       1  # If you want a more rectangular entry for a tibble failRates <- bind_rows(    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Control\"     ,duration=3,rate=.03),    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Experimental\",duration=3,rate=.03),    tibble(Stratum=\"Low\" ,period=2,Treatment=\"Experimental\",duration=3,rate=.02),    tibble(Stratum=\"High\",period=1,Treatment=\"Control\"     ,duration=3,rate=.05),    tibble(Stratum=\"High\",period=1,Treatment=\"Experimental\",duration=3,rate=.06),    tibble(Stratum=\"High\",period=2,Treatment=\"Experimental\",duration=3,rate=.03) ) dropoutRates <- bind_rows(    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Control\"     ,duration=3,rate=.001),    tibble(Stratum=\"Low\" ,period=1,Treatment=\"Experimental\",duration=3,rate=.001),    tibble(Stratum=\"High\",period=1,Treatment=\"Control\"     ,duration=3,rate=.001),    tibble(Stratum=\"High\",period=1,Treatment=\"Experimental\",duration=3,rate=.001) ) simtrial:::simPWSurv_(n=12,strata=tibble(Stratum=c(\"Low\",\"High\"),p=c(.3,.7)),          failRates=failRates,dropoutRates=dropoutRates) #> # A tibble: 12 × 7 #> # Groups:   Stratum, Treatment [4] #>    Stratum enrollTime Treatment    failTime dropoutTime    cte  fail #>    <chr>        <dbl> <chr>           <dbl>       <dbl>  <dbl> <dbl> #>  1 Low         0.0602 Control        35.0         3610. 35.1       1 #>  2 High        0.151  Control         0.387        281.  0.539     1 #>  3 High        0.299  Control        25.8          795. 26.1       1 #>  4 High        0.495  Experimental   73.7          110. 74.2       1 #>  5 High        0.499  Experimental    2.05        1110.  2.55      1 #>  6 High        0.706  Control        13.8         1512. 14.5       1 #>  7 High        0.813  Control        47.9         4795. 48.7       1 #>  8 Low         0.874  Experimental   41.3         2626. 42.2       1 #>  9 High        1.02   Experimental   28.7         1043. 29.7       1 #> 10 High        1.12   Experimental   12.0          758. 13.1       1 #> 11 High        1.31   Control        16.1          401. 17.4       1 #> 12 High        1.36   Experimental    3.47        1698.  4.83      1"},{"path":"https://merck.github.io/simtrial/reference/simfix.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of fixed sample size design for time-to-event endpoint — simfix","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix","text":"simfix() provide simulations single endpoint two-arm trial enrollment, hazard ratio, failure dropout rates change time.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix","text":"","code":"simfix(   nsim = 1000,   sampleSize = 500,   targetEvents = 350,   strata = tibble::tibble(Stratum = \"All\", p = 1),   enrollRates = tibble::tibble(duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   totalDuration = 30,   block = rep(c(\"Experimental\", \"Control\"), 2),   timingType = 1:5,   rg = tibble::tibble(rho = 0, gamma = 0),   seed = NULL )"},{"path":"https://merck.github.io/simtrial/reference/simfix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix","text":"nsim Number simulations perform. sampleSize Total sample size per simulation. targetEvents Targeted event count analysis. strata tibble strata specified Stratum, probability (incidence) stratum p. enrollRates Piecewise constant enrollment rates time period. Note overall population enrollment rates strata argument controls random distribution strata. failRates Piecewise constant control group failure rates, hazard ratio experimental vs control, dropout rates stratum time period. totalDuration Total follow-start enrollment data cutoff. block simtrial::simPWSurv(). Vector treatments included block. timingType numeric vector determining data cutoffs used; see details. Default include available cutoff methods. rg simtrial::tenFHCorr(). tibble variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted logrank test per row. seed Optional. Initial seed simulations","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix","text":"tibble including columns Events (event count), lnhr (log-hazard ratio), Z (normal test statistic; < 0 favors experimental) cut (text describing cutoff used), Duration (duration trial cutoff analysis) sim (sequential simulation id). One row per simulated dataset per cutoff specified timingType, per test statistic specified. multiple Fleming-Harrington tests specified rg, columns rho,gamma also included.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix","text":"timingType 5 elements indicating different options data cutoff. 1 uses planned study duration, 2 time targeted event count achieved, 3 planned minimum follow-enrollment complete, 4 maximum planned study duration targeted event count cuts (1 2), 5 maximum targeted event count minimum follow-cuts (2 3).","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix","text":"","code":"library(tidyr) library(dplyr) library(doParallel) #> Loading required package: foreach #> Loading required package: iterators #> Loading required package: parallel # Show output structure simfix(nsim=3) #>    Events        lnhr          Z                              cut Duration Sim #> 1      98 -0.07210747 -0.3561704                 Planned duration 30.00000   1 #> 2     350 -0.35553160 -3.3158379                  Targeted events 69.98166   1 #> 3     376 -0.31616814 -3.0599686                Minimum follow-up 75.40185   1 #> 4     350 -0.35553160 -3.3158379 Max(planned duration, event cut) 69.98166   1 #> 5     376 -0.31616814 -3.0599686    Max(min follow-up, event cut) 75.40185   1 #> 6      92 -0.41840045 -1.9945825                 Planned duration 30.00000   2 #> 7     350 -0.51195437 -4.7558955                  Targeted events 72.61954   2 #> 8     367 -0.51337778 -4.8816745                Minimum follow-up 75.88882   2 #> 9     350 -0.51195437 -4.7558955 Max(planned duration, event cut) 72.61954   2 #> 10    367 -0.51337778 -4.8816745    Max(min follow-up, event cut) 75.88882   2 #> 11    104 -0.43856173 -2.2236941                 Planned duration 30.00000   3 #> 12    350 -0.31600080 -2.9475270                  Targeted events 68.78812   3 #> 13    356 -0.34208444 -3.2157645                Minimum follow-up 70.47547   3 #> 14    350 -0.31600080 -2.9475270 Max(planned duration, event cut) 68.78812   3 #> 15    356 -0.34208444 -3.2157645    Max(min follow-up, event cut) 70.47547   3 # Example with 2 tests: logrank and FH(0,1) simfix(nsim=1,rg=tibble::tibble(rho=0,gamma=c(0,1))) #>    Events       lnhr rho gamma         Z        V1        V2 #> 1     108 -0.3923692   0     0 -2.019890 1.0000000 0.8376998 #> 2     108 -0.3923692   0     1 -3.096403 0.8376998 1.0000000 #> 3     350 -0.4197814   0     0 -3.902792 1.0000000 0.8541141 #> 4     350 -0.4197814   0     1 -3.742274 0.8541141 1.0000000 #> 5     339 -0.4353505   0     0 -3.983432 1.0000000 0.8531812 #> 6     339 -0.4353505   0     1 -3.947295 0.8531812 1.0000000 #> 7     350 -0.4197814   0     0 -3.902792 1.0000000 0.8541141 #> 8     350 -0.4197814   0     1 -3.742274 0.8541141 1.0000000 #> 9     350 -0.4197814   0     0 -3.902792 1.0000000 0.8541141 #> 10    350 -0.4197814   0     1 -3.742274 0.8541141 1.0000000 #>                                 cut Duration Sim #> 1                  Planned duration 30.00000   1 #> 2                  Planned duration 30.00000   1 #> 3                   Targeted events 76.54771   1 #> 4                   Targeted events 76.54771   1 #> 5                 Minimum follow-up 74.52111   1 #> 6                 Minimum follow-up 74.52111   1 #> 7  Max(planned duration, event cut) 76.54771   1 #> 8  Max(planned duration, event cut) 76.54771   1 #> 9     Max(min follow-up, event cut) 76.54771   1 #> 10    Max(min follow-up, event cut) 76.54771   1 # Power by test # Only use cuts for events, events + min follow-up xx <- simfix(nsim=100,timingType=c(2,5),rg=tibble::tibble(rho=0,gamma=c(0,1))) # Get power approximation for FH, data cutoff combination xx %>% group_by(cut,rho,gamma) %>% summarise(mean(Z<=qnorm(.025))) #> `summarise()` has grouped output by 'cut', 'rho'. You can override using the #> `.groups` argument. #> # A tibble: 4 × 4 #> # Groups:   cut, rho [2] #>   cut                             rho gamma `mean(Z <= qnorm(0.025))` #>   <chr>                         <dbl> <dbl>                     <dbl> #> 1 Max(min follow-up, event cut)     0     0                      0.98 #> 2 Max(min follow-up, event cut)     0     1                      0.99 #> 3 Targeted events                   0     0                      0.96 #> 4 Targeted events                   0     1                      0.98 # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up p <- xx %>%  filter(cut != \"Targeted events\") %>% group_by(Sim) %>% group_map(pMaxCombo) p <- unlist(p) mean(p<.025) #> [1] 0.99 # MaxCombo estimate for targeted events cutoff p <- unlist(xx %>%  filter(cut == \"Targeted events\") %>% group_by(Sim) %>% group_map(pMaxCombo)) mean(p<.025) #> [1] 0.97 # Use two cores registerDoParallel(2) simfix(nsim=10, seed = 2022) #> Using 2 cores with backend doParallelMC #>    Events        lnhr           Z                              cut Duration Sim #> 1     109 -0.39889743 -2.06986755                 Planned duration 30.00000   1 #> 2     350 -0.49422311 -4.60390065                  Targeted events 68.10765   1 #> 3     361 -0.46996411 -4.44698855                Minimum follow-up 70.94601   1 #> 4     350 -0.49422311 -4.60390065 Max(planned duration, event cut) 68.10765   1 #> 5     361 -0.46996411 -4.44698855    Max(min follow-up, event cut) 70.94601   1 #> 6      92  0.13030304  0.62455481                 Planned duration 30.00000   2 #> 7     350 -0.06380056 -0.59576098                  Targeted events 71.15880   2 #> 8     369 -0.12986489 -1.24394980                Minimum follow-up 74.20194   2 #> 9     350 -0.06380056 -0.59576098 Max(planned duration, event cut) 71.15880   2 #> 10    369 -0.12986489 -1.24394980    Max(min follow-up, event cut) 74.20194   2 #> 11    109 -0.35042569 -1.81806443                 Planned duration 30.00000   3 #> 12    350 -0.30340153 -2.82469678                  Targeted events 69.68286   3 #> 13    353 -0.30661159 -2.86687105                Minimum follow-up 71.40394   3 #> 14    350 -0.30340153 -2.82469678 Max(planned duration, event cut) 69.68286   3 #> 15    353 -0.30661159 -2.86687105    Max(min follow-up, event cut) 71.40394   3 #> 16    107 -0.32400212 -1.66943391                 Planned duration 30.00000   4 #> 17    350 -0.38322625 -3.56929885                  Targeted events 70.15615   4 #> 18    361 -0.40035000 -3.78355568                Minimum follow-up 73.04033   4 #> 19    350 -0.38322625 -3.56929885 Max(planned duration, event cut) 70.15615   4 #> 20    361 -0.40035000 -3.78355568    Max(min follow-up, event cut) 73.04033   4 #> 21     99 -0.13790150 -0.68382782                 Planned duration 30.00000   5 #> 22    350 -0.43925467 -4.08974448                  Targeted events 71.52825   5 #> 23    369 -0.44486563 -4.25463983                Minimum follow-up 76.21111   5 #> 24    350 -0.43925467 -4.08974448 Max(planned duration, event cut) 71.52825   5 #> 25    369 -0.44486563 -4.25463983    Max(min follow-up, event cut) 76.21111   5 #> 26    105 -0.18871020 -0.96580373                 Planned duration 30.00000   6 #> 27    350 -0.32895353 -3.07323368                  Targeted events 68.56574   6 #> 28    358 -0.33990896 -3.21127927                Minimum follow-up 69.61403   6 #> 29    350 -0.32895353 -3.07323368 Max(planned duration, event cut) 68.56574   6 #> 30    358 -0.33990896 -3.21127927    Max(min follow-up, event cut) 69.61403   6 #> 31     91 -0.32023796 -1.51269632                 Planned duration 30.00000   7 #> 32    350 -0.30003853 -2.79088836                  Targeted events 74.43009   7 #> 33    348 -0.30041840 -2.78367764                Minimum follow-up 73.88934   7 #> 34    350 -0.30003853 -2.79088836 Max(planned duration, event cut) 74.43009   7 #> 35    350 -0.30003853 -2.79088836    Max(min follow-up, event cut) 74.43009   7 #> 36    108 -0.06740129 -0.34998515                 Planned duration 30.00000   8 #> 37    350 -0.34760754 -3.23571976                  Targeted events 70.79181   8 #> 38    360 -0.36258193 -3.42179494                Minimum follow-up 73.10338   8 #> 39    350 -0.34760754 -3.23571976 Max(planned duration, event cut) 70.79181   8 #> 40    360 -0.36258193 -3.42179494    Max(min follow-up, event cut) 73.10338   8 #> 41    101 -0.51016154 -2.54286277                 Planned duration 30.00000   9 #> 42    350 -0.37603601 -3.50384516                  Targeted events 68.74117   9 #> 43    364 -0.37361232 -3.55001459                Minimum follow-up 74.54110   9 #> 44    350 -0.37603601 -3.50384516 Max(planned duration, event cut) 68.74117   9 #> 45    364 -0.37361232 -3.55001459    Max(min follow-up, event cut) 74.54110   9 #> 46     79  0.01209188  0.05336003                 Planned duration 30.00000  10 #> 47    350 -0.18922477 -1.76159151                  Targeted events 73.00188  10 #> 48    361 -0.19779690 -1.86989858                Minimum follow-up 76.39085  10 #> 49    350 -0.18922477 -1.76159151 Max(planned duration, event cut) 73.00188  10 #> 50    361 -0.19779690 -1.86989858    Max(min follow-up, event cut) 76.39085  10 stopImplicitCluster() registerDoSEQ()"},{"path":"https://merck.github.io/simtrial/reference/simfix2simPWSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Conversion of enrollment and failure rates from simfix() to simPWSurv() format — simfix2simPWSurv","title":"Conversion of enrollment and failure rates from simfix() to simPWSurv() format — simfix2simPWSurv","text":"simfix2simPWSurv() converts failure rates dropout rates entered simpler format simfix() used simtrial::simPWSurv(). failRates argument simfix() requires enrollment rates, failure rates hazard ratios dropout rates strata 2-arm trial, simtrial::simPWSurv() flexible less obvious flexible format. Since simfix() automatically analyzes data simtrial::simPWSurv() just produces simulation dataset, latter provides additional options analyze otherwise evaluate individual simulations ways simfix() .","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix2simPWSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conversion of enrollment and failure rates from simfix() to simPWSurv() format — simfix2simPWSurv","text":"","code":"simfix2simPWSurv(   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)) )"},{"path":"https://merck.github.io/simtrial/reference/simfix2simPWSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conversion of enrollment and failure rates from simfix() to simPWSurv() format — simfix2simPWSurv","text":"failRates Piecewise constant control group failure rates, hazard ratio experimental vs control, dropout rates stratum time period.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix2simPWSurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conversion of enrollment and failure rates from simfix() to simPWSurv() format — simfix2simPWSurv","text":"list two tibble components formatted simtrial::simPWSurv(): failRates dropoutRates.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix2simPWSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conversion of enrollment and failure rates from simfix() to simPWSurv() format — simfix2simPWSurv","text":"","code":"library(tidyr) library(dplyr) # Convert standard input simfix2simPWSurv() #> $failRates #> # A tibble: 4 × 5 #>   Stratum period Treatment    duration   rate #>   <chr>    <int> <chr>           <dbl>  <dbl> #> 1 All          1 Control             3 0.0770 #> 2 All          2 Control           100 0.0385 #> 3 All          1 Experimental        3 0.0693 #> 4 All          2 Experimental      100 0.0231 #>  #> $dropoutRates #> # A tibble: 4 × 5 #>   Stratum period Treatment    duration  rate #>   <chr>    <int> <chr>           <dbl> <dbl> #> 1 All          1 Control             3 0.001 #> 2 All          2 Control           100 0.001 #> 3 All          1 Experimental        3 0.001 #> 4 All          2 Experimental      100 0.001 #>  # Stratified example failRates <- tibble::tibble(Stratum=c(rep(\"Low\",3),rep(\"High\",3)),                             duration=rep(c(4,10,100),2),                             failRate=c(.04,.1,.06,                                        .08,.16,.12),                             hr=c(1.5,.5,2/3,                                  2, 10/16, 10/12),                             dropoutRate=.01 ) x <- simfix2simPWSurv(failRates) # Do a single simulation with the above rates # Enroll 300 patients in ~12 months at constant rate sim <-     simPWSurv(n=300,           strata=tibble::tibble(Stratum=c(\"Low\",\"High\"),p=c(.6,.4)),           enrollRates=tibble::tibble(duration=12,rate=300/12),           failRates=x$failRates,           dropoutRates=x$dropoutRates) # Cut after 200 events and do a stratified logrank test dat <- sim %>%        cutDataAtCount(200) %>%            # cut data        tensurv(txval=\"Experimental\") %>%  # convert format for tenFH        tenFH(rg=tibble(rho=0,gamma=0))    # stratified logrank"},{"path":"https://merck.github.io/simtrial/reference/simfix_.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of fixed sample size design for time-to-event endpoint — simfix_","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix_","text":"simfix_() provide simulations single endpoint two-arm trial enrollment, hazard ratio, failure dropout rates change time.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix_","text":"","code":"simfix_(   nsim = 1000,   sampleSize = 500,   targetEvents = 350,   strata = tibble::tibble(Stratum = \"All\", p = 1),   enrollRates = tibble::tibble(duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   totalDuration = 30,   block = rep(c(\"Experimental\", \"Control\"), 2),   timingType = 1:5,   rg = tibble::tibble(rho = 0, gamma = 0) )"},{"path":"https://merck.github.io/simtrial/reference/simfix_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix_","text":"nsim Number simulations perform. sampleSize Total sample size per simulation. targetEvents Targeted event count analysis. strata tibble strata specified Stratum, probability (incidence) stratum p. enrollRates Piecewise constant enrollment rates time period. Note overall population enrollment rates strata argument controls random distribution strata. failRates Piecewise constant control group failure rates, hazard ratio experimental vs control, dropout rates stratum time period. totalDuration Total follow-start enrollment data cutoff. block simtrial:::simPWSurv_(). Vector treatments included block. timingType numeric vector determining data cutoffs used; see details. Default include available cutoff methods. rg simtrial::tenFHCorr(). tibble variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted logrank test per row.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix_","text":"tibble including columns Events (event count), lnhr (log-hazard ratio), Z (normal test statistic; < 0 favors experimental) cut (text describing cutoff used), Duration (duration trial cutoff analysis) sim (sequential simulation id). One row per simulated dataset per cutoff specified timingType, per test statistic specified. multiple Fleming-Harrington tests specified rg, columns rho,gamma also included.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix_","text":"timingType 5 elements indicating different options data cutoff. 1 uses planned study duration, 2 time targeted event count achieved, 3 planned minimum follow-enrollment complete, 4 maximum planned study duration targeted event count cuts (1 2), 5 maximum targeted event count minimum follow-cuts (2 3).","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of fixed sample size design for time-to-event endpoint — simfix_","text":"","code":"library(tidyr) library(dplyr) # Show output structure simtrial:::simfix_(nsim=3) #>    Events       lnhr         Z                              cut Duration Sim #> 1     103 -0.5280793 -2.640435                 Planned duration 30.00000   1 #> 2     350 -0.5034721 -4.651405                  Targeted events 77.59402   1 #> 3     340 -0.5022811 -4.572105                Minimum follow-up 74.70954   1 #> 4     350 -0.5034721 -4.651405 Max(planned duration, event cut) 77.59402   1 #> 5     350 -0.5034721 -4.651405    Max(min follow-up, event cut) 77.59402   1 #> 6      90 -0.5224711 -2.449599                 Planned duration 30.00000   2 #> 7     350 -0.3116702 -2.908206                  Targeted events 72.04140   2 #> 8     370 -0.3165746 -3.037855                Minimum follow-up 76.83469   2 #> 9     350 -0.3116702 -2.908206 Max(planned duration, event cut) 72.04140   2 #> 10    370 -0.3165746 -3.037855    Max(min follow-up, event cut) 76.83469   2 #> 11     92 -0.4185950 -1.988818                 Planned duration 30.00000   3 #> 12    350 -0.5436922 -5.041697                  Targeted events 73.28002   3 #> 13    348 -0.5324415 -4.923599                Minimum follow-up 72.95646   3 #> 14    350 -0.5436922 -5.041697 Max(planned duration, event cut) 73.28002   3 #> 15    350 -0.5436922 -5.041697    Max(min follow-up, event cut) 73.28002   3 # Example with 2 tests: logrank and FH(0,1) simtrial:::simfix_(nsim=1,rg=tibble::tibble(rho=0,gamma=c(0,1))) #>    Events         lnhr rho gamma           Z        V1        V2 #> 1     103  0.009106792   0     0  0.04614088 1.0000000 0.8265539 #> 2     103  0.009106792   0     1  0.41256497 0.8265539 1.0000000 #> 3     350 -0.462403621   0     0 -4.30200199 1.0000000 0.8475055 #> 4     350 -0.462403621   0     1 -4.67850095 0.8475055 1.0000000 #> 5     366 -0.452064433   0     0 -4.30024567 1.0000000 0.8534493 #> 6     366 -0.452064433   0     1 -4.69260307 0.8534493 1.0000000 #> 7     350 -0.462403621   0     0 -4.30200199 1.0000000 0.8475055 #> 8     350 -0.462403621   0     1 -4.67850095 0.8475055 1.0000000 #> 9     366 -0.452064433   0     0 -4.30024567 1.0000000 0.8534493 #> 10    366 -0.452064433   0     1 -4.69260307 0.8534493 1.0000000 #>                                 cut Duration Sim #> 1                  Planned duration 30.00000   1 #> 2                  Planned duration 30.00000   1 #> 3                   Targeted events 69.82225   1 #> 4                   Targeted events 69.82225   1 #> 5                 Minimum follow-up 74.93619   1 #> 6                 Minimum follow-up 74.93619   1 #> 7  Max(planned duration, event cut) 69.82225   1 #> 8  Max(planned duration, event cut) 69.82225   1 #> 9     Max(min follow-up, event cut) 74.93619   1 #> 10    Max(min follow-up, event cut) 74.93619   1 # Power by test # Only use cuts for events, events + min follow-up xx <- simtrial:::simfix_(nsim=100,timingType=c(2,5),rg=tibble::tibble(rho=0,gamma=c(0,1))) # Get power approximation for FH, data cutoff combination xx %>% group_by(cut,rho,gamma) %>% summarise(mean(Z<=qnorm(.025))) #> `summarise()` has grouped output by 'cut', 'rho'. You can override using the #> `.groups` argument. #> # A tibble: 4 × 4 #> # Groups:   cut, rho [2] #>   cut                             rho gamma `mean(Z <= qnorm(0.025))` #>   <chr>                         <dbl> <dbl>                     <dbl> #> 1 Max(min follow-up, event cut)     0     0                      0.96 #> 2 Max(min follow-up, event cut)     0     1                      0.99 #> 3 Targeted events                   0     0                      0.94 #> 4 Targeted events                   0     1                      0.97 # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up p <- xx %>%  filter(cut != \"Targeted events\") %>% group_by(Sim) %>% group_map(pMaxCombo) p <- unlist(p) mean(p<.025) #> [1] 0.98 # MaxCombo estimate for targeted events cutoff p <- unlist(xx %>%  filter(cut == \"Targeted events\") %>% group_by(Sim) %>% group_map(pMaxCombo)) mean(p<.025) #> [1] 0.97"},{"path":"https://merck.github.io/simtrial/reference/simtrial-package.html","id":null,"dir":"Reference","previous_headings":"","what":"simtrial: Clinical Trial Simulation — simtrial-package","title":"simtrial: Clinical Trial Simulation — simtrial-package","text":"simtrial provides basic routines simulating clinical trial. primary intent provide tools generate trial simulations trials time event outcomes. Piecewise exponential failure rates piecewise constant enrollment rates underlying mechanism used simulate broad range scenarios. However, basic generation data done using pipes allow maximum flexibility users meet different needs.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/simtrial-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"simtrial: Clinical Trial Simulation — simtrial-package","text":"Maintainer: Yilong Zhang elong0527@gmail.com Authors: Keaven Anderson keaven_anderson@merck.com contributors: Amin Shirazi ashirazist@gmail.com [contributor] Ruixue Wang ruixue.wang@merck.com [contributor] Yi Cui yi.cui@merck.com [contributor] Ping Yang ping.yang1@merck.com [contributor] Yalin Zhu yalin.zhu@merck.com [contributor] Heng Zhou heng.zhou@merck.com [contributor] Merck & Co., Inc., Rahway, NJ, USA affiliates [copyright holder]","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFH.html","id":null,"dir":"Reference","previous_headings":"","what":"Fleming-Harrington Weighted Logrank Tests — tenFH","title":"Fleming-Harrington Weighted Logrank Tests — tenFH","text":"output function tensurv","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFH.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fleming-Harrington Weighted Logrank Tests — tenFH","text":"","code":"tenFH(   x = simPWSurv(n = 200) %>% cutDataAtCount(150) %>% tensurv(txval = \"Experimental\"),   rg = tibble(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)),   returnVariance = FALSE )"},{"path":"https://merck.github.io/simtrial/reference/tenFH.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fleming-Harrington Weighted Logrank Tests — tenFH","text":"x tensurv-class tibble counting process dataset rg tibble variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted logrank test per row; Default: tibble(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)) returnVariance logical flag , true, adds columns estimated variance weighted sum observed minus expected; see details; Default: FALSE","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFH.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fleming-Harrington Weighted Logrank Tests — tenFH","text":"tibble rg input FH test statistic data x (Z, directional square root usual weighted logrank test); variance calculations specified (e.g., used covariances combination test), returned column Var","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFH.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fleming-Harrington Weighted Logrank Tests — tenFH","text":"input value x produced tensurv() produces counting process dataset grouped strata sorted within strata increasing times events occur. \\(Z\\) - standardized normal Fleming-Harrington weighted logrank test \\(\\)  - stratum index \\(d_i\\) - number distinct times events occurred stratum \\(\\) \\(t_{ij}\\) - ordered times events stratum \\(\\), \\(j=1,2,\\ldots d_i\\) observed; observation, \\(t_{ij}\\) represents time post study entry \\(O_{ij.}\\) - total number events stratum \\(\\) occurred time \\(t_{ij}\\) \\(O_{ije}\\) - total number events stratum \\(\\) experimental treatment group occurred time \\(t_{ij}\\) \\(N_{ij.}\\) - total number study subjects stratum \\(\\) followed least duration \\(E_{ije}\\) - expected observations experimental treatment group given random selection \\(O_{ij.}\\) stratum \\(\\) risk time \\(t_{ij}\\) \\(V_{ije}\\) - hypergeometric variance \\(E_{ije}\\) produced Var tensurv() routine \\(N_{ije}\\) - total number study subjects stratum \\(\\) experimental treatment group followed least duration \\(t_{ij}\\) \\(E_{ije}\\) - expected observations experimental group stratum \\(\\) time \\(t_{ij}\\) conditioning overall number events risk populations time sampling risk observations without replacement: $$E_{ije} = O_{ij.} N_{ije}/N_{ij.}$$ \\(S_{ij}\\) - Kaplan-Meier estimate survival combined treatment groups immediately prior time \\(t_{ij}\\) \\(\\rho, \\gamma\\) - real parameters Fleming-Harrington test \\(X_i\\) - Numerator signed logrank test stratum \\(\\) $$X_i = \\sum_{j=1}^{d_{}} S_{ij}^\\rho(1-S_{ij}^\\gamma)(O_{ije}-E_{ije})$$ \\(V_{ij}\\) - variance used denominator Fleming-Harrington weighted logrank tests $$V_i = \\sum_{j=1}^{d_{}} (S_{ij}^\\rho(1-S_{ij}^\\gamma))^2V_{ij})$$ stratified Fleming-Harrington weighted logrank test computed : $$Z = \\sum_i X_i/\\sqrt{\\sum_i V_i}$$","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFH.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fleming-Harrington Weighted Logrank Tests — tenFH","text":"","code":"library(tidyr) # Use default enrollment and event rates at cut at 100 events x <- simPWSurv(n=200) %>% cutDataAtCount(100) %>% tensurv(txval=\"Experimental\") # compute logrank (FH(0,0)) and FH(0,1) tenFH(x,rg=tibble(rho=c(0,0),gamma=c(0,1))) #> # A tibble: 2 × 3 #>     rho gamma     Z #>   <dbl> <dbl> <dbl> #> 1     0     0 -3.01 #> 2     0     1 -4.14"},{"path":"https://merck.github.io/simtrial/reference/tenFHcorr.html","id":null,"dir":"Reference","previous_headings":"","what":"Fleming-Harrington Weighted Logrank Tests plus Correlations — tenFHcorr","title":"Fleming-Harrington Weighted Logrank Tests plus Correlations — tenFHcorr","text":"Correlations can used mvtnorm::pmvnorm compute p-value MaxCombo, maximum specifed Fleming-Harrington tests","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFHcorr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fleming-Harrington Weighted Logrank Tests plus Correlations — tenFHcorr","text":"","code":"tenFHcorr(   x = simPWSurv(n = 200) %>% cutDataAtCount(100) %>% tensurv(txval = \"Experimental\"),   rg = tibble(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)),   corr = TRUE )"},{"path":"https://merck.github.io/simtrial/reference/tenFHcorr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fleming-Harrington Weighted Logrank Tests plus Correlations — tenFHcorr","text":"x tensurv-class tibble counting process dataset rg tibble variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted logrank test per row corr logical; TRUE (default), return correlation matrix; otherwise, return covariance matrix","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFHcorr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fleming-Harrington Weighted Logrank Tests plus Correlations — tenFHcorr","text":"tibble rg input, FH test statistics specified data Z, correlation covariance matrix tests variables starting V","code":""},{"path":"https://merck.github.io/simtrial/reference/tenFHcorr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fleming-Harrington Weighted Logrank Tests plus Correlations — tenFHcorr","text":"","code":"library(tidyr) library(dplyr) # Use default enrollment and event rates at cut of 100 events x <- simPWSurv(n=200) %>% cutDataAtCount(100) %>% tensurv(txval=\"Experimental\") # compute logrank (FH(0,0)) and FH(0,1) x <- tenFHcorr(rg=tibble(rho=c(0,0),gamma=c(0,1)),x=x) # compute p-value for MaxCombo library(mvtnorm) 1-pmvnorm(lower=rep(min(x$Z),nrow(x)),corr=data.matrix(select(x,-c(rho,gamma,Z))), algorithm=GenzBretz(maxpts=50000,abseps=0.00001))[1] #> [1] 0.0001217593 # check that covariance is as expected x <- simPWSurv(n=200) %>%          cutDataAtCount(100) %>%          tensurv(txval=\"Experimental\") x %>% tenFHcorr(rg=tibble(rho=c(0,0),gamma=c(0,1)),corr=FALSE) #>   rho gamma         Z        V1       V2 #> 1   0     0 -2.286166 24.834847 6.867569 #> 2   0     1 -2.838049  6.867569 2.744544 # Off-diagonal element should be variance in following x %>% tenFHcorr(rg=tibble(rho=0,gamma=.5),corr=FALSE) #>   rho gamma         Z       V1 #> 1   0   0.5 -2.752333 6.867569 # compare off diagonal result with tenFH() x %>% tenFH(rg=tibble(rho=0,gamma=.5)) #> # A tibble: 1 × 3 #>     rho gamma     Z #>   <dbl> <dbl> <dbl> #> 1     0   0.5 -2.75"},{"path":"https://merck.github.io/simtrial/reference/tensurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Process Survival Data into Counting Process Format — tensurv","title":"Process Survival Data into Counting Process Format — tensurv","text":"Produces tibble sorted stratum time. Included times one event occurs. output dataset contains Stratum, tte (time--event), risk count count events specified tte sorted Stratum tte.","code":""},{"path":"https://merck.github.io/simtrial/reference/tensurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process Survival Data into Counting Process Format — tensurv","text":"","code":"tensurv(x, txval)"},{"path":"https://merck.github.io/simtrial/reference/tensurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process Survival Data into Counting Process Format — tensurv","text":"x tibble missing values contain variables Stratum: Stratum Treatment: Treatment group tte: Observed time event: Binary event indicator, 1 represents event, 0 represents censoring txval value input Treatment column indicates treatment group value.","code":""},{"path":"https://merck.github.io/simtrial/reference/tensurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process Survival Data into Counting Process Format — tensurv","text":"tibble grouped Stratum sorted within strata tte. Remain rows least one event population, least one subject risk treatment group control group. variables represent following within stratum time one events observed: events: Total number events txevents: Total number events treatment group atrisk: Number subjects risk txatrisk: Number subjects risk treatment group S: Left-continuous Kaplan-Meier survival estimate OminusE: treatment group, observed number events minus expected number events. expected number events estimated assuming treatment effect hypergeometric distribution parameters total number events, total number events treatment group number events time. (assumption log-rank test null hypothesis) Var: variance OminusE assumption.","code":""},{"path":"https://merck.github.io/simtrial/reference/tensurv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process Survival Data into Counting Process Format — tensurv","text":"function considered two group situation. tie handled Breslow's Method.","code":""},{"path":"https://merck.github.io/simtrial/reference/tensurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process Survival Data into Counting Process Format — tensurv","text":"","code":"library(dplyr)  # Example 1 x=tibble(Stratum = c(rep(1,10),rep(2,6)), Treatment = rep(c(1,1,0,0),4), tte = 1:16, event= rep(c(0,1),8))  tensurv(x, txval=1) #> # A tibble: 6 × 9 #> # Groups:   Stratum [2] #>   Stratum events txevents   tte atrisk txatrisk     S OminusE   Var #>     <dbl>  <dbl>    <dbl> <int>  <dbl>    <int> <dbl>   <dbl> <dbl> #> 1       1      1        1     2      9        5 1       0.444 0.247 #> 2       1      1        0     4      7        4 0.889  -0.571 0.245 #> 3       1      1        1     6      5        3 0.762   0.4   0.24  #> 4       1      1        0     8      3        2 0.610  -0.667 0.222 #> 5       2      1        0    12      5        2 1      -0.4   0.24  #> 6       2      1        1    14      3        1 0.8     0.667 0.222  # Example 2 x <- simPWSurv(n=400) y <- cutDataAtCount(x,150) %>% tensurv(txval = \"Experimental\") # weighted logrank test (Z-value and 1-sided p-value) z <- sum(y$OminusE)/sqrt(sum(y$Var)) c(z,pnorm(z)) #> [1] -1.96110899  0.02493315"},{"path":"https://merck.github.io/simtrial/reference/wMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","title":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","text":"Magirr Burman (2019) proposed weighted logrank test better power logrank test treatment effect delayed, still maintain good power proportional hazards assumption. weights early interval specified user inverse combined treatment group empirical survival distribution; see details. initial period, weights constant maximum previous weights. Another advantage test strong null hypothesis underlying survival control group greater equal underlying survival experimental group, Type error controlled specified level.","code":""},{"path":"https://merck.github.io/simtrial/reference/wMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","text":"","code":"wMB(x, delay = 4)"},{"path":"https://merck.github.io/simtrial/reference/wMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","text":"x tensurv-class tibble counting process dataset delay initial delay period weights increase; , weights constant final weigh delay period","code":""},{"path":"https://merck.github.io/simtrial/reference/wMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","text":"vector weights Magirr-Burman weighted logrank test data x","code":""},{"path":"https://merck.github.io/simtrial/reference/wMB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","text":"function computes Magirr-Burman weights adds dataset created tensurv() function. weights can used compute Z-statistic modestly weighted logrank test proposed. define \\(t^*\\) input variable delay. specifies initial period weights increase. define specific weights, let \\(S(t)\\) denote Kaplan-Meier survival estimate time \\(t\\) combined data (control plus experimental treatment groups). weight time \\(t\\) defined $$w(t)=S(\\min(t,t^*))^{-1}.$$","code":""},{"path":"https://merck.github.io/simtrial/reference/wMB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","text":"Magirr, Dominic, Carl‐Fredrik Burman. \"Modestly weighted logrank tests.\" Statistics Medicine 38.20 (2019): 3782-3790.","code":""},{"path":"https://merck.github.io/simtrial/reference/wMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Magirr and Burman Modestly Weighted Logrank Tests — wMB","text":"","code":"library(tidyr) library(dplyr) # Use default enrollment and event rates at cut at 100 events x <- simPWSurv(n=200) %>% cutDataAtCount(125) %>% tensurv(txval=\"Experimental\") # compute Magirr-Burman weights with ZMB <- x %>% wMB(6) %>%              summarize(S=sum(OminusE*wMB),V=sum(Var*wMB^2),Z=S/sqrt(V)) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$Z) #> [1] 9.090692e-07"},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-020-august-2020","dir":"Changelog","previous_headings":"","what":"simtrial 0.2.0, August, 2020","title":"simtrial 0.2.0, August, 2020","text":"Updated vignettes web site Prepared Regulatory/Industry Training session September","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-0179004-february-2020","dir":"Changelog","previous_headings":"","what":"simtrial 0.1.7.9004, February, 2020","title":"simtrial 0.1.7.9004, February, 2020","text":"Added wMB() compute Magirr-Burman weights Added vignette demonstrate working different weighting schemes Replaced Depends Imports DESCRIPTION","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-0179003-november-2019","dir":"Changelog","previous_headings":"","what":"simtrial 0.1.7.9003, November, 2019","title":"simtrial 0.1.7.9003, November, 2019","text":"Incorporated new functions simplify use (simfix, simfix2simPWSurv, pMaxCombo) Removed hgraph intent put release gsDesign Limited 2 essential vignettes Added continuous integration/continuous deployment (yaml) pkgdown web site development Limited dependencies essential; removed convenience functions related core package functionality","code":""}]
