[{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using the Magirr-Burman weights for testing","text":"Magirr Burman (2019) implemented modestly weighted logrank test following claim: Tests new class can constructed high power delayed-onset treatment effect scenario, well almost efficient standard logrank test proportional hazards. implemented package modestWLRT. Since implementation relatively straightforward, added functionality simtrial package explain use mb_weight() function. Packages used follows:","code":"library(simtrial) library(dplyr) library(survival)"},{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"simulating-a-delayed-effect-example","dir":"Articles","previous_headings":"","what":"Simulating a delayed effect example","title":"Using the Magirr-Burman weights for testing","text":"First, specify study duration, sample size enrollment rates. enrollment rate assumed constant enrollment period targeted sample size reached. failure rates, consider delayed treatment effect example Magirr Burman (2019). control group exponential failure rate median 15 months. initial 6 months, underlying hazard ratio one followed hazard ratio 0.7 thereafter. differs Magirr Burman (2019) delayed effect assumptions assume hazard ratio 0.5 6 months. Now generate single dataset characteristics cut data analysis 36 months post start enrollment. plot Kaplan-Meier curves resulting dataset (red curve experimental treatment, black control):","code":"study_duration <- 36 sample_size <- 300 enroll_rate <- data.frame(duration = 12, rate = 200 / 12) fail_rate <- data.frame(   stratum = c(\"All\", \"All\"),   duration = c(6, 36),   fail_rate = c(log(2) / 15, log(2) / 15),   hr = c(1, .7),   dropout_rate = c(0, 0) ) set.seed(7789) xpar <- simfix2simpwsurv(fail_rate) MBdelay <- sim_pw_surv(   n = sample_size,   stratum = data.frame(stratum = \"All\", p = 1),   block = c(rep(\"control\", 2), rep(\"experimental\", 2)),   enroll_rate = enroll_rate,   fail_rate = xpar$fail_rate,   dropout_rate = xpar$dropout_rate ) |>   cut_data_by_date(study_duration) fit <- survfit(Surv(tte, event) ~ treatment, data = MBdelay) plot(fit, col = 1:2, mark = \"|\", xaxt = \"n\") axis(1, xaxp = c(0, 36, 6))"},{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"generalizing-the-magirr-burman-test","dir":"Articles","previous_headings":"","what":"Generalizing the Magirr-Burman test","title":"Using the Magirr-Burman weights for testing","text":"Next, consider Magirr (2021) extension modestly weighted logrank test (MWLRT) Magirr Burman (2019) weights follows: \\[w(t, \\tau, w_{\\max}) = \\min\\left(w_{\\max},\\left(\\frac{1}{S(\\min(t,\\tau))}\\right)\\right).\\] requires generating weights computing test. begin default w_max=Inf corresponds original Magirr Burman (2019) test set time maximum weight \\(\\tau\\) delay = 6. Now set maximum weight 2 Magirr (2021) set delay=Inf maximum weight begins observed median observed combined treatment Kaplan-Meier curve. Another way can done generalized Fleming-Harrington test \\[w(t; \\rho, \\gamma, w_{\\max})= \\min((1-F(t))^\\rho F(t)^\\gamma, w_{\\max})).\\] let \\(\\gamma=0, \\rho = -1/2.\\)","code":"ZMB <- MBdelay |>   counting_process(arm = \"experimental\") |>   mb_weight(delay = 6) |>   summarize(     S = sum(o_minus_e * mb_weight),     V = sum(var_o_minus_e * mb_weight^2),     z = S / sqrt(V)   ) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$z) #> [1] 0.1395378 ZMB <- MBdelay |>   counting_process(arm = \"experimental\") |>   mb_weight(delay = Inf, w_max = 2) |>   summarize(     S = sum(o_minus_e * mb_weight),     V = sum(var_o_minus_e * mb_weight^2),     z = S / sqrt(V)   ) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$z) #> [1] 0.1387672 w_max <- 2 Z_modified_FH <- MBdelay |>   counting_process(arm = \"experimental\") |>   mutate(w = pmin(w_max, 1 / s)) |>   summarize(     S = sum(o_minus_e * w),     V = sum(var_o_minus_e * w^2),     z = S / sqrt(V)   ) # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(Z_modified_FH$z) #> [1] 0.1387672"},{"path":"https://merck.github.io/simtrial/articles/modest-wlrt.html","id":"freidlin-and-korn-strong-null-hypothesis-example","dir":"Articles","previous_headings":"Generalizing the Magirr-Burman test","what":"Freidlin and Korn strong null hypothesis example","title":"Using the Magirr-Burman weights for testing","text":"next example, underlying survival uniformly worse experimental group compared control throughout planned follow-. presented Freidlin Korn (2019). case, hazard ratio 16 1/10 1 year (1.2 months), followed hazard ratio 0.76 thereafter. First, specify study duration, sample size enrollment rates. enrollment rate assumed constant enrollment period targeted sample size reached. failure rates, consider delayed treatment effect example Magirr Burman (2019). Now generate single dataset characteristics cut data analysis 5 years post start enrollment. plot Kaplan-Meier curves resulting dataset (red curve experimental treatment, black control):  perform logrank weighted logrank tests suggested limited downweighting follows: Now MaxCombo test component tests, p-value Next, consider Magirr Burman (2019) modestly weighted logrank test -weighting specified first 6 months maximum weight 2. requires generating weights computing test. Finally, consider weighted logrank tests less -weighting. Results quite similar results greater -weighting. Now MaxCombo test component tests, p-value Thus, less -weighting MaxCombo test appears less problematic. addressed greater length Mukhopadhyay et al. (2022).","code":"study_duration <- 5 sample_size <- 2000 enroll_duration <- .0001 enroll_rate <- data.frame(   duration = enroll_duration,   rate = sample_size / enroll_duration ) fail_rate <- data.frame(   stratum = \"All\",   fail_rate = 0.25,   dropout_rate = 0,   hr = c(4 / .25, .19 / .25),   duration = c(.1, 4.9) ) set.seed(7783) xpar <- simfix2simpwsurv(fail_rate) FHwn <- sim_pw_surv(   n = sample_size,   stratum = data.frame(stratum = \"All\", p = 1),   block = c(rep(\"control\", 2), rep(\"experimental\", 2)),   enroll_rate = enroll_rate,   fail_rate = xpar$fail_rate,   dropout_rate = xpar$dropout_rate ) |>   cut_data_by_date(study_duration) fit <- survfit(Surv(tte, event) ~ treatment, data = FHwn) plot(fit, col = 1:2, mark = \"|\", xaxt = \"n\") axis(1, xaxp = c(0, 36, 6)) xx <- FHwn |>   counting_process(arm = \"experimental\") |>   fh_weight(     rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 1)),     return_corr = TRUE   ) |>   mutate(p = pnorm(z)) xx #>   rho gamma         z        v1        v2        v3 #> 1   0     0  4.808526 1.0000000 0.8652115 0.9356769 #> 2   0     1 -3.204735 0.8652115 1.0000000 0.9580098 #> 3   1     1 -1.220445 0.9356769 0.9580098 1.0000000 #>              p #> 1 0.9999992398 #> 2 0.0006759349 #> 3 0.1111481087 xx |> pvalue_maxcombo() #> [1] 0.001256683 ZMB <- FHwn |>   counting_process(arm = \"experimental\") |>   mb_weight(delay = 6, w_max = 2) |>   summarize(     S = sum(o_minus_e * mb_weight),     V = sum(var_o_minus_e * mb_weight^2),     z = S / sqrt(V)   )  # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$z) #> [1] 0.920727 xx <- FHwn |>   counting_process(arm = \"experimental\") |>   fh_weight(     rho_gamma = data.frame(rho = c(0, 0, .5), gamma = c(0, .5, .5)),     return_corr = TRUE   ) |>   mutate(p = pnorm(z)) xx #>   rho gamma          z        v1        v2        v3 #> 1 0.0   0.0  4.8085258 1.0000000 0.9421013 0.9709414 #> 2 0.0   0.5 -0.6919228 0.9421013 1.0000000 0.9872682 #> 3 0.5   0.5  0.9278452 0.9709414 0.9872682 1.0000000 #>           p #> 1 0.9999992 #> 2 0.2444929 #> 3 0.8232561 xx |> pvalue_maxcombo() #> [1] 0.2915952"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Simulating time-to-event trials in parallel","text":"vignette demonstrates ability implement sim_fixed_n() using user-defined backends parallelize simulations. consider backends supported future framework. backends supported future package include: sequential - default non-parallel backend. multisession - uses multiple background R sessions single machine. multicore - uses multiple forked R processes single non-Windows machine outside RStudio. cluster - supports external R sessions across multiple machines. can also choose backend types supported additional future extension packages, HPC job scheduler backends future.batchtools. function sim_fixed_n() provides simulation workflow two-arm trial single endpoint. can vary parameters trial using different functions outlined documentation. function now provides users opportunity implement simulations using previously described parallel backends accelerate computation.","code":""},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Simulating time-to-event trials in parallel","text":"Without specifying backend, sim_fixed_n() execute sequentially. sequential execution run n_sim iterations within process session R. order execute parallel, must define environment prior calling function. Setting seed prior calling function ensure results reproducible. Suppose want investigate duration trial two possible enrollments strategies. enrollments piecewise, varying durations rates.  see Enrollment 2 enrolls individuals quickly Enrollment 1 onset. Later, Enrollment 1 outpace Enrollment 2 eventually overtaken . , want consider duration study changes enrollments.","code":"library(simtrial) library(future) library(doFuture) set.seed(1)  n <- 5000 enroll_rate1 <- data.frame(rate = c(5, 20, 10), duration = c(100, 150, 150)) enroll_rate2 <- data.frame(rate = c(10, 15, 30), duration = c(150, 175, 75)) x1 <- rpw_enroll(n = n, enroll_rate = enroll_rate1) x2 <- rpw_enroll(n = n, enroll_rate = enroll_rate2)  plot(   x1, 1:n,   type = \"l\",   col = palette()[4],   xlim = c(0, max(x1, x2)),   main = \"Piecewise enrollments\",   xlab = \"Time\",   ylab = \"Enrollment\" ) lines(x2, 1:n, col = palette()[7]) legend(   250, 1500,   legend = c(\"Enrollment 1\", \"Enrollment 2\"),   col = c(palette()[4], palette()[7]),   lty = c(1, 1) )"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"the-sequential-run","dir":"Articles","previous_headings":"","what":"The sequential run","title":"Simulating time-to-event trials in parallel","text":"Naively, can execute simulations sequentially. set target total enrollment 3000 individuals trial ending observing 700 events. use timing_type = 2 return correct trial duration. message automatically appears console indicates backend used processing. calls proc.time() allow us evaluate computation time procedures. function provides three outputs, focus user elapsed time. User time represents CPU time spent evaluating function elapsed time represents “wall clock” time spent end user waiting results. can see CPU time 13.60 elapsed time 7.81 seconds. provide baseline computation time. may anticipated, see lower number events, enrollment 2 shorter average duration 99.8 enrollment 1, 131.2. also see distinction duration study proposed enrollment strategies.","code":"set.seed(1)  n_sim <- 200  start_sequential <- proc.time()  seq_result1 <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate1,   timing_type = 2 # Time until targeted event count achieved ) #> Backend uses sequential processing.  seq_result2 <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate2,   timing_type = 2 # Time until targeted event count achieved ) #> Backend uses sequential processing.  duration_sequential <- proc.time() - start_sequential print(duration_sequential) #>    user  system elapsed  #>  13.600   0.102   7.808"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"setting-up-a-parallel-backend","dir":"Articles","previous_headings":"","what":"Setting up a parallel backend","title":"Simulating time-to-event trials in parallel","text":"instead, wanted run simulations enrollment, can expect time run simulations increase. vary increase number parameter inputs consider, expect simulation process continue increase duration. help combat growing computational burden, can run simulations parallel using multisession backend available us plan(). can adjust default number cores function parallelly::availableCores(). multisession backend automatically use available cores default, use two. initialize backend, change plan.","code":"plan(multisession, workers = 2)"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"execution-in-parallel","dir":"Articles","previous_headings":"","what":"Execution in parallel","title":"Simulating time-to-event trials in parallel","text":"configured backend details, can execute code automatically distribute n_sim simulations across available cores. can see CPU time 0.41 elapsed time 8.18 seconds. user time appears drastically reduced R keeps track time; time used parent process children processes reported user time. Therefore, compare elapsed time see real-world impact parallelization. change implementation back sequential backend, simply use . can also verify simulation results identical setting seed backend type affect results. , clear results sequential multisession backends match completely. Note: parallel implementation may always faster serial implementation. substantial overhead associated executing parallel, sequential evaluation may faster. low number simulations available cores, may preferable continue computation serial rather parallel. leave end user determine difference based resources available .","code":"set.seed(1)  start_sequential <- proc.time()  seq_result1m <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate1,   timing_type = 2 # Time until targeted event count achieved ) #> Using 2 cores with backend multisession  seq_result2m <- sim_fixed_n(   n_sim = n_sim,   sample_size = 3000,   target_event = 700,   enroll_rate = enroll_rate2,   timing_type = 2 # Time until targeted event count achieved ) #> Using 2 cores with backend multisession  duration_sequential <- proc.time() - start_sequential print(duration_sequential) #>    user  system elapsed  #>   0.411   0.008   8.177 plan(sequential) sum(seq_result1 != seq_result1m) #> [1] 0 sum(seq_result2 != seq_result2m) #> [1] 0"},{"path":"https://merck.github.io/simtrial/articles/parallel.html","id":"a-nested-parallel-example","dir":"Articles","previous_headings":"","what":"A nested parallel example","title":"Simulating time-to-event trials in parallel","text":"provide additional example using nested parallel structure users extensive resources, high-performance computing clusters, available . resources commonly available, execute code herein. Consider two accessible nodes, three cores (shown diagram ). Available resource schematic. Ideally, available resources used executing simulations. , need correctly define backend using plan() run code previously. different structures, topologies, backend can changed depth explanation given future topologies vignette. example follows closely example. snippet, consider two nodes named n1 n2 create function select number cores use named nodes. trivial , courteous user shared machines specify fewer available cores can using modification code. implement backend using list follows hierarchy available resources. function tweak() necessary override inherent protection nested parallelism, meant help avoid overloading one’s resources errantly starting many processes. need tweak backends, message echoed console nested backends reflects highest level nested hierarchy. backend place, can run identical code using available resources return results . , reset plan sequential avoid accidentally continuing execute later calls within resources.","code":"nodes <- c(\"n1\", \"n2\") custom_cores <- function() {   switch(Sys.info()[[\"nodename\"]],     \"n1\" = 3L, # Modify here for number of cores on node1     \"n2\" = 3L, # Modify here for number of cores on node2     ## Default:     availableCores()   ) } plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = custom_cores) )) set.seed(1)  enroll_rates <- list(enroll_rate1, enroll_rate2)  seq_resultc <- foreach::foreach(   i = 1:2,   .combine = \"list\",   .options.future = list(seed = TRUE) ) %dofuture% {   sim_fixed_n(     n_sim = n_sim,     sample_size = 3000,     target_event = 700,     enroll_rate = enroll_rates[[i]],     timing_type = 2 # Time until targeted event count achieved   ) } plan(sequential)"},{"path":"https://merck.github.io/simtrial/articles/pvalue-maxcombo.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"vignette demonstrates use simple routine simulations testing using Fleming-Harrington weighted logrank tests MaxCombo test. addition, demonstrate perform tests dataset generated simulation routines within package. Note \\(p\\)-values computed one-sided small values indicating experimental treatment favored.","code":""},{"path":"https://merck.github.io/simtrial/articles/pvalue-maxcombo.html","id":"defining-the-test","dir":"Articles","previous_headings":"","what":"Defining the test","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"MaxCombo test posed maximum multiple Fleming-Harrington weighted logrank tests (Harrington Fleming (1982), Fleming Harrington (2011)). Combination tests looking maximum selected tests class also proposed; see Lee (2007), Roychoudhury et al. (2021), Lin et al. (2020). Fleming-Harrington class indexed parameters \\(\\rho\\ge 0\\) \\(\\gamma\\ge 0\\). denote FH(\\(\\rho, \\gamma\\)). class includes logrank test FH(0, 0). tests interest include: FH(0, 1): test -weights early events FH(1, 0): test -weights late events FH(1, 1): test -weights events increasingly quantiles differ median","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/pvalue-maxcombo.html","id":"generating-test-statistics-with-sim_fixed_n","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Generating test statistics with sim_fixed_n()","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"begin single trial simulation generated routine sim_fixed_n() using default arguments routine. sim_fixed_n() produces one record per test data cutoff method per simulation. choose 3 tests (logrank = FH(0, 0), FH(0, 1) FH(1, 1)). one test chosen correlation tests computed shown Karrison (2016), case columns V1, V2, V3. columns rho, gamma indicate \\(\\rho\\) \\(\\gamma\\) used compute test. z FH(\\(\\rho, \\gamma\\)) normal test statistic variance 1 negative value favoring experimental treatment. variable cut indicates data cut analysis, case maximum targeted minimum follow-last enrollment date targeted event count reached. Sim sequential index simulations performed. format, MaxCombo \\(p\\)-value per Karrison (2016), Roychoudhury et al. (2021) can computed follows (note need package mvtnorm installed):","code":"library(simtrial) library(knitr) library(dplyr) x <- sim_fixed_n(   n_sim = 1,   timing_type = 5,   rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 1)) ) #> Backend uses sequential processing. #> Loading required package: foreach #> Loading required package: future x |> kable(digits = 2) pvalue_maxcombo(x) #> [1] 2.948989e-08"},{"path":"https://merck.github.io/simtrial/articles/pvalue-maxcombo.html","id":"generating-data-with-sim_pw_surv","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Generating data with sim_pw_surv()","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"begin another simulation generated sim_pw_surv(). , use defaults routine. generated, need cut data analysis. cut 75 events. Now can analyze data. begin s show can done single line. case, use 4 test combination suggested Lin et al. (2020), Roychoudhury et al. (2021). Now compute \\(p\\)-value : Suppose want \\(p\\)-value just based logrank FH(0, 1) FH(1, 0) suggested Lee (2007). remove rows columns associated FH(0, 0) FH(1, 1) apply pvalue_maxcombo().","code":"s <- sim_pw_surv(n = 100) head(s) |> kable(digits = 2) x <- s |> cut_data_by_event(75) head(x) |> kable(digits = 2) z <- s |>   cut_data_by_event(75) |>   counting_process(arm = \"experimental\") |>   fh_weight(     rho_gamma = data.frame(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)),     return_corr = TRUE   ) z |> kable(digits = 2) pvalue_maxcombo(z) #> [1] 0.7314703 pvalue_maxcombo(   z |>     select(-c(v1, v4)) |>     filter((rho == 0 & gamma == 1) | (rho == 1 & gamma == 0)) ) #> [1] 0.7497603"},{"path":"https://merck.github.io/simtrial/articles/pvalue-maxcombo.html","id":"using-survival-data-in-another-format","dir":"Articles","previous_headings":"Executing for a single dataset","what":"Using survival data in another format","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"trial generated sim_fixed_n(), process slightly involved. consider survival data simtrial format show transformation needed. case use small aml dataset survival package. rename variables create stratum variable follows: Now analyze data MaxCombo logrank FH(0, 1) compute \\(p\\)-value.","code":"library(survival) head(aml) |> kable() x <- aml |> transmute(   tte = time,   event = status,   stratum = \"All\",   treatment = as.character(x) ) head(x) |> kable() x |>   counting_process(arm = \"Maintained\") |>   fh_weight(     rho_gamma = data.frame(rho = 0, gamma = c(0, 1)),     return_corr = TRUE   ) |>   pvalue_maxcombo() #> [1] 0.0491509"},{"path":"https://merck.github.io/simtrial/articles/pvalue-maxcombo.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Computing p-values for Fleming-Harrington weighted logrank tests and the MaxCombo test","text":"now consider example simulation pvalue_maxcombo() help file demonstrate simulate power MaxCombo test. However, increase number simulations 100 case; larger number used (e.g., 1000) better estimate design properties. test \\(\\alpha=0.001\\) level. note use group_map produces list \\(p\\)-values simulation. nice something worked like dplyr::summarize() avoid unlist() allow evaluating, say, multiple data cutoff methods. latter can done without re-run simulations follows, demonstrated smaller number simulations. Now compute \\(p\\)-value separately cut type, first targeted event count. Now use later targeted events minimum follow-cutoffs.","code":"# Only use cut events + min follow-up xx <- sim_fixed_n(   n_sim = 100,   timing_type = 5,   rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 1)) ) # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up p <- xx |>   group_by(sim) |>   group_map(~ pvalue_maxcombo(.x)) |>   unlist() mean(p < .001) #> [1] 0.8 # Only use cuts for events and events + min follow-up xx <- sim_fixed_n(   n_sim = 100,   timing_type = c(2, 5),   rho_gamma = data.frame(rho = 0, gamma = c(0, 1)) ) head(xx) |> kable(digits = 2) # Subset to targeted events cutoff tests p <- xx |>   filter(cut == \"Targeted events\") |>   group_by(sim) |>   group_map(~ pvalue_maxcombo(.x)) |>   unlist() mean(p < .025) #> [1] 0.99 # Subset to targeted events cutoff tests p <- xx |>   filter(cut != \"Targeted events\") |>   group_by(sim) |>   group_map(~ pvalue_maxcombo(.x)) |>   unlist() mean(p < .025) #> [1] 1"},{"path":[]},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Basic tools for time-to-event trial simulation and testing","text":"vignette demonstrates lower-level routines simtrial package specifically related trial generation statistical testing. routines follows: randomize_by_fixed_block() - fixed block randomization rpw_enroll() - random inter-arrival times piecewise constant enrollment rates rpwexp() - piecewise exponential failure rate generation cut_data_by_date() - cut data analysis specified calendar time cut_data_by_event() - cut data analysis specified event count, including ties cutoff date get_cut_date_by_event() - find date event count reached counting_process() - pre-process survival data counting process format Application demonstrated using higher-level routines sim_pw_surv() sim_fixed_n() generate simulations weighted logrank analysis stratified design. intent write routines spirit tidyverse approach (alternately referred data wrangling, tidy data, R Data Science, split-apply-combine). objectives easily documentable validated package easy use efficient broadly-useful tool simulation time--event clinical trials. package extended many ways future, including: Weighted logrank weighted Kaplan-Meier analyses One-step, hazard ratio estimator (first-order approximation PH) Randomization schemes stratified, fixed-block Poisson mixture survival distribution generation","code":"library(simtrial) library(knitr) library(dplyr)"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"randomization","dir":"Articles","previous_headings":"","what":"Randomization","title":"Basic tools for time-to-event trial simulation and testing","text":"Fixed block randomization arbitrary block contents performed demonstrated . case block size 5 one string repeated twice block three strings appearing . normally, default blocks size four:","code":"randomize_by_fixed_block(n = 10, block = c(\"A\", \"Dog\", \"Cat\", \"Cat\")) #>  [1] \"Dog\" \"Cat\" \"Cat\" \"A\"   \"Cat\" \"Cat\" \"A\"   \"Dog\" \"Dog\" \"A\" randomize_by_fixed_block(n = 20) #>  [1] 1 0 0 1 1 0 0 1 0 1 1 0 1 0 1 0 0 1 0 1"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"enrollment","dir":"Articles","previous_headings":"","what":"Enrollment","title":"Basic tools for time-to-event trial simulation and testing","text":"Piecewise constant enrollment can randomly generated follows. Note duration specifies interval durations constant rates; final rate extended long needed generate specified number observations.","code":"rpw_enroll(   n = 20,   enroll_rate = data.frame(     duration = c(1, 2),     rate = c(2, 5)   ) ) #>  [1] 1.421205 1.521615 1.709163 1.907934 1.928275 2.236364 2.303678 2.374594 #>  [9] 2.489750 2.553446 2.649585 2.832630 3.456009 3.550144 3.576612 4.129567 #> [17] 4.248655 4.315452 4.683225 4.715158"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"time-to-event-and-time-to-dropout","dir":"Articles","previous_headings":"","what":"Time-to-event and time-to-dropout","title":"Basic tools for time-to-event trial simulation and testing","text":"Time--event time--dropout random number generation observations generated piecewise exponential failure times. large number observations, log-plot time--failure","code":"x <- rpwexp(   10000,   fail_rate = data.frame(     rate = c(1, 3, 10),     duration = c(.5, .5, 1)   ) ) plot(   sort(x),   (10000:1) / 10001,   log = \"y\",   main = \"PW Exponential simulated survival curve\",   xlab = \"Time\", ylab = \"P{Survival}\" )"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"generating-a-trial","dir":"Articles","previous_headings":"","what":"Generating a trial","title":"Basic tools for time-to-event trial simulation and testing","text":"Ideally, might done routine generation randomization, time--event data done modular fashion plugged general trial generation routine. now, stratified randomization, piecewise constant enrollment, fixed block randomization piecewise exponential failure rates support flexible set trial generation options time--event endpoint trials. present, follow format carefully little checking input developed -date. methods used demonstrated , combined single routine generate trial. Note generated output dataset, cte calendar time event dropout, whichever comes first, fail indicator cte represents event time. First set input variables make later call sim_pw_surv() straightforward read.","code":"stratum <- data.frame(stratum = c(\"Negative\", \"Positive\"), p = c(.5, .5))  block <- c(rep(\"control\", 2), rep(\"experimental\", 2))  enroll_rate <- data.frame(rate = c(3, 6, 9), duration = c(3, 2, 1))  fail_rate <- data.frame(   stratum = c(rep(\"Negative\", 4), rep(\"Positive\", 4)),   period = rep(1:2, 4),   treatment = rep(c(rep(\"control\", 2), rep(\"experimental\", 2)), 2),   duration = rep(c(3, 1), 4),   rate = log(2) / c(4, 9, 4.5, 10, 4, 9, 8, 18) ) dropout_rate <- data.frame(   stratum = c(rep(\"Negative\", 4), rep(\"Positive\", 4)),   period = rep(1:2, 4),   treatment = rep(c(rep(\"control\", 2), rep(\"experimental\", 2)), 2),   duration = rep(c(3, 1), 4),   rate = rep(c(.001, .001), 4) ) x <- sim_pw_surv(   n = 400,   stratum = stratum,   block = block,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   dropout_rate = dropout_rate ) head(x) |> kable(digits = 2)"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"cutting-data-for-analysis","dir":"Articles","previous_headings":"","what":"Cutting data for analysis","title":"Basic tools for time-to-event trial simulation and testing","text":"two ways cut data generated dataset x . first uses calendar cutoff date. output includes time randomization event dropout (tte), indicator represents event (event), stratum observation generated (stratum) treatment group assigned (treatment). Observations enrolled input cut_date deleted events censoring x cut_date censored specified cut_date. instance, wish cut entire dataset 50 events observed Positive stratum can use get_cut_date_by_event function follows: Perhaps common way cut data event count overall population, done using cut_data_by_event function. Note tied events date cte count reached, included. Also, count never reached, event times included cut - indication error.","code":"y <- cut_data_by_date(x, cut_date = 5)  head(y) |> kable(digits = 2) cut50Positive <- get_cut_date_by_event(filter(x, stratum == \"Positive\"), 50) y50Positive <- cut_data_by_date(x, cut50Positive)  with(y50Positive, table(stratum, event)) #>           event #> stratum     0  1 #>   Negative 40 56 #>   Positive 54 50 y150 <- cut_data_by_event(x, 150) table(y150$event, y150$treatment) #>     #>     control experimental #>   0      42           61 #>   1      84           66"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"generating-a-counting-process-dataset","dir":"Articles","previous_headings":"","what":"Generating a counting process dataset","title":"Basic tools for time-to-event trial simulation and testing","text":"cut data analysis, can create dataset simple use weighted logrank tests. slightly complex version developed future enable Kaplan-Meier-based tests. take dataset y150 process format. counting process format discussed next section compute weighted logrank test.","code":"ten150 <- counting_process(y150, arm = \"experimental\")  head(ten150) |> kable(digits = 2)"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"logrank-and-weighted-logrank-testing","dir":"Articles","previous_headings":"","what":"Logrank and weighted logrank testing","title":"Basic tools for time-to-event trial simulation and testing","text":"Now stratified logrank stratified weighted logrank tests easily generated based counting process format. record counting process dataset represents tte one events occurs; results stratum-specific. Included observation number events overall (events) experimental treatment group (txevents), number risk overall (atrisk) experimental treatment group (txatrisk) just tte, combined treatment group Kaplan-Meier survival estimate (left-continuous) tte, observed events experimental group minus expected tte based assumption risk observations equally likely event time, variance quantity (Var). generate stratified logrank test corresponding one-sided p-value, simply following: Fleming-Harrington \\(\\rho=1\\), \\(\\gamma=2\\) nearly simple. compute z-statistic corresponding one-sided p-value. Fleming-Harrington tests, routine built tests : wanted take minimum MaxCombo test, first use fh_weight() compute correlation matrix z-statistics follows. Note ordering rho_gamma g argument list opposite . correlation matrix z-values now V1-V4. can compute p-value MaxCombo follows using mvtnorm::pmvnorm(). Note arguments GenzBretz() stringent defaults; also used stringent parameters example help file.","code":"z <- with(ten150, sum(o_minus_e) / sqrt(sum(var_o_minus_e))) c(z, pnorm(z)) #> [1] -2.2173791  0.0132986 xx <- mutate(ten150, w = s * (1 - s)^2) z <- with(xx, sum(o_minus_e * w) / sum(sqrt(var_o_minus_e * w^2))) c(z, pnorm(z)) #> [1] -0.2577106  0.3983151 fh_weight(   x = ten150,   rho_gamma = data.frame(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)) ) |> kable(digits = 2) x <- ten150 |>   fh_weight(     rho_gamma = data.frame(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)),     return_corr = TRUE   ) x |> kable(digits = 2) # Compute p-value for MaxCombo pvalue_maxcombo(x) #> [1] 0.009263286"},{"path":"https://merck.github.io/simtrial/articles/routines.html","id":"simplification-for-2-arm-trials","dir":"Articles","previous_headings":"","what":"Simplification for 2-arm trials","title":"Basic tools for time-to-event trial simulation and testing","text":"sim_fixed_n() routine combines much go straight generating tests individual trials cutting data analyzing need done separately. argument structure meant simpler sim_pw_surv(). Now simulate trial 2 times cut data analysis based timing_type = 1:5 translates : planned study duration, targeted event count achieved, planned minimum follow-enrollment complete, maximum 1 2, maximum 2 3. look carefully, asking cutoff planned number events different data cutoff methods. explain, note generally want sample_size match enrollment specified enroll_rate: targeted enrollment takes, average, 30 months longer sum enrollment durations enroll_rate (14 months) input enrollment rates. achieve input sample_size 500, final enrollment rate assumed steady state extends simulation targeted enrollment achieved. planned duration trial taken 30 months specified total_duration. targeted minimum follow-thus, implicit last subject enrolled 16 months prior duration given cutoff “Minimum follow-” cutoff simulations . planned duration cutoff given total_duration argument results much earlier cutoff.","code":"stratum <- data.frame(stratum = \"All\", p = 1) enroll_rate <- data.frame(   duration = c(2, 2, 10),   rate = c(3, 6, 9) ) fail_rate <- data.frame(   stratum = \"All\",   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(0.9, 0.6),   dropout_rate = rep(0.001, 2) ) block <- rep(c(\"experimental\", \"control\"), 2) rho_gamma <- data.frame(rho = 0, gamma = 0) sim_fixed_n(   n_sim = 2, # Number of simulations   sample_size = 500, # Trial sample size   target_event = 350, # Targeted events at analysis   stratum = stratum, # Study stratum   enroll_rate = enroll_rate, # Enrollment rates   fail_rate = fail_rate, # Failure rates   total_duration = 30, # Planned trial duration   block = block, # Block for treatment   timing_type = 1:5, # Use all possible data cutoff methods   rho_gamma = rho_gamma # FH test(s) to use; in this case, logrank ) |> kable(digits = 2) #> Backend uses sequential processing. #> Loading required package: foreach #> Loading required package: future enroll_rate |> summarize(   \"Targeted enrollment based on input enrollment rates\" = sum(duration * rate) ) #>   Targeted enrollment based on input enrollment rates #> 1                                                 108 total_duration <- 30 # From above total_duration - sum(enroll_rate$duration) #> [1] 16"},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"TTE simulation data manipulations","text":"attempt provide big picture view involved clinical trial simulation individual time--event data generated patient. Primary interest group sequential trials, usually single endpoint. However extensions made.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"results-data-table","dir":"Articles","previous_headings":"","what":"Results data table","title":"TTE simulation data manipulations","text":"time simulation planning analysis plan trial needed. group sequential design, data table store results generated. Generally, dimensions variables planned storage planned front. simple example, group sequential design 3 analyses planned, 15 data items analysis 10,000 simulations planned, data table 30,000 rows 15 columns used store summary results. trial simulation proceeds, row updated results analysis.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"simulated-trial-dataset-generation","dir":"Articles","previous_headings":"","what":"Simulated trial dataset generation","title":"TTE simulation data manipulations","text":"simulated trial, initial table generated information patient level. trials generated sequentially, space needed data table re-used, never requiring allocation space. row contains data single patient. example, simulate trial 500 patients 10 data items per patients. data items columns, patients rows.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"dataset-manipulations-for-analysis","dir":"Articles","previous_headings":"","what":"Dataset manipulations for analysis","title":"TTE simulation data manipulations","text":"Simulated trial data need manipulated individual analysis (interim final) clinical trial. following operations needed: Ordering data Selecting subset analysis Calculating individual patient results subset time analysis. Number subjects treatment group Number events treatment group Kaplan-Meier estimation survival curves Observed minus expected computations well weighting logrank, weighted logrank calculations. Using survival package compute hazard ratio estimates.","code":""},{"path":"https://merck.github.io/simtrial/articles/workflow.html","id":"flow-for-simulating-group-sequential-one-scenario-algorithm","dir":"Articles","previous_headings":"","what":"Flow for simulating group sequential: one scenario algorithm","title":"TTE simulation data manipulations","text":"Group sequential design simulation flow: Generate trial. Analyze repeatedly. Summarize across simulated trials.","code":""},{"path":"https://merck.github.io/simtrial/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Keaven Anderson. Author. Yilong Zhang. Author. Yujie Zhao. Contributor, maintainer. Nan Xiao. Contributor. Jianxiao Yang. Contributor. Lili Ling. Contributor. Xintong Li. Contributor. Ruixue Wang. Contributor. Yi Cui. Contributor. Ping Yang. Contributor. Yalin Zhu. Contributor. Heng Zhou. Contributor. Amin Shirazi. Contributor. Cole Manschot. Contributor. John Blischak. Contributor. Merck & Co., Inc., Rahway, NJ, USA affiliates. Copyright holder.","code":""},{"path":"https://merck.github.io/simtrial/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson K, Zhang Y (2023). simtrial: Clinical Trial Simulation. R package version 0.3.0.7, https://github.com/Merck/simtrial, https://merck.github.io/simtrial/.","code":"@Manual{,   title = {simtrial: Clinical Trial Simulation},   author = {Keaven Anderson and Yilong Zhang},   year = {2023},   note = {R package version 0.3.0.7, https://github.com/Merck/simtrial},   url = {https://merck.github.io/simtrial/}, }"},{"path":"https://merck.github.io/simtrial/index.html","id":"simtrial","dir":"","previous_headings":"","what":"Clinical Trial Simulation","title":"Clinical Trial Simulation","text":"simtrial fast extensible clinical trial simulation framework time--event endpoints.","code":""},{"path":"https://merck.github.io/simtrial/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Clinical Trial Simulation","text":"can install GitHub:","code":"remotes::install_github(\"Merck/simtrial\")"},{"path":"https://merck.github.io/simtrial/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Clinical Trial Simulation","text":"simtrial R package built initially focus evaluating weighted logrank tests combination tests based tests. simtrial designed core philosophy basing computations efficient table transformations package easy qualify use regulated environments. utilizes blazingly fast data.table tabular data processing, enhanced C++ implementations ensure optimal performance. Initial areas focus : Generating time--event data stratified trials using piecewise constant enrollment piecewise exponential failure rates. proportional non-proportional hazards supported. proportional hazards, assumptions along lines used Lachin Foulkes implemented gsDesign deriving group sequential designs. Setting data cutoffs (interim final) analyses. Support weighted logrank tests arbitrary weighting schemes, specifically supporting Fleming-Harrington set tests, including logrank test.","code":""},{"path":"https://merck.github.io/simtrial/index.html","id":"future-developments","dir":"","previous_headings":"","what":"Future developments","title":"Clinical Trial Simulation","text":"Expectations future development include: Provide test suite document package fit use regulatory environment. examples.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"","code":"data(Ex1delayedEffect)"},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187--198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex1delayedEffect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 1 for non-proportional hazards working group — Ex1delayedEffect","text":"","code":"library(survival)  data(Ex1delayedEffect) km1 <- with(Ex1delayedEffect, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 121     86   5.04    4.18    6.21 #> trt=1 240    132   7.66    6.54    9.48 plot(km1)  with(subset(Ex1delayedEffect, trt == 1), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 240    132   7.66    6.54    9.48 with(subset(Ex1delayedEffect, trt == 0), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 121     86   5.04    4.18    6.21"},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"","code":"data(Ex2delayedEffect)"},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187--198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex2delayedEffect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 2 for non-proportional hazards working group — Ex2delayedEffect","text":"","code":"library(survival)  data(Ex2delayedEffect) km1 <- with(Ex2delayedEffect, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 137    123   2.84    2.18    3.50 #> trt=1 135    105   3.45    2.13    5.07 plot(km1)  with(subset(Ex2delayedEffect, trt == 1), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 135    105   3.45    2.13    5.07 with(subset(Ex2delayedEffect, trt == 0), survfit(Surv(month, evntd) ~ trt)) #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> [1,] 137    123   2.84    2.18     3.5"},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"","code":"data(Ex3curewithph)"},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187--198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex3curewithph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 3 for non-proportional hazards working group — Ex3curewithph","text":"","code":"library(survival)  data(Ex3curewithph) km1 <- with(Ex3curewithph, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 137    101   1.05   0.523    1.74 #> trt=1 143     86   1.74   1.158    3.13 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"","code":"data(Ex4belly)"},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187--198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex4belly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 4 for non-proportional hazards working group — Ex4belly","text":"","code":"library(survival)  data(Ex4belly) km1 <- with(Ex4belly, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 387    339   5.40    4.61    5.55 #> trt=1 387    327   6.42    5.81    6.91 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"","code":"data(Ex5widening)"},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187--198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex5widening.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 5 for non-proportional hazards working group — Ex5widening","text":"","code":"library(survival)  data(Ex5widening) km1 <- with(Ex5widening, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>        n events median 0.95LCL 0.95UCL #> trt=0 79     65   8.16    6.65    10.3 #> trt=1 86     48  19.97   17.07    26.6 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"Survival objects reverse-engineered datasets published Kaplan-Meier curves. Individual trials de-identified since data approximations actual data. Data intended evaluate methods designs trials non-proportional hazards may anticipated outcome data.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"","code":"data(Ex6crossing)"},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"Data frame 4 variables: id: Sequential numbering unique identifiers. month: Time--event. event: 1 event, 0 censored. trt: 1 experimental, 0 control.","code":""},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"Lin, Ray S., Ji Lin, Satrajit Roychoudhury, Keaven M. Anderson, Tianle Hu, Bo Huang, Larry F Leon, Jason J.Z. Liao, Rong Liu, Xiaodong Luo, Pralay Mukhopadhyay, Rui Qin, Kay Tatsuoka, Xuejing Wang, Yang Wang, Jian Zhu, Tai-Tsang Chen, Renee Iacona & Cross-Pharma Non-proportional Hazards Working Group. 2020. Alternative analysis methods time event endpoints nonproportional hazards: comparative analysis. Statistics Biopharmaceutical Research 12(2): 187--198.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/Ex6crossing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-to-event data example 6 for non-proportional hazards working group — Ex6crossing","text":"","code":"library(survival)  data(Ex6crossing) km1 <- with(Ex6crossing, survfit(Surv(month, evntd) ~ trt)) km1 #> Call: survfit(formula = Surv(month, evntd) ~ trt) #>  #>         n events median 0.95LCL 0.95UCL #> trt=0 145    111  10.66    8.83    12.5 #> trt=1 145    113   9.92    7.38    14.3 plot(km1)"},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated survival dataset with delayed treatment effect — MBdelayed","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"Magirr Burman (2019) considered several scenarios modestly weighted logrank test. One delayed treatment effect hazard ratio 1 6 months followed hazard ratio 1/2 thereafter. scenario enrolled 200 patients uniformly 12 months cut data analysis 36 months enrollment opened. dataset generated sim_pw_surv() function scenario.","code":""},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"","code":"MBdelayed"},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"data frame 200 rows 4 columns: tte: Time event.","code":""},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"Magirr, Dominic, Carl‐Fredrik Burman. 2019. \"Modestly weighted logrank tests.\" Statistics Medicine 38 (20): 3782--3790.","code":""},{"path":"https://merck.github.io/simtrial/reference/MBdelayed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated survival dataset with delayed treatment effect — MBdelayed","text":"","code":"library(survival) library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  fit <- survfit(Surv(tte, event) ~ treatment, data = MBdelayed)  # Plot survival plot(fit, lty = 1:2) legend(\"topright\", legend = c(\"control\", \"experimental\"), lty = 1:2)   # Set up time, event, number of event dataset for testing # with arbitrary weights ten <- MBdelayed |> counting_process(arm = \"experimental\") head(ten) #>   stratum events n_event_tol        tte n_risk_tol n_risk_trt     s  o_minus_e #> 1     All      1           1 0.07659251        200        100 1.000  0.5000000 #> 2     All      1           0 0.49067015        199         99 0.995 -0.4974874 #> 3     All      1           1 0.65465035        198         99 0.990  0.5000000 #> 4     All      1           0 0.65906384        197         98 0.985 -0.4974619 #> 5     All      1           1 0.81945349        196         98 0.980  0.5000000 #> 6     All      1           0 0.82788909        195         97 0.975 -0.4974359 #>   var_o_minus_e #> 1     0.2500000 #> 2     0.2499937 #> 3     0.2500000 #> 4     0.2499936 #> 5     0.2500000 #> 6     0.2499934  # MaxCombo with logrank, FH(0,1), FH(1,1) ten |>   fh_weight(rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 1)), return_corr = TRUE) |>   pvalue_maxcombo() #> [1] 0.0110471  # Magirr-Burman modestly down-weighted rank test with 6 month delay # First, add weights ten <- ten |> mb_weight(6) head(ten) #>   stratum events n_event_tol        tte n_risk_tol n_risk_trt     s  o_minus_e #> 1     All      1           1 0.07659251        200        100 1.000  0.5000000 #> 2     All      1           0 0.49067015        199         99 0.995 -0.4974874 #> 3     All      1           1 0.65465035        198         99 0.990  0.5000000 #> 4     All      1           0 0.65906384        197         98 0.985 -0.4974619 #> 5     All      1           1 0.81945349        196         98 0.980  0.5000000 #> 6     All      1           0 0.82788909        195         97 0.975 -0.4974359 #>   var_o_minus_e mb_weight #> 1     0.2500000  1.000000 #> 2     0.2499937  1.005025 #> 3     0.2500000  1.010101 #> 4     0.2499936  1.015228 #> 5     0.2500000  1.020408 #> 6     0.2499934  1.025641  # Now compute test based on these weights ten |>   summarize(     S = sum(o_minus_e * mb_weight),     V = sum(var_o_minus_e * mb_weight^2),     Z = S / sqrt(V)   ) |>   mutate(p = pnorm(Z)) #>           S        V        Z           p #> 1 -18.11459 52.42537 -2.50183 0.006177665  # Create 0 weights for first 6 months ten <- ten |> mutate(w6 = 1 * (tte >= 6)) ten |>   summarize(     S = sum(o_minus_e * w6),     V = sum(var_o_minus_e * w6^2),     Z = S / sqrt(V)   ) |>   mutate(p = pnorm(Z)) #>           S       V         Z          p #> 1 -10.03651 22.5762 -2.112309 0.01732996  # Generate another dataset ds <- sim_pw_surv(   n = 200,   enroll_rate = data.frame(rate = 200 / 12, duration = 12),   fail_rate = data.frame(     stratum = c(\"All\", \"All\", \"All\"),     period = c(1, 1, 2),     treatment = c(\"control\", \"experimental\", \"experimental\"),     duration = c(42, 6, 36),     rate = c(log(2) / 15, log(2) / 15, log(2) / 15 * 0.6)   ),   dropout_rate = data.frame(     stratum = c(\"All\", \"All\"),     period = c(1, 1),     treatment = c(\"control\", \"experimental\"),     duration = c(42, 42),     rate = c(0, 0)   ) ) # Cut data at 24 months after final enrollment MBdelayed2 <- ds |> cut_data_by_date(max(ds$enroll_time) + 24)"},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":null,"dir":"Reference","previous_headings":"","what":"Process survival data into counting process format — counting_process","title":"Process survival data into counting process format — counting_process","text":"Produces data frame sorted stratum time. Included times one event occurs. output dataset contains stratum, tte (time--event), risk count count events specified tte sorted stratum tte.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process survival data into counting process format — counting_process","text":"","code":"counting_process(x, arm)"},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process survival data into counting process format — counting_process","text":"x data frame missing values contain variables: stratum: Stratum. treatment: Treatment group. tte: Observed time. event: Binary event indicator, 1 represents event, 0 represents censoring. arm Value input treatment column indicates treatment group value.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process survival data into counting process format — counting_process","text":"data frame grouped stratum sorted within stratum tte. Remain rows least one event population, least one subject risk treatment group control group. variables represent following within stratum time one events observed: events: Total number events n_event_tol: Total number events treatment group n_risk_tol: Number subjects risk n_risk_trt: Number subjects risk treatment group S: Left-continuous Kaplan-Meier survival estimate o_minus_e: treatment group, observed number events minus expected number events. expected number events estimated assuming treatment effect hypergeometric distribution parameters total number events, total number events treatment group number events time. (assumption log-rank test null hypothesis) var_o_minus_e: Variance o_minus_e assumption.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process survival data into counting process format — counting_process","text":"function considered two group situation. tie handled Breslow's Method.","code":""},{"path":"https://merck.github.io/simtrial/reference/counting_process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process survival data into counting process format — counting_process","text":"","code":"# Example 1 x <- data.frame(   stratum = c(rep(1, 10), rep(2, 6)),   treatment = rep(c(1, 1, 0, 0), 4),   tte = 1:16,   event = rep(c(0, 1), 8) ) counting_process(x, arm = 1) #>   stratum events n_event_tol tte n_risk_tol n_risk_trt         s  o_minus_e #> 1       1      1           1   2          9          5 1.0000000  0.4444444 #> 2       1      1           0   4          7          4 0.8888889 -0.5714286 #> 3       1      1           1   6          5          3 0.7619048  0.4000000 #> 4       1      1           0   8          3          2 0.6095238 -0.6666667 #> 5       2      1           0  12          5          2 1.0000000 -0.4000000 #> 6       2      1           1  14          3          1 0.8000000  0.6666667 #>   var_o_minus_e #> 1     0.2469136 #> 2     0.2448980 #> 3     0.2400000 #> 4     0.2222222 #> 5     0.2400000 #> 6     0.2222222  # Example 2 x <- sim_pw_surv(n = 400) y <- cut_data_by_event(x, 150) |> counting_process(arm = \"experimental\") # Weighted logrank test (Z-value and 1-sided p-value) z <- sum(y$o_minus_e) / sqrt(sum(y$var_o_minus_e)) c(z, pnorm(z)) #> [1] -0.5534917  0.2899634"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a dataset for analysis at a specified date — cut_data_by_date","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"Cut dataset analysis specified date","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"","code":"cut_data_by_date(x, cut_date)"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"x time--event dataset, example, generated sim_pw_surv(). cut_date Date relative start randomization (cte input dataset) dataset cut analysis.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"dataset ready survival analysis.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a dataset for analysis at a specified date — cut_data_by_date","text":"","code":"# Use default enrollment and event rates and # cut at calendar time 5 after start of randomization sim_pw_surv(n = 20) |> cut_data_by_date(5) #>          tte event stratum    treatment #> 1  4.6464391     0     All experimental #> 2  4.6406566     0     All      control #> 3  4.5924348     0     All      control #> 4  4.1014565     0     All experimental #> 5  4.0081719     0     All experimental #> 6  3.9034550     0     All      control #> 7  3.9027173     0     All      control #> 8  3.8297966     0     All experimental #> 9  2.7560229     1     All      control #> 10 3.7373491     0     All experimental #> 11 3.6427929     0     All experimental #> 12 3.5335914     0     All      control #> 13 3.3845954     0     All      control #> 14 3.1980332     0     All experimental #> 15 2.9850633     0     All      control #> 16 2.9317955     0     All experimental #> 17 2.8315793     0     All experimental #> 18 2.7646228     0     All      control #> 19 0.2370824     1     All      control #> 20 2.6555741     0     All experimental"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a dataset for analysis at a specified event count — cut_data_by_event","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"Takes time--event data set cuts data event count reached.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"","code":"cut_data_by_event(x, event)"},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"x time--event dataset, example, generated sim_pw_surv(). event Event count data cutoff made.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"data frame ready survival analysis, including columns time event (tte), event, stratum, treatment.","code":""},{"path":"https://merck.github.io/simtrial/reference/cut_data_by_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a dataset for analysis at a specified event count — cut_data_by_event","text":"","code":"# Use default enrollment and event rates at cut at 100 events x <- sim_pw_surv(n = 200) |> cut_data_by_event(100) table(x$event, x$treatment) #>     #>     control experimental #>   0      47           53 #>   1      53           47"},{"path":"https://merck.github.io/simtrial/reference/early_zero_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Zero early weight for weighted logrank tests — early_zero_weight","title":"Zero early weight for weighted logrank tests — early_zero_weight","text":"Zero early weight weighted logrank tests","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zero early weight for weighted logrank tests — early_zero_weight","text":"","code":"early_zero_weight(x, early_period = 4, fail_rate = NULL)"},{"path":"https://merck.github.io/simtrial/reference/early_zero_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zero early weight for weighted logrank tests — early_zero_weight","text":"x counting_process()-class data frame counting process dataset. early_period initial delay period weights increase; , weights constant final weight delay period. fail_rate data frame record failure rate.","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero_weight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zero early weight for weighted logrank tests — early_zero_weight","text":"data frame. column weight contains weights early zero weighted logrank test data x.","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero_weight.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Zero early weight for weighted logrank tests — early_zero_weight","text":"Xu, Z., Zhen, B., Park, Y., & Zhu, B. (2017). \"Designing therapeutic cancer vaccine trials delayed treatment effect.\" Statistics Medicine, 36(4), 592--605.","code":""},{"path":"https://merck.github.io/simtrial/reference/early_zero_weight.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zero early weight for weighted logrank tests — early_zero_weight","text":"","code":"library(dplyr) library(gsDesign2)  # Example 1: Unstratified sim_pw_surv(n = 200) |>   cut_data_by_event(125) |>   counting_process(arm = \"experimental\") |>   early_zero_weight(early_period = 2) |>   filter(row_number() %in% seq(5, 200, 40)) #>   stratum events n_event_tol        tte n_risk_tol n_risk_trt         s #> 1     All      1           1  0.4685844        196        100 0.9800000 #> 2     All      1           1  3.1614805        155         78 0.7791223 #> 3     All      1           0  7.2838793        101         57 0.5700234 #> 4     All      1           0 22.8154699          6          4 0.2093398 #>    o_minus_e var_o_minus_e weight #> 1  0.4897959     0.2498959      0 #> 2  0.4967742     0.2499896      1 #> 3 -0.5643564     0.2458582      1 #> 4 -0.6666667     0.2222222      1  # Example 2: Stratified n <- 500 # Two strata stratum <- c(\"Biomarker-positive\", \"Biomarker-negative\") prevalence_ratio <- c(0.6, 0.4)  # Enrollment rate enroll_rate <- define_enroll_rate(   stratum = rep(stratum, each = 2),   duration = c(2, 10, 2, 10),   rate = c(c(1, 4) * prevalence_ratio[1], c(1, 4) * prevalence_ratio[2]) ) enroll_rate$rate <- enroll_rate$rate * n / sum(enroll_rate$duration * enroll_rate$rate)  # Failure rate med_pos <- 10 # Median of the biomarker positive population med_neg <- 8 # Median of the biomarker negative population hr_pos <- c(1, 0.7) # Hazard ratio of the biomarker positive population hr_neg <- c(1, 0.8) # Hazard ratio of the biomarker negative population fail_rate <- define_fail_rate(   stratum = rep(stratum, each = 2),   duration = c(3, 1000, 4, 1000),   fail_rate = c(log(2) / c(med_pos, med_pos, med_neg, med_neg)),   hr = c(hr_pos, hr_neg),   dropout_rate = 0.01 )  # Simulate data temp <- simfix2simpwsurv(fail_rate) # Convert the failure rate set.seed(2023)  sim_pw_surv(   n = n, # Sample size   # Stratified design with prevalence ratio of 6:4   stratum = tibble(stratum = stratum, p = prevalence_ratio),   # Randomization ratio   block = c(\"control\", \"control\", \"experimental\", \"experimental\"),   enroll_rate = enroll_rate, # Enrollment rate   fail_rate = temp$fail_rate, # Failure rate   dropout_rate = temp$dropout_rate # Dropout rate ) |>   cut_data_by_event(125) |>   counting_process(arm = \"experimental\") |>   early_zero_weight(early_period = 2, fail_rate = fail_rate) |>   filter(row_number() %in% seq(5, 200, 40)) #>              stratum events n_event_tol        tte n_risk_tol n_risk_trt #> 1 Biomarker-negative      1           0  0.5257917        142         74 #> 2 Biomarker-negative      1           0  4.1066618         79         43 #> 3 Biomarker-positive      1           1  1.9657427        153         74 #> 4 Biomarker-positive      1           0 10.7059605         21         10 #>           s  o_minus_e var_o_minus_e  hr duration weight #> 1 0.9731944 -0.5211268     0.2495537 0.8        4    0.0 #> 2 0.6800393 -0.5443038     0.2480372 0.8        4    0.8 #> 3 0.8822199  0.5163399     0.2497330 0.7        3    0.0 #> 4 0.5265625 -0.4761905     0.2494331 0.7        3    0.7"},{"path":"https://merck.github.io/simtrial/reference/fh_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Fleming-Harrington weighted logrank tests — fh_weight","title":"Fleming-Harrington weighted logrank tests — fh_weight","text":"output function counting_process().","code":""},{"path":"https://merck.github.io/simtrial/reference/fh_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fleming-Harrington weighted logrank tests — fh_weight","text":"","code":"fh_weight(   x = counting_process(cut_data_by_event(sim_pw_surv(n = 200), 150), arm =     \"experimental\"),   rho_gamma = data.frame(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)),   return_variance = FALSE,   return_corr = FALSE )"},{"path":"https://merck.github.io/simtrial/reference/fh_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fleming-Harrington weighted logrank tests — fh_weight","text":"x counting_process()-class data frame counting process dataset. rho_gamma data frame variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted logrank test per row; Default: data.frame(rho = c(0, 0, 1, 1), gamma = c(0, 1, 0, 1)). return_variance logical flag , TRUE, adds columns estimated variance weighted sum observed minus expected; see details; Default: FALSE. return_corr logical flag , TRUE, adds columns estimated correlation weighted sum observed minus expected; see details; Default: FALSE.","code":""},{"path":"https://merck.github.io/simtrial/reference/fh_weight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fleming-Harrington weighted logrank tests — fh_weight","text":"data frame rho_gamma input FH test statistic data x. (z, directional square root usual weighted logrank test); variance calculations specified (example, used covariances combination test), returned column Var.","code":""},{"path":"https://merck.github.io/simtrial/reference/fh_weight.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fleming-Harrington weighted logrank tests — fh_weight","text":"input value x produced counting_process() produces counting process dataset grouped stratum sorted within stratum increasing times events occur. \\(z\\) - Standardized normal Fleming-Harrington weighted logrank test. \\(\\) - Stratum index. \\(d_i\\) - Number distinct times events occurred stratum \\(\\). \\(t_{ij}\\) - Ordered times events stratum \\(\\), \\(j = 1, 2, \\ldots, d_i\\) observed; observation, \\(t_{ij}\\) represents time post study entry. \\(O_{ij.}\\) - Total number events stratum \\(\\) occurred time \\(t_{ij}\\). \\(O_{ije}\\) - Total number events stratum \\(\\) experimental treatment group occurred time \\(t_{ij}\\). \\(N_{ij.}\\) - Total number study subjects stratum \\(\\) followed least duration. \\(E_{ije}\\) - Expected observations experimental treatment group given random selection \\(O_{ij.}\\) stratum \\(\\) risk time \\(t_{ij}\\). \\(V_{ije}\\) - Hypergeometric variance \\(E_{ije}\\) produced Var counting_process(). \\(N_{ije}\\) - Total number study subjects stratum \\(\\) experimental treatment group followed least duration \\(t_{ij}\\). \\(E_{ije}\\) - Expected observations experimental group stratum \\(\\) time \\(t_{ij}\\) conditioning overall number events risk populations time sampling risk observations without replacement: $$E_{ije} = O_{ij.} N_{ije}/N_{ij.}$$ \\(S_{ij}\\) - Kaplan-Meier estimate survival combined treatment groups immediately prior time \\(t_{ij}\\). \\(\\rho, \\gamma\\) - Real parameters Fleming-Harrington test. \\(X_i\\) - Numerator signed logrank test stratum \\(\\) $$X_i = \\sum_{j=1}^{d_{}} S_{ij}^\\rho(1-S_{ij}^\\gamma)(O_{ije}-E_{ije})$$ \\(V_{ij}\\) - Variance used denominator Fleming-Harrington weighted logrank tests $$V_i = \\sum_{j=1}^{d_{}} (S_{ij}^\\rho(1-S_{ij}^\\gamma))^2V_{ij})$$ stratified Fleming-Harrington weighted logrank test computed : $$z = \\sum_i X_i/\\sqrt{\\sum_i V_i}.$$","code":""},{"path":"https://merck.github.io/simtrial/reference/fh_weight.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fleming-Harrington weighted logrank tests — fh_weight","text":"","code":"library(dplyr)  # Example 1 # Use default enrollment and event rates at cut at 100 events x <- sim_pw_surv(n = 200) |>   cut_data_by_event(100) |>   counting_process(arm = \"experimental\")  # Compute logrank FH(0, 1) fh_weight(x, rho_gamma = data.frame(rho = 0, gamma = 1)) #>   rho gamma         z #> 1   0     1 -3.332801 fh_weight(x, rho_gamma = data.frame(rho = 0, gamma = 1), return_variance = TRUE) #>   rho gamma         z      var #> 1   0     1 -3.332801 2.477853  # Compute the corvariance between FH(0, 0), FH(0, 1) and FH(1, 0) fh_weight(x, rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 0))) #>   rho gamma         z #> 1   0     0 -3.744963 #> 2   0     1 -3.332801 #> 3   1     0 -3.561863 fh_weight(x, rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 0)), return_variance = TRUE) #>   rho gamma         z        v1       v2        v3 #> 1   0     0 -3.744963 24.195511 6.495887 17.699623 #> 2   0     1 -3.332801  6.495887 2.477853  4.018035 #> 3   1     0 -3.561863 17.699623 4.018035 13.681589 fh_weight(x, rho_gamma = data.frame(rho = c(0, 0, 1), gamma = c(0, 1, 0)), return_corr = TRUE) #>   rho gamma         z        v1        v2        v3 #> 1   0     0 -3.744963 1.0000000 0.8389447 0.9728108 #> 2   0     1 -3.332801 0.8389447 1.0000000 0.6900931 #> 3   1     0 -3.561863 0.9728108 0.6900931 1.0000000  # Example 2 # Use default enrollment and event rates at cut of 100 events set.seed(123) x <- sim_pw_surv(n = 200) |>   cut_data_by_event(100) |>   counting_process(arm = \"experimental\") |>   fh_weight(rho_gamma = data.frame(rho = c(0, 0), gamma = c(0, 1)), return_corr = TRUE)  # Compute p-value for MaxCombo library(mvtnorm) 1 - pmvnorm(   lower = rep(min(x$z), nrow(x)),   corr = data.matrix(select(x, -c(rho, gamma, z))),   algorithm = GenzBretz(maxpts = 50000, abseps = 0.00001) )[1] #> [1] 0.003336366  # Check that covariance is as expected x <- sim_pw_surv(n = 200) |>   cut_data_by_event(100) |>   counting_process(arm = \"experimental\")  x |> fh_weight(   rho_gamma = data.frame(     rho = c(0, 0),     gamma = c(0, 1)   ),   return_variance = TRUE ) #>   rho gamma          z        v1       v2 #> 1   0     0 -0.2790263 24.554559 6.644167 #> 2   0     1 -1.1511132  6.644167 2.552420  # Off-diagonal element should be variance in following x |> fh_weight(   rho_gamma = data.frame(     rho = 0,     gamma = .5   ),   return_variance = TRUE ) #>   rho gamma          z      var #> 1   0   0.5 -0.9492403 6.644167  # Compare off diagonal result with fh_weight() x |> fh_weight(rho_gamma = data.frame(rho = 0, gamma = .5)) #>   rho gamma          z #> 1   0   0.5 -0.9492403"},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise exponential survival estimation — fit_pwexp","title":"Piecewise exponential survival estimation — fit_pwexp","text":"Computes survival function, density function, -2 * log-likelihood based input dataset intervals piecewise constant failure rates. Initial version assumes observations right censored events .","code":""},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise exponential survival estimation — fit_pwexp","text":"","code":"fit_pwexp(   srv = Surv(time = Ex1delayedEffect$month, event = Ex1delayedEffect$evntd),   intervals = array(3, 3) )"},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise exponential survival estimation — fit_pwexp","text":"srv Input survival object (see survival::Surv()); note 0 = censored, 1 = event survival::Surv(). intervals Vector containing positive values indicating interval lengths exponential rates assumed. Note final infinite interval added events occur final interval specified.","code":""},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise exponential survival estimation — fit_pwexp","text":"matrix rows containing interval length, estimated rate, -2 * log-likelihood interval.","code":""},{"path":"https://merck.github.io/simtrial/reference/fit_pwexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise exponential survival estimation — fit_pwexp","text":"","code":"# Use default arguments for delayed effect example dataset (Ex1delayedEffect) library(survival)  # Example 1 rateall <- fit_pwexp() rateall #>   intervals     ttot event       rate     m2ll #> 1         3 937.1785    97 0.10350216 634.0236 #> 2         3 605.3572    71 0.11728612 446.3257 #> 3         3 346.8482    30 0.08649317 206.8614 #> 4       Inf 254.1148    20 0.07870458 141.6822  # Example 2 # Estimate by treatment effect rate1 <- with(subset(Ex1delayedEffect, trt == 1), fit_pwexp(Surv(month, evntd))) rate0 <- with(subset(Ex1delayedEffect, trt == 0), fit_pwexp(Surv(month, evntd)))  rate1 #>   intervals     ttot event       rate      m2ll #> 1         3 620.4375    64 0.10315302 418.75734 #> 2         3 415.8482    36 0.08657005 248.16970 #> 3         3 256.2053    19 0.07415927 136.85853 #> 4       Inf 205.4186    13 0.06328542  97.76261 rate0 #>   intervals      ttot event      rate      m2ll #> 1         3 316.74106    33 0.1041861 215.26408 #> 2         3 189.50899    35 0.1846878 188.23619 #> 3         3  90.64288    11 0.1213554  68.39871 #> 4       Inf  48.69624     7 0.1437483  41.15568 rate1$rate / rate0$rate #> [1] 0.9900847 0.4687372 0.6110917 0.4402517  # Chi-square test for (any) treatment effect (8 - 4 parameters = 4 df) pchisq(sum(rateall$m2ll) - sum(rate1$m2ll + rate0$m2ll),   df = 4,   lower.tail = FALSE ) #> [1] 0.006424744  # Compare with logrank survdiff(formula = Surv(month, evntd) ~ trt, data = Ex1delayedEffect) #> Call: #> survdiff(formula = Surv(month, evntd) ~ trt, data = Ex1delayedEffect) #>  #>         N Observed Expected (O-E)^2/E (O-E)^2/V #> trt=0 121       86     67.7      4.97      7.35 #> trt=1 240      132    150.3      2.24      7.35 #>  #>  Chisq= 7.3  on 1 degrees of freedom, p= 0.007   # Example 3 # Simple model with 3 rates same for each for 3 months, # different for each treatment after months rate1a <- with(subset(Ex1delayedEffect, trt == 1), fit_pwexp(Surv(month, evntd), 3)) rate0a <- with(subset(Ex1delayedEffect, trt == 0), fit_pwexp(Surv(month, evntd), 3)) rate1a$rate / rate0a$rate #> [1] 0.9900847 0.4808339  m2ll0 <- rateall$m2ll[1] + rate1a$m2ll[2] + rate0a$m2ll[2] m2ll1 <- sum(rate0$m2ll) + sum(rate1$m2ll)  # As a measure of strength, chi-square examines improvement in likelihood pchisq(m2ll0 - m2ll1, df = 5, lower.tail = FALSE) #> [1] 0.741822"},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the analysis date under multiple conditions — get_analysis_date","title":"Get the analysis date under multiple conditions — get_analysis_date","text":"Get analysis date multiple conditions","code":""},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the analysis date under multiple conditions — get_analysis_date","text":"","code":"get_analysis_date(   data,   planned_calendar_time = NA,   target_event_overall = NA,   target_event_per_stratum = NA,   max_extension_for_target_event = NA,   previous_analysis_date = 0,   min_time_after_previous_analysis = NA,   min_n_overall = NA,   min_n_per_stratum = NA,   min_followup = NA )"},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the analysis date under multiple conditions — get_analysis_date","text":"data simulated data generated sim_pw_surv(). planned_calendar_time numerical value specifying planned calendar time analysis. target_event_overall numerical value specifying targeted events overall population. target_event_per_stratum numerical vector specifying targeted events per stratum. max_extension_for_target_event numerical value specifying maximum time extension reach targeted events. previous_analysis_date numerical value specifying previous analysis date. min_time_after_previous_analysis numerical value specifying planned minimum time previous analysis. min_n_overall numerical value specifying minimal overall sample size enrolled kick analysis. min_n_per_stratum numerical value specifying minimal sample size enrolled per stratum kick analysis. min_followup numerical value specifying minimal follow-time specified enrollment fraction min_n_overall min_n_per_stratum.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the analysis date under multiple conditions — get_analysis_date","text":"numerical value analysis date.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_analysis_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the analysis date under multiple conditions — get_analysis_date","text":"","code":"library(gsDesign2) library(simtrial)  alpha <- 0.025 ratio <- 3 n <- 500 info_frac <- c(0.7, 1) prevalence_ratio <- c(0.4, 0.6) study_duration <- 48  # Two strata stratum <- c(\"Biomarker-positive\", \"Biomarker-negative\")  prevalence_ratio <- c(0.6, 0.4) # enrollment rate enroll_rate <- define_enroll_rate(   stratum = rep(stratum, each = 2),   duration = c(2, 10, 2, 10),   rate = c(c(1, 4) * prevalence_ratio[1], c(1, 4) * prevalence_ratio[2]) ) enroll_rate$rate <- enroll_rate$rate * n / sum(enroll_rate$duration * enroll_rate$rate)  # Failure rate med_pos <- 10 # Median of the biomarker positive population med_neg <- 8 # Median of the biomarker negative population hr_pos <- c(1, 0.7) # Hazard ratio of the biomarker positive population hr_neg <- c(1, 0.8) # Hazard ratio of the biomarker negative population fail_rate <- define_fail_rate(   stratum = rep(stratum, each = 2),   duration = 1000,   fail_rate = c(log(2) / c(med_pos, med_pos, med_neg, med_neg)),   hr = c(hr_pos, hr_neg),   dropout_rate = 0.01 )  # Simulate data temp <- simfix2simpwsurv(fail_rate) # Convert the failure rate set.seed(2023) simulated_data <- sim_pw_surv(   n = n, # Sample size   # Stratified design with prevalence ratio of 6:4   stratum = data.frame(stratum = stratum, p = prevalence_ratio),   # Randomization ratio   block = c(\"control\", \"control\", \"experimental\", \"experimental\"),   enroll_rate = enroll_rate, # Enrollment rate   fail_rate = temp$fail_rate, # Failure rate   dropout_rate = temp$dropout_rate # Dropout rate )  # Example 1: Cut for analysis at the 24th month. get_analysis_date(   simulated_data,   planned_calendar_time = 24 ) #> [1] 24  # Example 2: Cut for analysis when there are 300 events in the overall population. get_analysis_date(   simulated_data,   target_event_overall = 300 ) #> [1] 25.61506  # Example 3: Cut for analysis at the 24th month and there are 300 events # in the overall population, whichever arrives later. get_analysis_date(   simulated_data,   planned_calendar_time = 24,   target_event_overall = 300 ) #> [1] 25.61506  # Example 4a: Cut for analysis when there are at least 100 events # in the biomarker-positive population, and at least 200 events # in the biomarker-negative population, whichever arrives later. get_analysis_date(   simulated_data,   target_event_per_stratum = c(100, 200) ) #> [1] 30.78865 # Example 4b: Cut for analysis when there are at least 100 events # in the biomarker-positive population, but we don't have a requirement # for the biomarker-negative population. get_analysis_date(   simulated_data,   target_event_overall = 150,   target_event_per_stratum = c(100, NA) ) #> [1] 18.30272  # Example 5: Cut for analysis when there are at least 100 events # in the biomarker positive population, and at least 200 events # in the biomarker negative population, whichever arrives later. # But will stop at the 30th month if events are fewer than 100/200. get_analysis_date(   simulated_data,   target_event_per_stratum = c(100, 200),   max_extension_for_target_event = 30 ) #> [1] 30  # Example 6: Cut for analysis after 12 months followup when 80% # of the patients are enrolled in the overall population. get_analysis_date(   simulated_data,   min_n_overall = n * 0.8,   min_followup = 12 ) #> [1] 28.82521  # Example 7a: Cut for analysis when 12 months after at least 200/160 patients # are enrolled in the biomarker positive/negative population. get_analysis_date(   simulated_data,   min_n_per_stratum = c(200, 160),   min_followup = 12 ) #> [1] 27.33728 # Example 7b: Cut for analysis when 12 months after at least 200 patients # are enrolled in the biomarker positive population, but we don't have a # specific requirement for the biomarker negative population. get_analysis_date(   simulated_data,   min_n_per_stratum = c(200, NA),   min_followup = 12 ) #> [1] 27.33728 # Example 7c: Cut for analysis when 12 months after at least 200 patients # are enrolled in the biomarker-positive population, but we don't have a # specific requirement for the biomarker-negative population. We also want # there are at least 80% of the patients enrolled in the overall population. get_analysis_date(   simulated_data,   min_n_overall = n * 0.8,   min_n_per_stratum = c(200, NA),   min_followup = 12 ) #> [1] 28.82521"},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Get date at which an event count is reached — get_cut_date_by_event","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"Get date event count reached","code":""},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"","code":"get_cut_date_by_event(x, event)"},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"x time--event dataset, example, generated sim_pw_surv(). event Event count dataset cut analysis.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"numeric value cte input dataset targeted event count reached, final event count never reached, final cte event occurs.","code":""},{"path":"https://merck.github.io/simtrial/reference/get_cut_date_by_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get date at which an event count is reached — get_cut_date_by_event","text":"","code":"library(dplyr)  # Use default enrollment and calendar cut date # for 50 events in the \"Positive\" stratum x <- sim_pw_surv(   n = 200,   stratum = data.frame(     stratum = c(\"Positive\", \"Negative\"),     p = c(.5, .5)   ),   fail_rate = data.frame(     stratum = rep(c(\"Positive\", \"Negative\"), 2),     period = rep(1, 4),     treatment = c(rep(\"control\", 2), rep(\"experimental\", 2)),     duration = rep(1, 4),     rate = log(2) / c(6, 9, 9, 12)   ),   dropout_rate = data.frame(     stratum = rep(c(\"Positive\", \"Negative\"), 2),     period = rep(1, 4),     treatment = c(rep(\"control\", 2), rep(\"experimental\", 2)),     duration = rep(1, 4),     rate = rep(.001, 4)   ) )  d <- get_cut_date_by_event(x |> filter(stratum == \"Positive\"), event = 50)  y <- cut_data_by_date(x, cut_date = d) table(y$stratum, y$event) #>            #>             0  1 #>   Negative 49 45 #>   Positive 37 50"},{"path":"https://merck.github.io/simtrial/reference/mb_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Magirr and Burman modestly weighted logrank tests — mb_weight","title":"Magirr and Burman modestly weighted logrank tests — mb_weight","text":"Magirr Burman (2019) proposed weighted logrank test better power logrank test treatment effect delayed, still maintain good power proportional hazards assumption. Magirr (2021), (equivalent ) maximum weight proposed opposed fixed time duration weights increase. weights early interval specified user inverse combined treatment group empirical survival distribution; see details. initial period, weights constant maximum previous weights. Another advantage test strong null hypothesis underlying survival control group greater equal underlying survival experimental group, Type error controlled specified level.","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magirr and Burman modestly weighted logrank tests — mb_weight","text":"","code":"mb_weight(x, delay = 4, w_max = Inf)"},{"path":"https://merck.github.io/simtrial/reference/mb_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Magirr and Burman modestly weighted logrank tests — mb_weight","text":"x counting_process()-class data frame counting process dataset. delay initial delay period weights increase; , weights constant final weight delay period. w_max Maximum weight returned. Set delay = Inf, w_max = 2 consistent recommendation Magirr (2021).","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_weight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Magirr and Burman modestly weighted logrank tests — mb_weight","text":"data frame. column mb_weight contains weights Magirr-Burman weighted logrank test data x.","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_weight.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Magirr and Burman modestly weighted logrank tests — mb_weight","text":"Computes Magirr-Burman weights adds dataset created counting_process(). weights can used compute z-statistic modestly weighted logrank test proposed. define \\(t^*\\) input variable delay. specifies initial period weights increase. also set maximum weight \\(w_{\\max}\\). define specific weights, let \\(S(t)\\) denote Kaplan-Meier survival estimate time \\(t\\) combined data (control plus experimental treatment groups). weight time \\(t\\) defined $$w(t)=\\min(w_{\\max}, S(\\min(t, t^*))^{-1}).$$","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_weight.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Magirr and Burman modestly weighted logrank tests — mb_weight","text":"Magirr, Dominic, Carl‐Fredrik Burman. 2019. \"Modestly weighted logrank tests.\" Statistics Medicine 38 (20): 3782--3790. Magirr, Dominic. 2021. \"Non‐proportional hazards immuno‐oncology: old perspective needed?\" Pharmaceutical Statistics 20 (3): 512--527.","code":""},{"path":"https://merck.github.io/simtrial/reference/mb_weight.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Magirr and Burman modestly weighted logrank tests — mb_weight","text":"","code":"library(dplyr)  # Use default enrollment and event rates at cut at 100 events # For transparency, may be good to set either `delay` or `w_max` to `Inf` x <- sim_pw_surv(n = 200) |>   cut_data_by_event(125) |>   counting_process(arm = \"experimental\")  # Example 1 # Compute Magirr-Burman weights with `delay = 6` ZMB <- x |>   mb_weight(delay = 6, w_max = Inf) |>   summarize(     S = sum(o_minus_e * mb_weight),     V = sum(var_o_minus_e * mb_weight^2),     z = S / sqrt(V)   )  # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB$z) #> [1] 0.2198563  # Example 2 # Now compute with maximum weight of 2 as recommended in Magirr, 2021 ZMB2 <- x |>   mb_weight(delay = Inf, w_max = 2) |>   summarize(     S = sum(o_minus_e * mb_weight),     V = sum(var_o_minus_e * mb_weight^2),     z = S / sqrt(V)   )  # Compute p-value of modestly weighted logrank of Magirr-Burman pnorm(ZMB2$z) #> [1] 0.2213785"},{"path":"https://merck.github.io/simtrial/reference/pvalue_maxcombo.html","id":null,"dir":"Reference","previous_headings":"","what":"MaxCombo p-value — pvalue_maxcombo","title":"MaxCombo p-value — pvalue_maxcombo","text":"Computes p-values MaxCombo test based output fh_weight(). still experimental stage intended use sim_fixed_n() trial simulation routine. However, can also used analyze clinical trial data provided ADaM ADTTE format.","code":""},{"path":"https://merck.github.io/simtrial/reference/pvalue_maxcombo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MaxCombo p-value — pvalue_maxcombo","text":"","code":"pvalue_maxcombo(   z,   algorithm = mvtnorm::GenzBretz(maxpts = 50000, abseps = 1e-05) )"},{"path":"https://merck.github.io/simtrial/reference/pvalue_maxcombo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MaxCombo p-value — pvalue_maxcombo","text":"z dataset output fh_weight(); see examples. algorithm passed directly algorithm argument mvtnorm::pmvnorm().","code":""},{"path":"https://merck.github.io/simtrial/reference/pvalue_maxcombo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MaxCombo p-value — pvalue_maxcombo","text":"numeric p-value.","code":""},{"path":"https://merck.github.io/simtrial/reference/pvalue_maxcombo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MaxCombo p-value — pvalue_maxcombo","text":"","code":"library(dplyr)  # Example 1 x <- sim_fixed_n(   n_sim = 1,   timing_type = 5,   rho_gamma = data.frame(     rho = c(0, 0, 1),     gamma = c(0, 1, 1)   ) ) #> Backend uses sequential processing. #> Loading required package: foreach #> Loading required package: future #>  #> Attaching package: ‘future’ #> The following object is masked from ‘package:survival’: #>  #>     cluster head(x) #>   event      ln_hr rho gamma         z        v1        v2        v3 #> 1   350 -0.3913266   0     0 -3.637665 1.0000000 0.8523636 0.9324825 #> 2   350 -0.3913266   0     1 -4.420310 0.8523636 1.0000000 0.9321649 #> 3   350 -0.3913266   1     1 -4.540739 0.9324825 0.9321649 1.0000000 #>                             cut duration sim #> 1 Max(min follow-up, event cut) 73.05896   1 #> 2 Max(min follow-up, event cut) 73.05896   1 #> 3 Max(min follow-up, event cut) 73.05896   1 pvalue_maxcombo(x) #> [1] 2.806222e-06  # Example 2 # Only use cuts for events, events + min follow-up xx <- sim_fixed_n(   n_sim = 100,   timing_type = 5,   rho_gamma = data.frame(     rho = c(0, 0, 1),     gamma = c(0, 1, 1)   ) ) #> Backend uses sequential processing. head(xx) #>   event      ln_hr rho gamma         z        v1        v2        v3 #> 1   367 -0.3603407   0     0 -3.433180 1.0000000 0.8508939 0.9329539 #> 2   367 -0.3603407   0     1 -3.227307 0.8508939 1.0000000 0.9168869 #> 3   367 -0.3603407   1     1 -3.707276 0.9329539 0.9168869 1.0000000 #> 4   370 -0.3551767   0     0 -3.406090 1.0000000 0.8523183 0.9339574 #> 5   370 -0.3551767   0     1 -3.207531 0.8523183 1.0000000 0.9165166 #> 6   370 -0.3551767   1     1 -3.310361 0.9339574 0.9165166 1.0000000 #>                             cut duration sim #> 1 Max(min follow-up, event cut) 77.50178   1 #> 2 Max(min follow-up, event cut) 77.50178   1 #> 3 Max(min follow-up, event cut) 77.50178   1 #> 4 Max(min follow-up, event cut) 71.48793   2 #> 5 Max(min follow-up, event cut) 71.48793   2 #> 6 Max(min follow-up, event cut) 71.48793   2  # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up p <- xx |>   group_by(sim) |>   group_map(~ pvalue_maxcombo(.x)) |>   unlist() mean(p < .025) #> [1] 0.98"},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":null,"dir":"Reference","previous_headings":"","what":"Permuted fixed block randomization — randomize_by_fixed_block","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"Fixed block randomization. block input repeat treatment code number times included within block. final block partial block n exact multiple block length.","code":""},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"","code":"randomize_by_fixed_block(n = 10, block = c(0, 0, 1, 1))"},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"n Sample size randomized. block Vector treatments included block.","code":""},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"treatment group sequence (vector) length n treatments block permuted within block block size equal length block.","code":""},{"path":"https://merck.github.io/simtrial/reference/randomize_by_fixed_block.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permuted fixed block randomization — randomize_by_fixed_block","text":"","code":"library(dplyr)  # Example 1 # 2:1 randomization with block size 3, treatments \"A\" and \"B\" data.frame(x = 1:10) |> mutate(Treatment = randomize_by_fixed_block(block = c(\"A\", \"B\", \"B\"))) #>     x Treatment #> 1   1         B #> 2   2         A #> 3   3         B #> 4   4         B #> 5   5         A #> 6   6         B #> 7   7         B #> 8   8         B #> 9   9         A #> 10 10         B  # Example 2 # Stratified randomization data.frame(stratum = c(rep(\"A\", 10), rep(\"B\", 10))) |>   group_by(stratum) |>   mutate(Treatment = randomize_by_fixed_block()) #> # A tibble: 20 × 2 #> # Groups:   stratum [2] #>    stratum Treatment #>    <chr>       <dbl> #>  1 A               1 #>  2 A               0 #>  3 A               0 #>  4 A               1 #>  5 A               1 #>  6 A               0 #>  7 A               1 #>  8 A               0 #>  9 A               0 #> 10 A               0 #> 11 B               0 #> 12 B               1 #> 13 B               1 #> 14 B               0 #> 15 B               1 #> 16 B               0 #> 17 B               0 #> 18 B               1 #> 19 B               1 #> 20 B               1"},{"path":"https://merck.github.io/simtrial/reference/rpw_enroll.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate piecewise exponential enrollment — rpw_enroll","title":"Generate piecewise exponential enrollment — rpw_enroll","text":"piecewise exponential enrollment rate generation enrollment rate distribution can easily approximated. rpw_enroll() support simulation Lachin Foulkes (1986) sample size method (fixed trial duration) well Kim Tsiatis(1990) method (fixed enrollment rates either fixed enrollment duration fixed minimum follow-); see gsDesign::nSurv().","code":""},{"path":"https://merck.github.io/simtrial/reference/rpw_enroll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate piecewise exponential enrollment — rpw_enroll","text":"","code":"rpw_enroll(   n = NULL,   enroll_rate = data.frame(duration = c(1, 2), rate = c(2, 5)) )"},{"path":"https://merck.github.io/simtrial/reference/rpw_enroll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate piecewise exponential enrollment — rpw_enroll","text":"n Number observations. Default NULL yields random enrollment size. enroll_rate data frame containing period duration (duration) enrollment rate (rate). specified enrollment periods. necessary, last period extended ensure enrollment specified n.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpw_enroll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate piecewise exponential enrollment — rpw_enroll","text":"vector random enrollment times.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpw_enroll.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate piecewise exponential enrollment — rpw_enroll","text":"","code":"# Example 1 # Piecewise uniform (piecewise exponential inter-arrival times) for 10k patients enrollment # Enrollment rates of 5 for time 0-100, 15 for 100-300, and 30 thereafter x <- rpw_enroll(   n = 1e5,   enroll_rate = data.frame(     rate = c(5, 15, 30),     duration = c(100, 200, 100)   ) ) plot(x, 1:1e5,   main = \"Piecewise uniform enrollment simulation\",   xlab = \"Time\",   ylab = \"Enrollment\" )   # Example 2 # Exponential enrollment x <- rpw_enroll(   n = 1e5,   enroll_rate = data.frame(rate = .03, duration = 1) ) plot(x, 1:1e5,   main = \"Simulated exponential inter-arrival times\",   xlab = \"Time\",   ylab = \"Enrollment\" )"},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":null,"dir":"Reference","previous_headings":"","what":"The piecewise exponential distribution — rpwexp","title":"The piecewise exponential distribution — rpwexp","text":"piecewise exponential distribution allows simple method specify distribution hazard rate changes time. likely useful conditions failure rates change, also simulations may delayed treatment effect treatment effect otherwise changing (example, decreasing) time. rpwexp() support simulation Lachin Foulkes (1986) sample size method (fixed trial duration) well Kim Tsiatis(1990) method (fixed enrollment rates either fixed enrollment duration fixed minimum follow-); see gsDesign::nSurv().","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The piecewise exponential distribution — rpwexp","text":"","code":"rpwexp(n = 100, fail_rate = data.frame(duration = c(1, 1), rate = c(10, 20)))"},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The piecewise exponential distribution — rpwexp","text":"n Number observations generated. fail_rate data frame containing duration rate variables. rate specifies failure rates corresponding interval duration specified duration. final interval extended infinite ensure observations generated.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The piecewise exponential distribution — rpwexp","text":"Using cumulative = TRUE option, enrollment times piecewise constant time can generated.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The piecewise exponential distribution — rpwexp","text":"","code":"# Example 1 # Exponential failure times x <- rpwexp(   n = 10000,   fail_rate = data.frame(rate = 5, duration = 1) ) plot(sort(x), (10000:1) / 10001,   log = \"y\", main = \"Exponential simulated survival curve\",   xlab = \"Time\", ylab = \"P{Survival}\" )   # Example 2  # Get 10k piecewise exponential failure times. # Failure rates are 1 for time 0 to 0.5, 3 for time 0.5 to 1, and 10 for > 1. # Intervals specifies duration of each failure rate interval # with the final interval running to infinity. x <- rpwexp(   n = 1e4,   fail_rate = data.frame(rate = c(1, 3, 10), duration = c(.5, .5, 1)) ) plot(sort(x), (1e4:1) / 10001,   log = \"y\", main = \"PW Exponential simulated survival curve\",   xlab = \"Time\", ylab = \"P{Survival}\" )"},{"path":"https://merck.github.io/simtrial/reference/rpwexpRcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"The piecewise exponential distribution in C++ — rpwexpRcpp","title":"The piecewise exponential distribution in C++ — rpwexpRcpp","text":"piecewise exponential distribution C++","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexpRcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The piecewise exponential distribution in C++ — rpwexpRcpp","text":"","code":"rpwexpRcpp(n, fail_rate)"},{"path":"https://merck.github.io/simtrial/reference/rpwexpRcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The piecewise exponential distribution in C++ — rpwexpRcpp","text":"n Number observations generated. fail_rate data frame containing duration rate variables.","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexpinvRcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"The piecewise exponential distribution using inverse CDF method in C++ — rpwexpinvRcpp","title":"The piecewise exponential distribution using inverse CDF method in C++ — rpwexpinvRcpp","text":"piecewise exponential distribution using inverse CDF method C++","code":""},{"path":"https://merck.github.io/simtrial/reference/rpwexpinvRcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The piecewise exponential distribution using inverse CDF method in C++ — rpwexpinvRcpp","text":"","code":"rpwexpinvRcpp(n, fail_rate)"},{"path":"https://merck.github.io/simtrial/reference/rpwexpinvRcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The piecewise exponential distribution using inverse CDF method in C++ — rpwexpinvRcpp","text":"n Number observations generated. fail_rate data frame containing duration rate variables.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"sim_fixed_n() provides simulations single endpoint two-arm trial enrollment, hazard ratio, failure dropout rates change time.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"","code":"sim_fixed_n(   n_sim = 1000,   sample_size = 500,   target_event = 350,   stratum = data.frame(stratum = \"All\", p = 1),   enroll_rate = data.frame(duration = c(2, 2, 10), rate = c(3, 6, 9)),   fail_rate = data.frame(stratum = \"All\", duration = c(3, 100), fail_rate = log(2)/c(9,     18), hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)),   total_duration = 30,   block = rep(c(\"experimental\", \"control\"), 2),   timing_type = 1:5,   rho_gamma = data.frame(rho = 0, gamma = 0) )"},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"n_sim Number simulations perform. sample_size Total sample size per simulation. target_event Targeted event count analysis. stratum data frame stratum specified stratum, probability (incidence) stratum p. enroll_rate Piecewise constant enrollment rates time period. Note overall population enrollment rates stratum argument controls random distribution stratum. fail_rate Piecewise constant control group failure rates, hazard ratio experimental vs. control, dropout rates stratum time period. total_duration Total follow-start enrollment data cutoff. block sim_pw_surv(). Vector treatments included block. timing_type numeric vector determining data cutoffs used; see details. Default include available cutoff methods. rho_gamma fh_weight(). data frame variables rho gamma, greater equal zero, specify one Fleming-Harrington weighted logrank test per row.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"data frame including columns: event: Event count. ln_hr: Log-hazard ratio. z: Normal test statistic; < 0 favors experimental. cut: Text describing cutoff used. duration: Duration trial cutoff analysis. sim: Sequential simulation ID. One row per simulated dataset per cutoff specified timing_type, per test statistic specified. multiple Fleming-Harrington tests specified rho_gamma, columns rho gamma also included.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"timing_type 5 elements indicating different options data cutoff: 1: Uses planned study duration. 2: time targeted event count achieved. 3: planned minimum follow-enrollment complete. 4: maximum planned study duration targeted event count cuts (1 2). 5: maximum targeted event count minimum follow-cuts (2 3).","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_fixed_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of fixed sample size design for time-to-event endpoint — sim_fixed_n","text":"","code":"library(dplyr) library(future)  # Example 1 # Show output structure sim_fixed_n(n_sim = 3) #> Backend uses sequential processing. #>    event       ln_hr           z                              cut duration sim #> 1     83  0.01971738  0.08971129                 Planned duration 30.00000   1 #> 2    350 -0.44660434 -4.14870756                  Targeted events 76.42231   1 #> 3    357 -0.45730243 -4.29017887                Minimum follow-up 78.95750   1 #> 4    350 -0.44660434 -4.14870756 Max(planned duration, event cut) 76.42231   1 #> 5    357 -0.45730243 -4.29017887    Max(min follow-up, event cut) 78.95750   1 #> 6     91 -0.53035580 -2.51307652                 Planned duration 30.00000   2 #> 7    350 -0.32110592 -2.99705291                  Targeted events 68.41542   2 #> 8    371 -0.32877984 -3.15895909                Minimum follow-up 73.04302   2 #> 9    350 -0.32110592 -2.99705291 Max(planned duration, event cut) 68.41542   2 #> 10   371 -0.32877984 -3.15895909    Max(min follow-up, event cut) 73.04302   2 #> 11    95 -0.44491127 -2.14972553                 Planned duration 30.00000   3 #> 12   350 -0.40578241 -3.77852275                  Targeted events 69.17342   3 #> 13   355 -0.41392358 -3.88023391                Minimum follow-up 71.12040   3 #> 14   350 -0.40578241 -3.77852275 Max(planned duration, event cut) 69.17342   3 #> 15   355 -0.41392358 -3.88023391    Max(min follow-up, event cut) 71.12040   3  # Example 2 # Example with 2 tests: logrank and FH(0,1) sim_fixed_n(n_sim = 1, rho_gamma = data.frame(rho = 0, gamma = c(0, 1))) #> Backend uses sequential processing. #>    event       ln_hr rho gamma          z        v1        v2 #> 1    116 -0.07712287   0     0 -0.4150471 1.0000000 0.8405119 #> 2    116 -0.07712287   0     1 -0.5013790 0.8405119 1.0000000 #> 3    350 -0.28701600   0     0 -2.6752220 1.0000000 0.8506759 #> 4    350 -0.28701600   0     1 -3.3615245 0.8506759 1.0000000 #> 5    368 -0.28136928   0     0 -2.6893969 1.0000000 0.8557960 #> 6    368 -0.28136928   0     1 -3.3254973 0.8557960 1.0000000 #> 7    350 -0.28701600   0     0 -2.6752220 1.0000000 0.8506759 #> 8    350 -0.28701600   0     1 -3.3615245 0.8506759 1.0000000 #> 9    368 -0.28136928   0     0 -2.6893969 1.0000000 0.8557960 #> 10   368 -0.28136928   0     1 -3.3254973 0.8557960 1.0000000 #>                                 cut duration sim #> 1                  Planned duration 30.00000   1 #> 2                  Planned duration 30.00000   1 #> 3                   Targeted events 68.05234   1 #> 4                   Targeted events 68.05234   1 #> 5                 Minimum follow-up 73.61523   1 #> 6                 Minimum follow-up 73.61523   1 #> 7  Max(planned duration, event cut) 68.05234   1 #> 8  Max(planned duration, event cut) 68.05234   1 #> 9     Max(min follow-up, event cut) 73.61523   1 #> 10    Max(min follow-up, event cut) 73.61523   1  # Example 3 # Power by test # Only use cuts for events, events + min follow-up xx <- sim_fixed_n(   n_sim = 100,   timing_type = c(2, 5),   rho_gamma = data.frame(rho = 0, gamma = c(0, 1)) ) #> Backend uses sequential processing. # Get power approximation for FH, data cutoff combination xx |>   group_by(cut, rho, gamma) |>   summarize(mean(z <= qnorm(.025))) #> `summarise()` has grouped output by 'cut', 'rho'. You can override using the #> `.groups` argument. #> # A tibble: 4 × 4 #> # Groups:   cut, rho [2] #>   cut                             rho gamma `mean(z <= qnorm(0.025))` #>   <chr>                         <dbl> <dbl>                     <dbl> #> 1 Max(min follow-up, event cut)     0     0                      0.99 #> 2 Max(min follow-up, event cut)     0     1                      0.98 #> 3 Targeted events                   0     0                      0.96 #> 4 Targeted events                   0     1                      0.98  # MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up p <- xx |>   filter(cut != \"Targeted events\") |>   group_by(sim) |>   group_map(~ pvalue_maxcombo(.x)) |>   unlist()  mean(p < .025) #> [1] 0.99  # MaxCombo estimate for targeted events cutoff p <- xx |>   filter(cut == \"Targeted events\") |>   group_by(sim) |>   group_map(~ pvalue_maxcombo(.x)) |>   unlist()  mean(p < .025) #> [1] 0.99  # Example 3 # Use two cores set.seed(2023) plan(\"multisession\", workers = 2) sim_fixed_n(n_sim = 10) #> Using 2 cores with backend multisession #>    event      ln_hr          z                              cut duration sim #> 1    109 -0.3342849 -1.7348832                 Planned duration 30.00000   1 #> 2    350 -0.4793575 -4.4607622                  Targeted events 65.23187   1 #> 3    376 -0.4498374 -4.3411518                Minimum follow-up 73.17268   1 #> 4    350 -0.4793575 -4.4607622 Max(planned duration, event cut) 65.23187   1 #> 5    376 -0.4498374 -4.3411518    Max(min follow-up, event cut) 73.17268   1 #> 6    103 -0.2047494 -1.0356297                 Planned duration 30.00000   2 #> 7    350 -0.3873648 -3.5981660                  Targeted events 67.64612   2 #> 8    367 -0.3953215 -3.7665623                Minimum follow-up 72.56793   2 #> 9    350 -0.3873648 -3.5981660 Max(planned duration, event cut) 67.64612   2 #> 10   367 -0.3953215 -3.7665623    Max(min follow-up, event cut) 72.56793   2 #> 11    95 -0.8181040 -3.8898935                 Planned duration 30.00000   3 #> 12   350 -0.6662357 -6.1228581                  Targeted events 74.95821   3 #> 13   349 -0.6719858 -6.1652657                Minimum follow-up 74.72225   3 #> 14   350 -0.6662357 -6.1228581 Max(planned duration, event cut) 74.95821   3 #> 15   350 -0.6662357 -6.1228581    Max(min follow-up, event cut) 74.95821   3 #> 16   110 -0.1120785 -0.5861109                 Planned duration 30.00000   4 #> 17   350 -0.3939024 -3.6658988                  Targeted events 69.16631   4 #> 18   372 -0.3781111 -3.6289642                Minimum follow-up 73.68989   4 #> 19   350 -0.3939024 -3.6658988 Max(planned duration, event cut) 69.16631   4 #> 20   372 -0.3781111 -3.6289642    Max(min follow-up, event cut) 73.68989   4 #> 21    94 -0.6069906 -2.8943845                 Planned duration 30.00000   5 #> 22   350 -0.4410650 -4.1082391                  Targeted events 77.05035   5 #> 23   348 -0.4296748 -3.9894083                Minimum follow-up 76.68470   5 #> 24   350 -0.4410650 -4.1082391 Max(planned duration, event cut) 77.05035   5 #> 25   350 -0.4410650 -4.1082391    Max(min follow-up, event cut) 77.05035   5 #> 26   103 -0.5638412 -2.8176983                 Planned duration 30.00000   6 #> 27   350 -0.4227156 -3.9027737                  Targeted events 71.51268   6 #> 28   351 -0.4245379 -3.9272445                Minimum follow-up 72.34254   6 #> 29   350 -0.4227156 -3.9027737 Max(planned duration, event cut) 71.51268   6 #> 30   351 -0.4245379 -3.9272445    Max(min follow-up, event cut) 72.34254   6 #> 31   108 -0.1666295 -0.8633360                 Planned duration 30.00000   7 #> 32   350 -0.3453421 -3.2209226                  Targeted events 75.61250   7 #> 33   338 -0.3305844 -3.0299119                Minimum follow-up 72.99192   7 #> 34   350 -0.3453421 -3.2209226 Max(planned duration, event cut) 75.61250   7 #> 35   350 -0.3453421 -3.2209226    Max(min follow-up, event cut) 75.61250   7 #> 36   124 -0.2803523 -1.5523243                 Planned duration 30.00000   8 #> 37   350 -0.3478454 -3.2482694                  Targeted events 66.62160   8 #> 38   367 -0.3690357 -3.5288351                Minimum follow-up 70.19488   8 #> 39   350 -0.3478454 -3.2482694 Max(planned duration, event cut) 66.62160   8 #> 40   367 -0.3690357 -3.5288351    Max(min follow-up, event cut) 70.19488   8 #> 41   104 -0.1525416 -0.7765436                 Planned duration 30.00000   9 #> 42   350 -0.3069406 -2.8670291                  Targeted events 70.92746   9 #> 43   351 -0.3023229 -2.8280363                Minimum follow-up 71.28078   9 #> 44   350 -0.3069406 -2.8670291 Max(planned duration, event cut) 70.92746   9 #> 45   351 -0.3023229 -2.8280363    Max(min follow-up, event cut) 71.28078   9 #> 46   106 -0.3551148 -1.8105400                 Planned duration 30.00000  10 #> 47   350 -0.4077490 -3.8029263                  Targeted events 75.17856  10 #> 48   360 -0.4138911 -3.9105095                Minimum follow-up 76.94235  10 #> 49   350 -0.4077490 -3.8029263 Max(planned duration, event cut) 75.17856  10 #> 50   360 -0.4138911 -3.9105095    Max(min follow-up, event cut) 76.94235  10 plan(\"sequential\")"},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"sim_pw_surv() enables simulation clinical trial essentially arbitrary patterns enrollment, failure rates censoring. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure, dropout rate changes time. main purpose may generate trial can analyzed single point time using group sequential methods, routine can also used simulate adaptive trial design. Enrollment, failure, dropout rates specified treatment group, stratum time period. Fixed block randomization used; blocks must include treatments provided failure dropout specification. Default arguments set allow simple implementation non-proportional hazards assumption unstratified design.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"","code":"sim_pw_surv(   n = 100,   stratum = data.frame(stratum = \"All\", p = 1),   block = c(rep(\"control\", 2), rep(\"experimental\", 2)),   enroll_rate = data.frame(rate = 9, duration = 1),   fail_rate = data.frame(stratum = rep(\"All\", 4), period = rep(1:2, 2), treatment =     c(rep(\"control\", 2), rep(\"experimental\", 2)), duration = rep(c(3, 1), 2), rate =     log(2)/c(9, 9, 9, 18)),   dropout_rate = data.frame(stratum = rep(\"All\", 2), period = rep(1, 2), treatment =     c(\"control\", \"experimental\"), duration = rep(100, 2), rate = rep(0.001, 2)) )"},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"n Number observations. length(n) > 1, length taken number required. stratum data frame stratum specified stratum, probability (incidence) stratum p. block Vector treatments included block. enroll_rate Enrollment rates; see details examples. fail_rate Failure rates; see details examples; note treatments need input block. dropout_rate Dropout rates; see details examples; note treatments need input block.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"data frame following variables observation: stratum. enroll_time: Enrollment time observation. Treatment: Treatment group; one values input block. fail_time: Failure time generated using rpwexp(). dropout_time: Dropout time generated using rpwexp(). cte: Calendar time enrollment plot minimum failure time dropout time. fail: Indicator cte set using failure time; .e., 1 failure, 0 dropout.","code":""},{"path":"https://merck.github.io/simtrial/reference/sim_pw_surv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a stratified time-to-event outcome randomized trial — sim_pw_surv","text":"","code":"library(dplyr)  # Example 1 sim_pw_surv(n = 20) #>    stratum enroll_time    treatment  fail_time dropout_time        cte fail #> 1      All   0.1169701      control  2.3522782   726.236246  2.4692483    1 #> 2      All   0.1655561 experimental  7.2130199  1375.314370  7.3785759    1 #> 3      All   0.2203226      control  5.2816125   279.355397  5.5019351    1 #> 4      All   0.4589592 experimental  4.5824607    11.342590  5.0414199    1 #> 5      All   0.5161879 experimental  0.3408276    98.581064  0.8570155    1 #> 6      All   0.5525417 experimental 48.4943098  3940.428363 49.0468516    1 #> 7      All   0.6023998      control  7.9020486  1506.827622  8.5044484    1 #> 8      All   0.7313558      control  5.3501473     8.859702  6.0815032    1 #> 9      All   0.8013719 experimental  4.6297940   591.700214  5.4311659    1 #> 10     All   0.8438567      control  1.7559011    20.478716  2.5997577    1 #> 11     All   0.8919483      control  5.2311790   151.951748  6.1231272    1 #> 12     All   0.9181567 experimental 25.3045387  1074.127307 26.2226954    1 #> 13     All   1.0548415      control 20.0464765  1420.826969 21.1013180    1 #> 14     All   1.2705991 experimental  8.2785049   460.908456  9.5491040    1 #> 15     All   1.2920275 experimental  1.6351292   480.784251  2.9271566    1 #> 16     All   1.2945163      control 11.2924970   459.922500 12.5870132    1 #> 17     All   1.3919213 experimental 19.0080405    80.189760 20.3999618    1 #> 18     All   1.6078178      control 10.0045280   295.652900 11.6123458    1 #> 19     All   1.6174817      control  6.2319115   255.661979  7.8493933    1 #> 20     All   1.6770953 experimental  0.7551894   278.421726  2.4322847    1  # Example 2 # 3:1 randomization sim_pw_surv(   n = 20,   block = c(rep(\"experimental\", 3), \"control\") ) #>    stratum enroll_time    treatment  fail_time dropout_time       cte fail #> 1      All   0.0701005 experimental 67.0221105    1602.5241 67.092211    1 #> 2      All   0.3138125 experimental 23.9737611     189.7320 24.287574    1 #> 3      All   0.4815617      control  8.9365213     847.8221  9.418083    1 #> 4      All   0.7462000 experimental 20.2543626     699.6371 21.000563    1 #> 5      All   0.9607707 experimental 53.8871321     706.7815 54.847903    1 #> 6      All   1.0511800      control  0.1715598     255.8370  1.222740    1 #> 7      All   1.1067745 experimental 38.1885083    1101.2561 39.295283    1 #> 8      All   1.2658658 experimental 77.1229067    1447.0174 78.388772    1 #> 9      All   1.3559820      control  6.5343971     742.2296  7.890379    1 #> 10     All   1.3676125 experimental 58.7567835     251.6071 60.124396    1 #> 11     All   1.3691043 experimental 38.8468048     481.0761 40.215909    1 #> 12     All   1.4535872 experimental 13.4139827     596.6599 14.867570    1 #> 13     All   1.4727922 experimental  1.3089880    1697.0029  2.781780    1 #> 14     All   1.7945164 experimental 17.3633287    4614.3631 19.157845    1 #> 15     All   1.8293592 experimental 10.5662550      86.2281 12.395614    1 #> 16     All   1.8558251      control 10.2177042     685.6568 12.073529    1 #> 17     All   1.8972873 experimental  2.6178723    1819.2595  4.515160    1 #> 18     All   1.9490709 experimental  3.4084081     289.6376  5.357479    1 #> 19     All   1.9615621      control 51.0259561    1134.6053 52.987518    1 #> 20     All   2.0864015 experimental  2.3365045     384.2175  4.422906    1  # Example 3 # Simulate 2 stratum; will use defaults for blocking and enrollRates sim_pw_surv(   n = 20,   # 2 stratum,30% and 70% prevalence   stratum = data.frame(stratum = c(\"Low\", \"High\"), p = c(.3, .7)),   fail_rate = data.frame(     stratum = c(rep(\"Low\", 4), rep(\"High\", 4)),     period = rep(1:2, 4),     treatment = rep(c(       rep(\"control\", 2),       rep(\"experimental\", 2)     ), 2),     duration = rep(c(3, 1), 4),     rate = c(.03, .05, .03, .03, .05, .08, .07, .04)   ),   dropout_rate = data.frame(     stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),     period = rep(1, 4),     treatment = rep(c(\"control\", \"experimental\"), 2),     duration = rep(1, 4),     rate = rep(.001, 4)   ) ) #>    stratum enroll_time    treatment  fail_time dropout_time       cte fail #> 1     High   0.1863179 experimental  8.5527734    437.33867  8.739091    1 #> 2      Low   0.3170170      control 69.3565466    513.65581 69.673564    1 #> 3      Low   0.3427688 experimental 23.3040655    485.16067 23.646834    1 #> 4     High   0.3664647      control  4.1008854    790.71037  4.467350    1 #> 5      Low   0.6836981      control 23.9110679   1164.23533 24.594766    1 #> 6     High   0.7075722      control 17.5605004    397.54149 18.268073    1 #> 7      Low   0.7807614 experimental 26.2864537    475.16192 27.067215    1 #> 8     High   0.8097265 experimental  0.1926551     43.34721  1.002382    1 #> 9     High   0.8122659 experimental 15.0456185   4174.94331 15.857884    1 #> 10     Low   1.4281633 experimental 12.7370848   1625.11183 14.165248    1 #> 11    High   1.4808871 experimental 20.2331348    465.29175 21.714022    1 #> 12    High   1.5638285      control 23.0282302    759.05162 24.592059    1 #> 13    High   1.6907687      control 11.6284285   1004.53947 13.319197    1 #> 14    High   1.7629898 experimental  4.1098911   2189.41244  5.872881    1 #> 15    High   1.9106687      control  6.7833167    494.34540  8.693985    1 #> 16     Low   2.1112185 experimental  4.4710497   1487.11764  6.582268    1 #> 17    High   2.2452636      control 29.7332577     21.84553 24.090796    0 #> 18    High   2.4984987 experimental  1.8322780    361.39980  4.330777    1 #> 19     Low   2.8414901      control 41.3615037   2212.00385 44.202994    1 #> 20    High   3.0451995 experimental  0.8167457   3357.73901  3.861945    1 # Example 4 # If you want a more rectangular entry for a data.frame fail_rate <- bind_rows(   data.frame(stratum = \"Low\", period = 1, treatment = \"control\", duration = 3, rate = .03),   data.frame(stratum = \"Low\", period = 1, treatment = \"experimental\", duration = 3, rate = .03),   data.frame(stratum = \"Low\", period = 2, treatment = \"experimental\", duration = 3, rate = .02),   data.frame(stratum = \"High\", period = 1, treatment = \"control\", duration = 3, rate = .05),   data.frame(stratum = \"High\", period = 1, treatment = \"experimental\", duration = 3, rate = .06),   data.frame(stratum = \"High\", period = 2, treatment = \"experimental\", duration = 3, rate = .03) )  dropout_rate <- bind_rows(   data.frame(stratum = \"Low\", period = 1, treatment = \"control\", duration = 3, rate = .001),   data.frame(stratum = \"Low\", period = 1, treatment = \"experimental\", duration = 3, rate = .001),   data.frame(stratum = \"High\", period = 1, treatment = \"control\", duration = 3, rate = .001),   data.frame(stratum = \"High\", period = 1, treatment = \"experimental\", duration = 3, rate = .001) )  sim_pw_surv(   n = 12,   stratum = data.frame(stratum = c(\"Low\", \"High\"), p = c(.3, .7)),   fail_rate = fail_rate,   dropout_rate = dropout_rate ) #>    stratum enroll_time    treatment   fail_time dropout_time        cte fail #> 1      Low   0.0734264 experimental  19.8074367     65.86452  19.880863    1 #> 2     High   0.1289682      control   9.4633770   1250.15328   9.592345    1 #> 3     High   0.1502559 experimental   5.3931730   2506.43240   5.543429    1 #> 4      Low   0.4075359      control   0.2998111    347.07976   0.707347    1 #> 5     High   0.5873042 experimental   8.2992292    645.75643   8.886533    1 #> 6      Low   0.6447172 experimental  68.4701859    875.86457  69.114903    1 #> 7      Low   0.7176320      control  53.4130441    803.69807  54.130676    1 #> 8      Low   1.2571982 experimental 181.0733138    465.17781 182.330512    1 #> 9     High   1.3182567      control  31.2547073   2963.64946  32.572964    1 #> 10     Low   1.4377561 experimental  54.9043285    723.83802  56.342085    1 #> 11    High   1.6384161      control  27.0443860    403.53936  28.682802    1 #> 12    High   1.7007771 experimental   8.5890783   1027.30887  10.289855    1"},{"path":"https://merck.github.io/simtrial/reference/simfix2simpwsurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Conversion of enrollment and failure rates from sim_fixed_n() to\nsim_pw_surv() format — simfix2simpwsurv","title":"Conversion of enrollment and failure rates from sim_fixed_n() to\nsim_pw_surv() format — simfix2simpwsurv","text":"simfix2simpwsurv() converts failure rates dropout rates entered simpler format sim_fixed_n() used sim_pw_surv(). fail_rate argument sim_fixed_n() requires enrollment rates, failure rates hazard ratios dropout rates stratum 2-arm trial, sim_pw_surv() flexible less obvious flexible format. Since sim_fixed_n() automatically analyzes data sim_pw_surv() just produces simulation dataset, latter provides additional options analyze otherwise evaluate individual simulations ways sim_fixed_n() .","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix2simpwsurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conversion of enrollment and failure rates from sim_fixed_n() to\nsim_pw_surv() format — simfix2simpwsurv","text":"","code":"simfix2simpwsurv(   fail_rate = data.frame(stratum = \"All\", duration = c(3, 100), fail_rate = log(2)/c(9,     18), hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)) )"},{"path":"https://merck.github.io/simtrial/reference/simfix2simpwsurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conversion of enrollment and failure rates from sim_fixed_n() to\nsim_pw_surv() format — simfix2simpwsurv","text":"fail_rate Piecewise constant control group failure rates, hazard ratio experimental vs. control, dropout rates stratum time period.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix2simpwsurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conversion of enrollment and failure rates from sim_fixed_n() to\nsim_pw_surv() format — simfix2simpwsurv","text":"list two data frame components formatted sim_pw_surv(): fail_rate dropout_rate.","code":""},{"path":"https://merck.github.io/simtrial/reference/simfix2simpwsurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conversion of enrollment and failure rates from sim_fixed_n() to\nsim_pw_surv() format — simfix2simpwsurv","text":"","code":"# Example 1 # Convert standard input simfix2simpwsurv() #> $fail_rate #>   stratum period    treatment duration       rate #> 1     All      1      control        3 0.07701635 #> 2     All      2      control      100 0.03850818 #> 3     All      1 experimental        3 0.06931472 #> 4     All      2 experimental      100 0.02310491 #>  #> $dropout_rate #>   stratum period    treatment duration  rate #> 1     All      1      control        3 0.001 #> 2     All      2      control      100 0.001 #> 3     All      1 experimental        3 0.001 #> 4     All      2 experimental      100 0.001 #>   # Stratified example fail_rate <- data.frame(   stratum = c(rep(\"Low\", 3), rep(\"High\", 3)),   duration = rep(c(4, 10, 100), 2),   fail_rate = c(     .04, .1, .06,     .08, .16, .12   ),   hr = c(     1.5, .5, 2 / 3,     2, 10 / 16, 10 / 12   ),   dropout_rate = .01 )  x <- simfix2simpwsurv(fail_rate)  # Do a single simulation with the above rates # Enroll 300 patients in ~12 months at constant rate sim <- sim_pw_surv(   n = 300,   stratum = data.frame(stratum = c(\"Low\", \"High\"), p = c(.6, .4)),   enroll_rate = data.frame(duration = 12, rate = 300 / 12),   fail_rate = x$fail_rate,   dropout_rate = x$dropout_rate )  # Cut after 200 events and do a stratified logrank test dat <- sim |>   cut_data_by_event(200) |> # Cut data   counting_process(arm = \"experimental\") |> # Convert format for fh_weight()   fh_weight(rho_gamma = data.frame(rho = 0, gamma = 0)) # Stratified logrank"},{"path":"https://merck.github.io/simtrial/reference/simtrial-package.html","id":null,"dir":"Reference","previous_headings":"","what":"simtrial: Clinical Trial Simulation — simtrial-package","title":"simtrial: Clinical Trial Simulation — simtrial-package","text":"Provides basic routines simulating clinical trial. primary intent provide tools generate trial simulations trials time event outcomes. Piecewise exponential failure rates piecewise constant enrollment rates underlying mechanism used simulate broad range scenarios. However, basic generation data done using pipes allow maximum flexibility users meet different needs.","code":""},{"path":[]},{"path":"https://merck.github.io/simtrial/reference/simtrial-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"simtrial: Clinical Trial Simulation — simtrial-package","text":"Maintainer: Yujie Zhao yujie.zhao@merck.com [contributor] Authors: Keaven Anderson keaven_anderson@merck.com Yilong Zhang elong0527@gmail.com contributors: Nan Xiao [contributor] Jianxiao Yang [contributor] Lili Ling [contributor] Xintong Li [contributor] Ruixue Wang [contributor] Yi Cui [contributor] Ping Yang [contributor] Yalin Zhu [contributor] Heng Zhou [contributor] Amin Shirazi [contributor] Cole Manschot [contributor] John Blischak [contributor] Merck & Co., Inc., Rahway, NJ, USA affiliates [copyright holder]","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-020-august-2020","dir":"Changelog","previous_headings":"","what":"simtrial 0.2.0, August, 2020","title":"simtrial 0.2.0, August, 2020","text":"Updated vignettes web site Prepared Regulatory/Industry Training session September","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-0179004-february-2020","dir":"Changelog","previous_headings":"","what":"simtrial 0.1.7.9004, February, 2020","title":"simtrial 0.1.7.9004, February, 2020","text":"Added wMB() compute Magirr-Burman weights Added vignette demonstrate working different weighting schemes Replaced Depends Imports DESCRIPTION","code":""},{"path":"https://merck.github.io/simtrial/news/index.html","id":"simtrial-0179003-november-2019","dir":"Changelog","previous_headings":"","what":"simtrial 0.1.7.9003, November, 2019","title":"simtrial 0.1.7.9003, November, 2019","text":"Incorporated new functions simplify use (simfix, simfix2simPWSurv, pMaxCombo) Removed hgraph intent put release gsDesign Limited 2 essential vignettes Added continuous integration/continuous deployment (yaml) pkgdown web site development Limited dependencies essential; removed convenience functions related core package functionality","code":""}]
