---
title: "Parallel computing in `simfix`"
author: "Jianxiao Yang"
output:
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
    number_sections: true
---

```{r}
sessionInfo()
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  dev = "ragg_png",
  dpi = 96,
  fig.retina = 1,
  fig.width = 7.2916667,
  fig.asp = 1,
  fig.align = "center",
  out.width = "80%")

library(simtrial)
library(knitr)
library(tibble)
library(dplyr)
library(gt)
library(ggplot2)
library(profvis)
library(bench)
library(microbenchmark)
library(PWEALL)
library(parallel)
library(doParallel)
devtools::load_all()

# ggplot2 theme ----------------------------------------------------------------

theme_mk <- function(font_size = 14, font_family = "sans", line_size = .5,
                     rel_small = 12 / 14, rel_tiny = 11 / 14, rel_large = 16 / 14,
                     border_type = c("half", "full", "none"),
                     grid_x = FALSE, grid_y = FALSE) {
  half_line <- font_size / 2
  small_size <- rel_small * font_size
  border_type <- match.arg(border_type)

  # work off of theme_grey just in case some new theme element comes along
  theme_grey(base_size = font_size, base_family = font_family) %+replace%
    theme(
      line = element_line(color = "black", size = line_size, linetype = 1, lineend = "butt"),
      rect = element_rect(fill = NA, color = NA, size = line_size, linetype = 1),
      text = element_text(
        family = font_family, face = "plain", color = "black",
        size = font_size, hjust = 0.5, vjust = 0.5, angle = 0, lineheight = .9,
        margin = margin(), debug = FALSE
      ),
      axis.line = element_line(color = "black", size = line_size, linetype = as.numeric(border_type == "half"), lineend = "square"),
      axis.line.x = NULL,
      axis.line.y = NULL,
      axis.text = element_text(color = "black", size = small_size),
      axis.text.x = element_text(margin = margin(t = small_size / 4), vjust = 1),
      axis.text.x.top = element_text(margin = margin(b = small_size / 4), vjust = 0),
      axis.text.y = element_text(margin = margin(r = small_size / 4), hjust = 1),
      axis.text.y.right = element_text(margin = margin(l = small_size / 4), hjust = 0),
      axis.ticks = element_line(color = "black", size = line_size),
      axis.ticks.length = unit(half_line / 2, "pt"),
      axis.title.x = element_text(
        margin = margin(t = half_line / 2),
        vjust = 1
      ),
      axis.title.x.top = element_text(
        margin = margin(b = half_line / 2),
        vjust = 0
      ),
      axis.title.y = element_text(
        angle = 90,
        margin = margin(r = half_line / 2),
        vjust = 1
      ),
      axis.title.y.right = element_text(
        angle = -90,
        margin = margin(l = half_line / 2),
        vjust = 0
      ),
      legend.background = element_blank(),
      legend.spacing = unit(font_size, "pt"),
      legend.spacing.x = NULL,
      legend.spacing.y = NULL,
      legend.margin = margin(0, 0, 0, 0),
      legend.key = element_blank(),
      legend.key.size = unit(1.1 * font_size, "pt"),
      legend.key.height = NULL,
      legend.key.width = NULL,
      legend.text = element_text(size = rel(rel_small)),
      legend.text.align = NULL,
      legend.title = element_text(hjust = 0),
      legend.title.align = NULL,
      legend.position = "right",
      legend.direction = NULL,
      legend.justification = c("left", "center"),
      legend.box = NULL,
      legend.box.margin = margin(0, 0, 0, 0),
      legend.box.background = element_blank(),
      legend.box.spacing = unit(font_size, "pt"),
      panel.background = element_blank(),
      panel.border = element_rect(fill = NA, color = "black", size = line_size, linetype = as.numeric(border_type == "full")),
      panel.grid.major = NULL,
      panel.grid.minor = NULL,
      panel.grid.major.x = element_line(color = "grey85", size = line_size, linetype = as.numeric(grid_x)),
      panel.grid.major.y = element_line(color = "grey85", size = line_size, linetype = as.numeric(grid_y)),
      panel.grid.minor.x = NULL,
      panel.grid.minor.y = NULL,
      panel.spacing = unit(half_line, "pt"),
      panel.spacing.x = NULL,
      panel.spacing.y = NULL,
      panel.ontop = FALSE,
      strip.background = element_rect(fill = "grey80"),
      strip.text = element_text(
        size = rel(rel_small),
        margin = margin(
          half_line / 2, half_line / 2,
          half_line / 2, half_line / 2
        )
      ),
      strip.text.x = NULL,
      strip.text.y = element_text(angle = -90),
      strip.placement = "inside",
      strip.placement.x = NULL,
      strip.placement.y = NULL,
      strip.switch.pad.grid = unit(half_line / 2, "pt"),
      strip.switch.pad.wrap = unit(half_line / 2, "pt"),
      plot.background = element_blank(),
      plot.title = element_text(
        face = "bold",
        size = rel(rel_large),
        hjust = 0, vjust = 1,
        margin = margin(b = half_line)
      ),
      plot.subtitle = element_text(
        size = rel(rel_small),
        hjust = 0, vjust = 1,
        margin = margin(b = half_line)
      ),
      plot.caption = element_text(
        size = rel(rel_tiny),
        hjust = 1, vjust = 1,
        margin = margin(t = half_line)
      ),
      plot.tag = element_text(
        face = "bold",
        hjust = 0, vjust = 0.7
      ),
      plot.tag.position = c(0, 1),
      plot.margin = margin(half_line, half_line, half_line, half_line),
      complete = TRUE
    )
}

# ggplot2 color palettes -------------------------------------------------------

#' Adaptive palette (discrete)
#'
#' Create a discrete palette that will use the first `n` colors from
#' the supplied color values when the palette has enough colors.
#' Otherwise, use an interpolated color palette.
#'
#' @param values Color values.
pal_ramp <- function(values) {
  force(values)
  function(n) {
    if (n <= length(values)) {
      values[seq_len(n)]
    } else {
      colorRampPalette(values, alpha = TRUE)(n)
    }
  }
}

#' Adaptive color palette generator
#'
#' Adaptive color palette generator for ggsci color palettes using `pal_ramp()`.
#'
#' @param name Color palette name
#' @param alpha Transparency level, a real number in (0, 1].
pal_adaptive <- function(name, alpha = 1) {
  if (alpha > 1L | alpha <= 0L) stop("alpha must be in (0, 1]")

  raw_cols <- simtrial_pal_hex[[name]]
  raw_cols_rgb <- col2rgb(raw_cols)
  alpha_cols <- rgb(
    raw_cols_rgb[1L, ], raw_cols_rgb[2L, ], raw_cols_rgb[3L, ],
    alpha = alpha * 255L, names = names(raw_cols),
    maxColorValue = 255L
  )

  pal_ramp(unname(alpha_cols))
}

simtrial_pal_hex <- list(
  "d3.category10" = c(
    "#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD", "#8C564B",
    "#E377C2", "#7F7F7F", "#BCBD22", "#17BECF"
  ),
  "d3.category20" = c(
    "#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD", "#8C564B",
    "#E377C2", "#7F7F7F", "#BCBD22", "#17BECF", "#AEC7E8", "#FFBB78",
    "#98DF8A", "#FF9896", "#C5B0D5", "#C49C94", "#F7B6D2", "#C7C7C7",
    "#DBDB8D", "#9EDAE5"
  ),
  "d3.category20b" = c(
    "#393B79", "#637939", "#8C6D31", "#843C39", "#7B4173", "#5254A3",
    "#8CA252", "#BD9E39", "#AD494A", "#A55194", "#6B6ECF", "#B5CF6B",
    "#E7BA52", "#D6616B", "#CE6DBD", "#9C9EDE", "#CEDB9C", "#E7CB94",
    "#E7969C", "#DE9ED6"
  ),
  "d3.category20c" = c(
    "#3182BD", "#E6550D", "#31A354", "#756BB1", "#636363", "#6BAED6",
    "#FD8D3C", "#74C476", "#9E9AC8", "#969696", "#9ECAE1", "#FDAE6B",
    "#A1D99B", "#BCBDDC", "#BDBDBD", "#C6DBEF", "#FDD0A2", "#C7E9C0",
    "#DADAEB", "#D9D9D9"
  ),
  "okabe-ito" = c(
    "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00",
    "#CC79A7", "#999999"
  ),
  "teal" = c(
    "#00857C", "#6ECEB2", "#BFED33", "#FFF063", "#0C2340", "#5450E4",
    "#688CE8", "#69B8F7"
  )
)

#' Adaptive color scales
#'
#' @inheritParams pal_adaptive
#' @param ... additional parameters for [ggplot2::discrete_scale()].
scale_color_adaptive <- function(name, alpha = 1, ...) {
  ggplot2::discrete_scale("colour", name, pal_adaptive(name, alpha), ...)
}

scale_fill_adaptive <- function(name, alpha = 1, ...) {
  ggplot2::discrete_scale("fill", name, pal_adaptive(name, alpha), ...)
}
```

# Data

In this example, we consider

- 2 strata
- 2 periods in enrollments
- 4 periods in failure rates of the control arm per stratum
- 4 periods in failure rates of the experimental arm per stratum
- 4 periods in dropout rates of the control arm per stratum
- 4 periods in dropout rates of the experimental arm per stratum

```{r data}
# 2 strata: Biomarker negative (50% of population) + Biomarker positive (50% of population); 
enrollStrata <- tibble(Stratum = c("Biomarker Negative", "Biomarker Positive"), p = c(.5, .5))

block <- c(rep("Control", 2), rep("Experimental", 2))

# enrollment over 1 year, with ramp-up over first 6 months
enrollRates <- tibble(rate = c(9, 2), duration = c(6, 6))

# failure rate:
# - biomarker negative: control is exponential with median of 12 months; experimental has HR = 1.2 for 4 months followed by HR=.65
# - biomarker positive: control is exponential with median of 12 months; experimental has HR = .9 for 4 months followed by HR=.4)
failRates <- tibble(
  Stratum = c(rep("Biomarker Negative", 3), rep("Biomarker Positive", 3)),
  period = c(1, 1:2, 1, 1:2),
  Treatment = rep(c("Control", rep("Experimental", 2)), 2),
  duration = c(12, 4, 8, 12, 4, 8), 
  rate = c(log(2)/12, log(2)/12*1.2, log(2)/12*0.65, log(2)/12, log(2)/12*0.9, log(2)/12*0.4)
)

# dropout rate
dropoutRates <- tibble(
  Stratum = c(rep("Biomarker Negative", 4), rep("Biomarker Positive", 4)),
  period = rep(1:2, 4),
  Treatment = rep(c(rep("Control", 2), rep("Experimental", 2)), 2),
  duration = rep(c(3, 1), 4),
  rate = rep(c(.001, .001), 4)
)

# Create failRatesAll for simfix
failRatesAll <- failRates[failRates$Treatment == "Experimental", ]
failRatesAll$dropoutRate <- dropoutRates[dropoutRates$Treatment == "Experimental", ]$rate
failRatesAll$hr <- c(rep(0.6, 2), rep(0.9, 2))
failRatesAll <- failRatesAll %>%
  mutate(failRate = rate/hr) %>%
  select("Stratum", "duration", "failRate", "hr", "dropoutRate")
rg <- tibble(rho = 0, gamma = 0)
```


# Number of available cores
```{r detectCores}
detectCores()
```


# Experiments

## Functions
```{r functions}
runSimfixVarCores <- function(
  ncores = c(1L, 2L, 4L, 8L), # Number of cores
  runsimfixNew = FALSE, # Run simfix or simfixNew
  nsim = 1000, # Number of simulations
  sampleSize = 800, # Trial sample size
  targetEvents = 350, # Targeted events at analysis
  totalDuration = 30, # Planned trial duration
  timingType = 1:5 # Use all possible data cutoff methods
  ) {
  if (!is.integer(ncores)) stop("Number of cores must be integer")
  if (min(ncores) != 1) stop("Number of cores must be positive")
  if (length(ncores) < 2) stop("Multiple cores are required for parallel computing.")
  ncores <- unique(ncores)
  ncores <- sort(ncores)
  
  times <- rep(0, length(ncores))

  if (runsimfixNew == FALSE) { # simfix

    # In serial
    registerDoParallel(1)
    start <- Sys.time()
    s <- simfix(
      nsim = nsim, # Number of simulations
      sampleSize = sampleSize, # Trial sample size
      targetEvents = targetEvents, # Targeted events at analysis
      enrollStrata = enrollStrata, # Study strata
      enrollRates = enrollRates, # Enrollment rates
      failRates = failRatesAll, # Failure rates
      totalDuration = totalDuration, # Planned trial duration
      block = block, # Block for treatment
      timingType = timingType, # Use all possible data cutoff methods
      rg = rg, # FH test(s) to use; in this case, logrank
      setSeed = TRUE
    )
    times[1] <- difftime(Sys.time(), start, units = "sec")[[1]]
    doParallel::stopImplicitCluster()

    # In parallel
    for (i in 2:length(ncores)) {
      registerDoParallel(ncores[i])
      start <- Sys.time()
      sp <- simfix(
        nsim = nsim, # Number of simulations
        sampleSize = sampleSize, # Trial sample size
        targetEvents = targetEvents, # Targeted events at analysis
        enrollStrata = enrollStrata, # Study strata
        enrollRates = enrollRates, # Enrollment rates
        failRates = failRatesAll, # Failure rates
        totalDuration = totalDuration, # Planned trial duration
        block = block, # Block for treatment
        timingType = timingType, # Use all possible data cutoff methods
        rg = rg, # FH test(s) to use; in this case, logrank
        setSeed = TRUE
      )
      times[i] <- difftime(Sys.time(), start, units = "sec")[[1]]
      doParallel::stopImplicitCluster()
      message("Results are identical: ", identical(s, sp))
    }
  } else { # simfixNew

    # In serial
    registerDoParallel(1)
    start <- Sys.time()
    s <- simfixNew(
      nsim = nsim, # Number of simulations
      sampleSize = sampleSize, # Trial sample size
      targetEvents = targetEvents, # Targeted events at analysis
      enrollStrata = enrollStrata, # Study strata
      enrollRates = enrollRates, # Enrollment rates
      failRates = failRatesAll, # Failure rates
      totalDuration = totalDuration, # Planned trial duration
      block = block, # Block for treatment
      timingType = timingType, # Use all possible data cutoff methods
      rg = rg, # FH test(s) to use; in this case, logrank
      setSeed = TRUE
    )
    times[1] <- difftime(Sys.time(), start, units = "sec")[[1]]
    doParallel::stopImplicitCluster()

    # In parallel
    for (i in 2:length(ncores)) {
      registerDoParallel(ncores[i])
      start <- Sys.time()
      sp <- simfixNew(
        nsim = nsim, # Number of simulations
        sampleSize = sampleSize, # Trial sample size
        targetEvents = targetEvents, # Targeted events at analysis
        enrollStrata = enrollStrata, # Study strata
        enrollRates = enrollRates, # Enrollment rates
        failRates = failRatesAll, # Failure rates
        totalDuration = totalDuration, # Planned trial duration
        block = block, # Block for treatment
        timingType = timingType, # Use all possible data cutoff methods
        rg = rg, # FH test(s) to use; in this case, logrank
        setSeed = TRUE
      )
      times[i] <- difftime(Sys.time(), start, units = "sec")[[1]]
      doParallel::stopImplicitCluster()
      message("Results are identical: ", identical(s, sp))
    }
  }
  
  return (times)
}

runAndPlotSimfixVarCores <- function(
  ncores = c(1L, 2L, 4L, 8L), # Number of cores
  nsim = 1000, # Number of simulations
  sampleSize = 800, # Trial sample size
  targetEvents = 350, # Targeted events at analysis
  totalDuration = 30, # Planned trial duration
  timingType = 1:5 # Use all possible data cutoff methods
) {
  
  # Run simfix and simfixNew in serial and in parallel
  times <- runSimfixVarCores(nsim = nsim,
                             ncores = ncores,
                             sampleSize = sampleSize,
                             targetEvents = targetEvents,
                             totalDuration = totalDuration,
                             timingType = timingType)
  times_new <- runSimfixVarCores(nsim = nsim,
                             ncores = ncores,
                             runsimfixNew = TRUE,
                             sampleSize = sampleSize,
                             targetEvents = targetEvents,
                             totalDuration = totalDuration,
                             timingType = timingType)

  # Reshape timing results for plot
  df_times<- data.frame(x = sort(ncores),
                              y = c(times,
                                    times_new),
                              fun = c(rep("simfix", length(ncores)),
                                      rep("simfixNew", length(ncores))))
  pl_times <- ggplot(df_times, aes(x, y, col = fun)) +
    geom_line() +
    geom_point() +
    scale_x_continuous(trans='log2', breaks = ncores) +
    labs(x = "Number of cores", y = paste0("Run time (in second)"),
         title = paste0(nsim, " simulations")) +
    theme_mk() +
    scale_color_adaptive("teal") +
    theme(legend.title=element_blank(),
          legend.position="bottom",
          legend.justification = "center",
          aspect.ratio=1)
  
  # Table
  tb_times <- t(data.frame(cores = as.character(sort(ncores)),
                           simfix = times,
                           simfixNew = times_new))
  # kable(tb_times)
  
  return (list(plot = pl_times,
               df = tb_times))
}

runAndPlotSimfixVarCoresVarSims <- function(
  ncores = c(1L, 2L, 4L, 8L), # Number of cores
  nsims = c(1000, 2000, 3000, 4000, 5000), # Number of simulations
  sampleSize = 800, # Trial sample size
  targetEvents = 350, # Targeted events at analysis
  totalDuration = 30, # Planned trial duration
  timingType = 1:5 # Use all possible data cutoff methods
) {
  
  nsims <- sort(nsims)
  times_all <- rep(0, length(ncores) * length(nsims) * 2)
  labels_all <- character(length = length(ncores) * length(nsims) * 2)
  sims_all <- rep(0, length(ncores) * length(nsims) * 2)
  for (i in 1:length(nsims)) {
    s1 = (i-1) * length(ncores) * 2 + 1
    e1 = s1 + length(ncores) - 1
    s2 = e1 + 1
    e2 = i * length(ncores) * 2
    # Run simfix and simfixNew in serial and in parallel
    times_all[s1:e1] <- runSimfixVarCores(nsim = nsims[i],
                               ncores = ncores,
                               sampleSize = sampleSize,
                               targetEvents = targetEvents,
                               totalDuration = totalDuration,
                               timingType = timingType)
    times_all[s2:e2] <- runSimfixVarCores(nsim = nsims[i],
                               ncores = ncores,
                               runsimfixNew = TRUE,
                               sampleSize = sampleSize,
                               targetEvents = targetEvents,
                               totalDuration = totalDuration,
                               timingType = timingType)
    
    sims_all[s1:e2] <- rep(nsims[i], length(ncores) * 2)
    for (j in 1:length(ncores)) {
      labels_all[s1] <- paste0("simfix ", ncores[j], " core")
      labels_all[s2] <- paste0("simfixNew ", ncores[j], " core")
      s1 = s1+1
      s2 = s2+1
    }
  }

  # Reshape timing results for plot
  df_times<- data.frame(x = sims_all,
                        y = times_all,
                        group = labels_all)

  pl_times <- ggplot(df_times, aes(x, y, col = group)) +
    geom_line() +
    geom_point() +
    scale_x_continuous(breaks = nsims) +
    labs(x = "Number of simulations", y = paste0("Run time (in second)")) +
    theme_mk() +
    scale_color_adaptive("teal") +
    theme(legend.title=element_blank(),
          legend.position="bottom",
          legend.justification = "center",
          aspect.ratio=1)
  
  # Table
  tb_times <- rbind(nsims = c("simulations", as.character(nsims)),
                    reshape(df_times,
                            idvar = "group",
                            timevar = "x",
                            direction = "wide"))
  names(tb_times) <- NULL

  return (list(plot = pl_times,
               df = tb_times))
}
```

## Fixed number of simulations

### 1000 simulations
```{r 1000sims}
n_sim <- 1000 # number of simulations in simfix
n_cores <- c(1L, 2L, 4L, 8L)

# Run simfix and simfixNew in serial and in parallel
test1000 <- runAndPlotSimfixVarCores(nsim = n_sim, ncores = n_cores)

# Plot and table
test1000$plot
kable(test1000$df)
```


## Varying number of simulations

### 1000 to 5000 simulations
```{r varsims}
n_sims <- c(1000, 2000, 3000, 4000, 5000)
n_cores <- c(1L, 2L, 4L, 8L)

# Run simfix and simfixNew in serial and in parallel
testVar <- runAndPlotSimfixVarCoresVarSims(nsims = n_sims, ncores = n_cores)

# Plot and table
testVar$plot
kable(testVar$df)
```

