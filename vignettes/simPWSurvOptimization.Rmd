---
title: "Optimization of `simPWSurv` and `rpwexp` "
author: "Jianxiao Yang"
output:
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
    number_sections: true
---

```{r}
sessionInfo()
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(simtrial)
library(knitr)
library(tibble)
library(dplyr)
library(gt)
library(ggplot2)
library(bench)
library(microbenchmark)
library(PWEALL)
devtools::load_all()


# ggplot2 theme ----------------------------------------------------------------

theme_mk <- function(font_size = 14, font_family = "sans", line_size = .5,
                     rel_small = 12 / 14, rel_tiny = 11 / 14, rel_large = 16 / 14,
                     border_type = c("half", "full", "none"),
                     grid_x = FALSE, grid_y = FALSE) {
  half_line <- font_size / 2
  small_size <- rel_small * font_size
  border_type <- match.arg(border_type)

  # work off of theme_grey just in case some new theme element comes along
  theme_grey(base_size = font_size, base_family = font_family) %+replace%
    theme(
      line = element_line(color = "black", size = line_size, linetype = 1, lineend = "butt"),
      rect = element_rect(fill = NA, color = NA, size = line_size, linetype = 1),
      text = element_text(
        family = font_family, face = "plain", color = "black",
        size = font_size, hjust = 0.5, vjust = 0.5, angle = 0, lineheight = .9,
        margin = margin(), debug = FALSE
      ),
      axis.line = element_line(color = "black", size = line_size, linetype = as.numeric(border_type == "half"), lineend = "square"),
      axis.line.x = NULL,
      axis.line.y = NULL,
      axis.text = element_text(color = "black", size = small_size),
      axis.text.x = element_text(margin = margin(t = small_size / 4), vjust = 1),
      axis.text.x.top = element_text(margin = margin(b = small_size / 4), vjust = 0),
      axis.text.y = element_text(margin = margin(r = small_size / 4), hjust = 1),
      axis.text.y.right = element_text(margin = margin(l = small_size / 4), hjust = 0),
      axis.ticks = element_line(color = "black", size = line_size),
      axis.ticks.length = unit(half_line / 2, "pt"),
      axis.title.x = element_text(
        margin = margin(t = half_line / 2),
        vjust = 1
      ),
      axis.title.x.top = element_text(
        margin = margin(b = half_line / 2),
        vjust = 0
      ),
      axis.title.y = element_text(
        angle = 90,
        margin = margin(r = half_line / 2),
        vjust = 1
      ),
      axis.title.y.right = element_text(
        angle = -90,
        margin = margin(l = half_line / 2),
        vjust = 0
      ),
      legend.background = element_blank(),
      legend.spacing = unit(font_size, "pt"),
      legend.spacing.x = NULL,
      legend.spacing.y = NULL,
      legend.margin = margin(0, 0, 0, 0),
      legend.key = element_blank(),
      legend.key.size = unit(1.1 * font_size, "pt"),
      legend.key.height = NULL,
      legend.key.width = NULL,
      legend.text = element_text(size = rel(rel_small)),
      legend.text.align = NULL,
      legend.title = element_text(hjust = 0),
      legend.title.align = NULL,
      legend.position = "right",
      legend.direction = NULL,
      legend.justification = c("left", "center"),
      legend.box = NULL,
      legend.box.margin = margin(0, 0, 0, 0),
      legend.box.background = element_blank(),
      legend.box.spacing = unit(font_size, "pt"),
      panel.background = element_blank(),
      panel.border = element_rect(fill = NA, color = "black", size = line_size, linetype = as.numeric(border_type == "full")),
      panel.grid.major = NULL,
      panel.grid.minor = NULL,
      panel.grid.major.x = element_line(color = "grey85", size = line_size, linetype = as.numeric(grid_x)),
      panel.grid.major.y = element_line(color = "grey85", size = line_size, linetype = as.numeric(grid_y)),
      panel.grid.minor.x = NULL,
      panel.grid.minor.y = NULL,
      panel.spacing = unit(half_line, "pt"),
      panel.spacing.x = NULL,
      panel.spacing.y = NULL,
      panel.ontop = FALSE,
      strip.background = element_rect(fill = "grey80"),
      strip.text = element_text(
        size = rel(rel_small),
        margin = margin(
          half_line / 2, half_line / 2,
          half_line / 2, half_line / 2
        )
      ),
      strip.text.x = NULL,
      strip.text.y = element_text(angle = -90),
      strip.placement = "inside",
      strip.placement.x = NULL,
      strip.placement.y = NULL,
      strip.switch.pad.grid = unit(half_line / 2, "pt"),
      strip.switch.pad.wrap = unit(half_line / 2, "pt"),
      plot.background = element_blank(),
      plot.title = element_text(
        face = "bold",
        size = rel(rel_large),
        hjust = 0, vjust = 1,
        margin = margin(b = half_line)
      ),
      plot.subtitle = element_text(
        size = rel(rel_small),
        hjust = 0, vjust = 1,
        margin = margin(b = half_line)
      ),
      plot.caption = element_text(
        size = rel(rel_tiny),
        hjust = 1, vjust = 1,
        margin = margin(t = half_line)
      ),
      plot.tag = element_text(
        face = "bold",
        hjust = 0, vjust = 0.7
      ),
      plot.tag.position = c(0, 1),
      plot.margin = margin(half_line, half_line, half_line, half_line),
      complete = TRUE
    )
}

# ggplot2 color palettes -------------------------------------------------------

#' Adaptive palette (discrete)
#'
#' Create a discrete palette that will use the first `n` colors from
#' the supplied color values when the palette has enough colors.
#' Otherwise, use an interpolated color palette.
#'
#' @param values Color values.
pal_ramp <- function(values) {
  force(values)
  function(n) {
    if (n <= length(values)) {
      values[seq_len(n)]
    } else {
      colorRampPalette(values, alpha = TRUE)(n)
    }
  }
}

#' Adaptive color palette generator
#'
#' Adaptive color palette generator for ggsci color palettes using `pal_ramp()`.
#'
#' @param name Color palette name
#' @param alpha Transparency level, a real number in (0, 1].
pal_adaptive <- function(name, alpha = 1) {
  if (alpha > 1L | alpha <= 0L) stop("alpha must be in (0, 1]")

  raw_cols <- simtrial_pal_hex[[name]]
  raw_cols_rgb <- col2rgb(raw_cols)
  alpha_cols <- rgb(
    raw_cols_rgb[1L, ], raw_cols_rgb[2L, ], raw_cols_rgb[3L, ],
    alpha = alpha * 255L, names = names(raw_cols),
    maxColorValue = 255L
  )

  pal_ramp(unname(alpha_cols))
}

simtrial_pal_hex <- list(
  "d3.category10" = c(
    "#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD", "#8C564B",
    "#E377C2", "#7F7F7F", "#BCBD22", "#17BECF"
  ),
  "d3.category20" = c(
    "#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD", "#8C564B",
    "#E377C2", "#7F7F7F", "#BCBD22", "#17BECF", "#AEC7E8", "#FFBB78",
    "#98DF8A", "#FF9896", "#C5B0D5", "#C49C94", "#F7B6D2", "#C7C7C7",
    "#DBDB8D", "#9EDAE5"
  ),
  "d3.category20b" = c(
    "#393B79", "#637939", "#8C6D31", "#843C39", "#7B4173", "#5254A3",
    "#8CA252", "#BD9E39", "#AD494A", "#A55194", "#6B6ECF", "#B5CF6B",
    "#E7BA52", "#D6616B", "#CE6DBD", "#9C9EDE", "#CEDB9C", "#E7CB94",
    "#E7969C", "#DE9ED6"
  ),
  "d3.category20c" = c(
    "#3182BD", "#E6550D", "#31A354", "#756BB1", "#636363", "#6BAED6",
    "#FD8D3C", "#74C476", "#9E9AC8", "#969696", "#9ECAE1", "#FDAE6B",
    "#A1D99B", "#BCBDDC", "#BDBDBD", "#C6DBEF", "#FDD0A2", "#C7E9C0",
    "#DADAEB", "#D9D9D9"
  ),
  "okabe-ito" = c(
    "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00",
    "#CC79A7", "#999999"
  ),
  "teal" = c(
    "#00857C", "#6ECEB2", "#BFED33", "#FFF063", "#0C2340", "#5450E4",
    "#688CE8", "#69B8F7"
  )
)

#' Adaptive color scales
#'
#' @inheritParams pal_adaptive
#' @param ... additional parameters for [ggplot2::discrete_scale()].
scale_color_adaptive <- function(name, alpha = 1, ...) {
  ggplot2::discrete_scale("colour", name, pal_adaptive(name, alpha), ...)
}

scale_fill_adaptive <- function(name, alpha = 1, ...) {
  ggplot2::discrete_scale("fill", name, pal_adaptive(name, alpha), ...)
}
```


# Data

In this example, we consider

- 7 strata
- 10 periods in enrollments
- 4 periods in failure rates of the control arm per stratum
- 5 periods in failure rates of the experimental arm per stratum
- 4 periods in dropout rates of the control arm per stratum
- 5 periods in dropout rates of the experimental arm per stratum

```{r}
# 1.1 Set up Strata & Block
strata <- tibble(
  Stratum = c("A", "B", "C", "D", "E", "F", "G"), 
  p = c(rep(0.1, 4), rep(0.2, 3)))
  
block <- c(rep("Control", 2), rep("Experimental", 2))

# 1.2 Set up Enrollment Rates
enrollRates <- bind_rows(
   # control arm - low stratum - 4 periods
   tibble(period = 1,  duration = 2, rate = 9),
   tibble(period = 2,  duration = 3, rate = 10),
   tibble(period = 3,  duration = 4, rate = 11),
   tibble(period = 4,  duration = 5, rate = 12),
   tibble(period = 5,  duration = 2, rate = 5),
   tibble(period = 6,  duration = 1, rate = 6),
   tibble(period = 7,  duration = 3, rate = 7),
   tibble(period = 8,  duration = 2, rate = 8),
   tibble(period = 9,  duration = 2, rate = 4),
   tibble(period = 10, duration = 1, rate = 2)
)

# 1.3 Set up Failure Rates
failRates <- bind_rows(
   # stratum A 
   tibble(Stratum = "A" , period = 1, Treatment = "Control"     , duration = 3, rate = .03),
   tibble(Stratum = "A" , period = 2, Treatment = "Control"     , duration = 2, rate = .04),
   tibble(Stratum = "A" , period = 3, Treatment = "Control"     , duration = 1, rate = .05),
   tibble(Stratum = "A" , period = 4, Treatment = "Control"     , duration = 2, rate = .06),
   tibble(Stratum = "A" , period = 1, Treatment = "Experimental", duration = 2, rate = .03),
   tibble(Stratum = "A" , period = 2, Treatment = "Experimental", duration = 3, rate = .04),
   tibble(Stratum = "A" , period = 3, Treatment = "Experimental", duration = 1, rate = .05),
   tibble(Stratum = "A" , period = 4, Treatment = "Experimental", duration = 2, rate = .06),
   tibble(Stratum = "A" , period = 5, Treatment = "Experimental", duration = 3, rate = .07),
   
   # stratum B 
   tibble(Stratum = "B", period = 1, Treatment = "Control"     , duration = 3, rate = .05),
   tibble(Stratum = "B", period = 2, Treatment = "Control"     , duration = 2, rate = .06),
   tibble(Stratum = "B", period = 3, Treatment = "Control"     , duration = 2, rate = .07),
   tibble(Stratum = "B", period = 4, Treatment = "Control"     , duration = 1, rate = .08),
   tibble(Stratum = "B", period = 1, Treatment = "Experimental", duration = 4, rate = .06),
   tibble(Stratum = "B", period = 2, Treatment = "Experimental", duration = 3, rate = .07),
   tibble(Stratum = "B", period = 3, Treatment = "Experimental", duration = 2, rate = .08),
   tibble(Stratum = "B", period = 4, Treatment = "Experimental", duration = 2, rate = .09),
   tibble(Stratum = "B", period = 5, Treatment = "Experimental", duration = 1, rate = .095),
   
   # stratum C
   tibble(Stratum = "C", period = 1, Treatment = "Control"     , duration = 4, rate = .01),
   tibble(Stratum = "C", period = 2, Treatment = "Control"     , duration = 2, rate = .02),
   tibble(Stratum = "C", period = 3, Treatment = "Control"     , duration = 3, rate = .025),
   tibble(Stratum = "C", period = 4, Treatment = "Control"     , duration = 1, rate = .022),
   tibble(Stratum = "C", period = 1, Treatment = "Experimental", duration = 3, rate = .011),
   tibble(Stratum = "C", period = 2, Treatment = "Experimental", duration = 2, rate = .014),
   tibble(Stratum = "C", period = 3, Treatment = "Experimental", duration = 1, rate = .012),
   tibble(Stratum = "C", period = 4, Treatment = "Experimental", duration = 3, rate = .02),
   tibble(Stratum = "C", period = 5, Treatment = "Experimental", duration = 2, rate = .022),
   
   # stratum D
   tibble(Stratum = "D", period = 1, Treatment = "Control"     , duration = 3, rate = .02),
   tibble(Stratum = "D", period = 2, Treatment = "Control"     , duration = 2, rate = .022),
   tibble(Stratum = "D", period = 3, Treatment = "Control"     , duration = 1, rate = .018),
   tibble(Stratum = "D", period = 4, Treatment = "Control"     , duration = 1, rate = .024),
   tibble(Stratum = "D", period = 1, Treatment = "Experimental", duration = 4, rate = .017),
   tibble(Stratum = "D", period = 2, Treatment = "Experimental", duration = 2, rate = .024),
   tibble(Stratum = "D", period = 3, Treatment = "Experimental", duration = 3, rate = .022),
   tibble(Stratum = "D", period = 4, Treatment = "Experimental", duration = 1, rate = .026),
   tibble(Stratum = "D", period = 5, Treatment = "Experimental", duration = 2, rate = .02),
   
   # stratum E
   tibble(Stratum = "E", period = 1, Treatment = "Control"     , duration = 1, rate = .05),
   tibble(Stratum = "E", period = 2, Treatment = "Control"     , duration = 2, rate = .045),
   tibble(Stratum = "E", period = 3, Treatment = "Control"     , duration = 2, rate = .052),
   tibble(Stratum = "E", period = 4, Treatment = "Control"     , duration = 4, rate = .04),
   tibble(Stratum = "E", period = 1, Treatment = "Experimental", duration = 2, rate = .06),
   tibble(Stratum = "E", period = 2, Treatment = "Experimental", duration = 3, rate = .065),
   tibble(Stratum = "E", period = 3, Treatment = "Experimental", duration = 3, rate = .058),
   tibble(Stratum = "E", period = 4, Treatment = "Experimental", duration = 2, rate = .062),
   tibble(Stratum = "E", period = 5, Treatment = "Experimental", duration = 2, rate = .064),

   # stratum F
   tibble(Stratum = "F", period = 1, Treatment = "Control"     , duration = 2, rate = .052),
   tibble(Stratum = "F", period = 2, Treatment = "Control"     , duration = 3, rate = .053),
   tibble(Stratum = "F", period = 3, Treatment = "Control"     , duration = 3, rate = .054),
   tibble(Stratum = "F", period = 4, Treatment = "Control"     , duration = 4, rate = .055),
   tibble(Stratum = "F", period = 1, Treatment = "Experimental", duration = 3, rate = .054),
   tibble(Stratum = "F", period = 2, Treatment = "Experimental", duration = 2, rate = .055),
   tibble(Stratum = "F", period = 3, Treatment = "Experimental", duration = 2, rate = .056),
   tibble(Stratum = "F", period = 4, Treatment = "Experimental", duration = 1, rate = .057),
   tibble(Stratum = "F", period = 5, Treatment = "Experimental", duration = 4, rate = .058),
   
   # stratum G
   tibble(Stratum = "G", period = 1, Treatment = "Control"     , duration = 1, rate = .04),
   tibble(Stratum = "G", period = 2, Treatment = "Control"     , duration = 2, rate = .042),
   tibble(Stratum = "G", period = 3, Treatment = "Control"     , duration = 3, rate = .044),
   tibble(Stratum = "G", period = 4, Treatment = "Control"     , duration = 4, rate = .048),
   tibble(Stratum = "G", period = 1, Treatment = "Experimental", duration = 4, rate = .05),
   tibble(Stratum = "G", period = 2, Treatment = "Experimental", duration = 2, rate = .053),
   tibble(Stratum = "G", period = 3, Treatment = "Experimental", duration = 3, rate = .056),
   tibble(Stratum = "G", period = 4, Treatment = "Experimental", duration = 1, rate = .057),
   tibble(Stratum = "G", period = 5, Treatment = "Experimental", duration = 3, rate = .058)
)

# 1.4 Set up Dropout Rates
dropoutRates <- bind_rows(
   # stratum A
   tibble(Stratum = "A" , period = 1, Treatment = "Control"     , duration = 3, rate = .001),
   tibble(Stratum = "A" , period = 2, Treatment = "Control"     , duration = 2, rate = .002),
   tibble(Stratum = "A" , period = 3, Treatment = "Control"     , duration = 3, rate = .0015),
   tibble(Stratum = "A" , period = 4, Treatment = "Control"     , duration = 3, rate = .0022),
   tibble(Stratum = "A" , period = 1, Treatment = "Experimental", duration = 2, rate = .001),
   tibble(Stratum = "A" , period = 2, Treatment = "Experimental", duration = 2, rate = .0015),
   tibble(Stratum = "A" , period = 3, Treatment = "Experimental", duration = 2, rate = .0009),
   tibble(Stratum = "A" , period = 4, Treatment = "Experimental", duration = 4, rate = .0008),
   tibble(Stratum = "A" , period = 5, Treatment = "Experimental", duration = 4, rate = .0007),
   
   # stratum B
   tibble(Stratum = "B", period = 1, Treatment = "Control"     , duration = 3, rate = .0008),
   tibble(Stratum = "B", period = 2, Treatment = "Control"     , duration = 1, rate = .0009),
   tibble(Stratum = "B", period = 3, Treatment = "Control"     , duration = 1, rate = .001),
   tibble(Stratum = "B", period = 4, Treatment = "Control"     , duration = 2, rate = .0011),
   tibble(Stratum = "B", period = 1, Treatment = "Experimental", duration = 3, rate = .0009),
   tibble(Stratum = "B", period = 2, Treatment = "Experimental", duration = 4, rate = .0008),
   tibble(Stratum = "B", period = 3, Treatment = "Experimental", duration = 4, rate = .0011),
   tibble(Stratum = "B", period = 4, Treatment = "Experimental", duration = 2, rate = .0012),
   tibble(Stratum = "B", period = 5, Treatment = "Experimental", duration = 3, rate = .0007),
   
   # stratum C
   tibble(Stratum = "C", period = 1, Treatment = "Control"     , duration = 3, rate = .0011),
   tibble(Stratum = "C", period = 2, Treatment = "Control"     , duration = 4, rate = .0012),
   tibble(Stratum = "C", period = 3, Treatment = "Control"     , duration = 2, rate = .0013),
   tibble(Stratum = "C", period = 4, Treatment = "Control"     , duration = 1, rate = .0014),
   tibble(Stratum = "C", period = 1, Treatment = "Experimental", duration = 2, rate = .001),
   tibble(Stratum = "C", period = 2, Treatment = "Experimental", duration = 3, rate = .0009),
   tibble(Stratum = "C", period = 3, Treatment = "Experimental", duration = 3, rate = .0008),
   tibble(Stratum = "C", period = 4, Treatment = "Experimental", duration = 1, rate = .0007),
   tibble(Stratum = "C", period = 5, Treatment = "Experimental", duration = 3, rate = .0006),
   
   # stratum D
   tibble(Stratum = "D", period = 1, Treatment = "Control"     , duration = 2, rate = .0015),
   tibble(Stratum = "D", period = 2, Treatment = "Control"     , duration = 3, rate = .0012),
   tibble(Stratum = "D", period = 3, Treatment = "Control"     , duration = 1, rate = .0013),
   tibble(Stratum = "D", period = 4, Treatment = "Control"     , duration = 4, rate = .0014),
   tibble(Stratum = "D", period = 1, Treatment = "Experimental", duration = 3, rate = .002),
   tibble(Stratum = "D", period = 2, Treatment = "Experimental", duration = 2, rate = .0018),
   tibble(Stratum = "D", period = 3, Treatment = "Experimental", duration = 1, rate = .0017),
   tibble(Stratum = "D", period = 4, Treatment = "Experimental", duration = 1, rate = .0015),
   tibble(Stratum = "D", period = 5, Treatment = "Experimental", duration = 5, rate = .0016),
   
   # stratum E
   tibble(Stratum = "E", period = 1, Treatment = "Control"     , duration = 3, rate = .0005),
   tibble(Stratum = "E", period = 2, Treatment = "Control"     , duration = 2, rate = .0008),
   tibble(Stratum = "E", period = 3, Treatment = "Control"     , duration = 2, rate = .0009),
   tibble(Stratum = "E", period = 4, Treatment = "Control"     , duration = 2, rate = .001),
   tibble(Stratum = "E", period = 1, Treatment = "Experimental", duration = 3, rate = .001),
   tibble(Stratum = "E", period = 2, Treatment = "Experimental", duration = 1, rate = .0012),
   tibble(Stratum = "E", period = 3, Treatment = "Experimental", duration = 1, rate = .0013),
   tibble(Stratum = "E", period = 4, Treatment = "Experimental", duration = 4, rate = .0011),
   tibble(Stratum = "E", period = 5, Treatment = "Experimental", duration = 1, rate = .0015),
   
   # stratum F
   tibble(Stratum = "F", period = 1, Treatment = "Control"     , duration = 3, rate = .0008),
   tibble(Stratum = "F", period = 2, Treatment = "Control"     , duration = 2, rate = .0009),
   tibble(Stratum = "F", period = 3, Treatment = "Control"     , duration = 1, rate = .001),
   tibble(Stratum = "F", period = 4, Treatment = "Control"     , duration = 2, rate = .0012),
   tibble(Stratum = "F", period = 1, Treatment = "Experimental", duration = 2, rate = .0007),
   tibble(Stratum = "F", period = 2, Treatment = "Experimental", duration = 3, rate = .0009),
   tibble(Stratum = "F", period = 3, Treatment = "Experimental", duration = 3, rate = .001),
   tibble(Stratum = "F", period = 4, Treatment = "Experimental", duration = 1, rate = .0012),
   tibble(Stratum = "F", period = 5, Treatment = "Experimental", duration = 4, rate = .0011),
   
   # stratum G
   tibble(Stratum = "G", period = 1, Treatment = "Control"     , duration = 4, rate = .0011),
   tibble(Stratum = "G", period = 2, Treatment = "Control"     , duration = 1, rate = .0012),
   tibble(Stratum = "G", period = 3, Treatment = "Control"     , duration = 2, rate = .0009),
   tibble(Stratum = "G", period = 4, Treatment = "Control"     , duration = 1, rate = .001),
   tibble(Stratum = "G", period = 1, Treatment = "Experimental", duration = 4, rate = .001),
   tibble(Stratum = "G", period = 2, Treatment = "Experimental", duration = 2, rate = .0012),
   tibble(Stratum = "G", period = 3, Treatment = "Experimental", duration = 3, rate = .0013),
   tibble(Stratum = "G", period = 4, Treatment = "Experimental", duration = 3, rate = .001),
   tibble(Stratum = "G", period = 5, Treatment = "Experimental", duration = 2, rate = .0012)
)

```


# Profile `simPWSurv`

```{r}
# Create necessary intermediate variables

n <- 1000
set.seed(2022)

# Source code of simPWSurv
x <- tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
  mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
  group_by(Stratum) %>% 
  mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
  group_by(Stratum, Treatment)
utr <- unique(x$Treatment)
usr <- unique(x$Stratum)
x$failTime <- 0
x$dropoutTime <- 0
for(sr in usr){for(tr in utr){
    indx <- x$Stratum==sr & x$Treatment==tr
    x$failTime[indx] <- rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
    x$dropoutTime[indx] <- rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
}}

```

## The source code of `simPWSurv`
```{r}
set.seed(2022)
prof_sim <- microbenchmark(
  # Create a tibble
  tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
    mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
    group_by(Stratum) %>% 
    mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
    group_by(Stratum, Treatment),
  # Get unique treatments and strata
  {
    utr <- unique(x$Treatment)
    usr <- unique(x$Stratum)
  },
  # Initialize columns of x
  {
    x$failTime <- 0
    x$dropoutTime <- 0
  },
  # Nested for loops to generate failTime and dropoutTime
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
      rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
  }},
  times = 100
)
levels(prof_sim$expr) <- c("Create a tibble",
                        "Get unique treatments and strata",
                        "Initialize columns of x",
                        "Nested For loop")
prof_sim
```

The nested for loop takes almost $90\%$ of the runtime, while creating a `tibble` takes the rest $10\%$ of the runtime.

## A single iteration of the nested for loops
```{r}
# Select the third stratum and the first treatment
sr <- usr[3]
tr <- utr[1]
x_indx <- x$Stratum==sr & x$Treatment==tr
x_n <- sum(x_indx)
f_indx <- failRates$Stratum==sr & failRates$Treatment==tr
d_indx <- dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
test_failRates <- filter(failRates, f_indx) %>% select(c("duration", "rate"))
test_dropoutRates <- filter(dropoutRates, d_indx) %>% select(c("duration", "rate"))

prof_singleit <- microbenchmark(
  # Get index of x
  x$Stratum==sr & x$Treatment==tr,
  # Count index of x
  sum(x_indx),
  # Get index of failRates and dropoutRates,
  {
    failRates$Stratum==sr & failRates$Treatment==tr
    dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
  },
  # Subset failRates
  {
    filter(failRates, f_indx)
    filter(dropoutRates, d_indx)
  },
  # rpwexp
  {
    rpwexp(n = x_n, failRates = test_failRates)
    rpwexp(n = x_n, failRates = test_dropoutRates)
  },
  times = 1000
)
levels(prof_singleit$expr) <- c("Get x_index", "Count x_index", "Get f_index and d_indx", "Filter data", "rpwexp")
prof_singleit
```

Filtering rows using `dplyr` takes more than $90\%$ of the runtime of a single iteration of the nested loop.


# Manipulate input data

## Filter rows
```{r}
mbm_subset <- bench::mark(
  filter(failRates, f_indx),
  subset(failRates, f_indx),
  failRates[f_indx,],
  iterations = 1000
)
mbm_subset
plot(mbm_subset)
```

Filtering rows using brackets is 35 times faster than `dplyr`.

## Select column
```{r}
mbm_pull <- bench::mark(
  test_failRates %>% pull(rate),
  test_failRates$rate,
  iterations = 1000
)
mbm_pull
plot(mbm_pull)
```

## Subset both rows and column
```{r}
mbm_subset_pull <- bench::mark(
  filter(failRates, f_indx) %>% pull(rate),
  failRates[f_indx, ]$rate,
  iterations = 1000
)
mbm_subset_pull
plot(mbm_subset_pull)
```

## Improvements

### A single iteration
```{r}
mbm_singleit1 <- microbenchmark(
  # Current
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
    rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
  },
  # Efficient filter
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),
           failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
    rpwexp(n=sum(indx),
           failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  },
  times = 100
)

levels(mbm_singleit1$expr) <- c("Current",
                                "Efficient filter")
mbm_singleit1
```


### The nested for loop
```{r}
mbm_nested1 <- microbenchmark(
  # Current nested for loop
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}    
  },
  # Nested for loop with efficient filter
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),
               failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
        rpwexp(n=sum(indx),
               failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}    
  },
  times = 100
)

levels(mbm_nested1$expr) <- c("Current nested loop",
                              "Nested loop with efficient filter")
mbm_nested1
```

### The source code of `simPWSurv`
```{r}
mbm_sim1 <- microbenchmark(
  # Current
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        x$failTime[indx] <- rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        x$dropoutTime[indx] <- rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}
  },
  # Efficient filter
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      x$failTime[indx] <- rpwexp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      x$dropoutTime[indx] <- rpwexp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}
  },
  times = 100
)

levels(mbm_sim1$expr) <- c("Old simPWSurv",
                           "simPWSurv with efficient filter")
mbm_sim1
```

Using brackets for filtering data gains 45-fold speedup for a single iteration, 15-fold speedup for the nested loop, and 5-fold speedup for the `simPWSurv`.

## Profile again

### A single iteration of the nested for loops
```{r}
prof_singleit1 <- microbenchmark(
  # Get index of x
  x$Stratum==sr & x$Treatment==tr,
  # Count index of x
  sum(x_indx),
  # Get index of failRates and dropoutRates,
  {
    failRates$Stratum==sr & failRates$Treatment==tr
    dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
  },
  # Subset failRates
  {
    failRates[f_indx,]
    dropoutRates[d_indx,]
  },
  # rpwexp
  {
    rpwexp(n = x_n, failRates = test_failRates)
    rpwexp(n = x_n, failRates = test_dropoutRates)
  },
  times = 1000
)
levels(prof_singleit1$expr) <- c("Get x_index", "Count x_index", "Get f_index", "Filter data", "rpwexp")
prof_singleit1
```

After optimizing filtering, `rpwexp` takes half of the runtime of a single iteration.

### The source code of `simPWSurv`
```{r}
set.seed(2022)
prof_sim1 <- microbenchmark(
  # Create a tibble
  tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
    mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
    group_by(Stratum) %>% 
    mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
    group_by(Stratum, Treatment),
  # Get unique treatments and strata
  {
    utr <- unique(x$Treatment)
    usr <- unique(x$Stratum)
  },
  # Initialize columns of x
  {
    x$failTime <- 0
    x$dropoutTime <- 0
  },
  # Nested for loops to generate failTime and dropoutTime
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      rpwexp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      rpwexp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  }},
  times = 100
)
levels(prof_sim1$expr) <- c("Create a tibble",
                        "Get unique treatments and strata",
                        "Initialize columns of x",
                        "Nested for loops")
prof_sim1
```

Now creating a `tibble` takes 2/3 of the runtime, while the nested for loop takes the rest 1/3 of the runtime.


# Generate piecewise Exponential random numbers

## The inverse transform method

### `rexp(1)`
```{r}
rpwexpexp <- function(n, rate = 1, duration = 1) {
  # Need to check rate, t are positive real vectors of same length, t is increasing, h > 0
  n_piece <- length(rate)
  # Get number of piecewise rates
  H <- c(0, cumsum(rate * duration))[1:n_piece]
  duration <- c(0, cumsum(duration))[1:n_piece]
  # Generate cumulative hazard for each observation
  y <- rexp(n = n, rate = 1)
  # Make a vector to record with interval each observation is in
  interval <- rep(1, n)
  if (n_piece > 1) {
    for (i in 2:(n_piece)) interval[y >= H[i]] <- i
    # if rate[i-1] = 0 (i.e. H[i] == H[i-1]), no observation will fall in to [i-1, i)
  }
  y <- (y - H[interval]) / rate[interval] + duration[interval]
  # if rate[n_piece] == 0, observations in final interval are Inf
  return (y)
}
```

### `runif`
```{r}
rpwexpunif <- function(n, rate, duration){
  # Need to check rate, t are positive real vectors of same length, t is increasing, h > 0
  n_piece <- length(rate)
  # Get number of piecewise rates
  H <- c(0, cumsum(rate * duration))[1:n_piece]
  duration <- c(0, cumsum(duration))[1:n_piece]
  # Generate cumulative hazard for each observation
  y <- -log(runif(n))
  # Make a vector to record with interval each observation is in
  interval <- rep(1, n)
  if (n_piece > 1) {
    for (i in 2:(n_piece)) {
      interval[y >= H[i]] <- i
    }
  }
  y <- (y - H[interval]) / rate[interval] + duration[interval]
  return (y)
}

# Simulate failRates
n_rates <- 10
duration <- floor(runif(n_rates, 1, 5))
rate <- runif(n_rates, 0.0005, 0.095)
rate[5] <- 0.0
rate[10] <- 0.0
tchange1 <- cumsum(duration)
tchange0 <- c(0, tchange1)[1:(length(duration-1))]

# Expect the same results
set.seed(2)
s1 <- PWEALL::rpwe(n = 10, rate = rate, tchange = tchange0)
set.seed(2)
s2 <- rpwexpunif(n = 10, rate = rate, duration = duration)
set.seed(2)
s3 <- simtrial::rpwexpinvRcpp(n = 10, failRates = data.frame(duration = duration,
                                                             rate = rate))

all.equal(s1$r, s2)
all.equal(s2, s3)
```

## Benchmark different methods for generating piecewise Exponential random numbers

### Generate ~100 observations using ~5 intervals
```{r}
# PWEALL requires time changing point
tchange0 <- cumsum(c(0, test_failRates$duration))[1:(length(test_failRates$duration-1))] # exclusive prefix sum of duration

mbm_rpwexp <- microbenchmark(
  # R
  rpwexp(n = x_n, failRates = test_failRates),
  # C++
  rpwexpRcpp(n = x_n, failRates = test_failRates),
  # Inverse exp(1) in R
  rpwexpexp(n = x_n, rate = test_failRates$rate, duration = test_failRates$duration),
  # Inverse unif in R
  rpwexpunif(n = x_n, rate = test_failRates$rate, duration = test_failRates$duration),
  # Inverse unif in C++
  rpwexpinvRcpp(n = x_n, failRates = test_failRates),
  # PWEALL (Inverse unif in Fortran)
  PWEALL::rpwe(n = x_n, rate = test_failRates$rate, tchange = tchange0),
  times = 1000
)
levels(mbm_rpwexp$expr) <- c("Old method in R",
                             "Old method in C++",
                             "Inverse CDF with exp(1) in R",
                             "Inverse CDF with unif in R",
                             "Inverse CDF with unif in C++",
                             "Inverse CDF with unif in Fortran")
mbm_rpwexp
```

The inverse transform method in C++ is 3 times faster than the current implementation in R in this small example.

### Runtime comparison across different number of observations to be generated
```{r}
bm_rpwexp <- function(n, nr, itr = 1000) {
  # simulate failRates
  duration <- floor(runif(nr, 1, 5))
  rate <- runif(nr, 0.0005, 0.095)
  failTbl <- tibble(duration, rate)
  tchange0 <- cumsum(c(0, duration))[1:(length(duration-1))]

  times <- rep(0, 6)
  for (i in 1:itr) {
    # Current method in R
    start_time <- Sys.time()
    rpwexp(n = n, failRates = failTbl)
    end_time <- Sys.time()
    times[1] = times[1] + end_time - start_time

    # Current method in C++
    start_time <- Sys.time()
    rpwexpRcpp(n = n, failRates = failTbl)
    end_time <- Sys.time()
    times[2] = times[2] + end_time - start_time

    # Inverse CDF with exp(1) in R
    start_time <- Sys.time()
    rpwexpexp(n = n, rate = rate, duration = duration)
    end_time <- Sys.time()
    times[3] = times[3] + end_time - start_time

    # Inverse CDF with unif in R
    start_time <- Sys.time()
    rpwexpunif(n = n, rate = rate, duration = duration)
    end_time <- Sys.time()
    times[4] = times[4] + end_time - start_time

    # Inverse CDF with unif in C++
    start_time <- Sys.time()
    rpwexpinvRcpp(n = x_n, failRates = failTbl)
    end_time <- Sys.time()
    times[5] = times[5] + end_time - start_time

    # Inverse CDF with unif in Fortran
    start_time <- Sys.time()
    PWEALL::rpwe(n = n, rate = rate, tchange = tchange0)
    end_time <- Sys.time()
    times[6] = times[6] + end_time - start_time
  }

  return (times * 1e6 / itr)
}

nr_pool <- c(2, 4, 6, 8, 10, 20, 50, 100) # number of time intervals
n_pool <- c(50, 100, 200, 500, 1000, 1500, 2000, 5000, 10000) # number of observations to be generated

##################################################################
# Fix n_rates = 5
nr <- 5

# Dataframe for storing timing results
times_n <- data.frame(matrix(ncol = 7, nrow = length(n_pool)))
colnames(times_n) <- c("n",
                       "rpwexp",
                       "rpwexpRcpp",
                       "rpwexpexp",
                       "rpwexpunif",
                       "rpwexpinvRcpp",
                       "PWEALL")
times_n$n <- n_pool

# Benchmark
for (i in 1:length(n_pool)) {
  times_n[i, 2:7] <- bm_rpwexp(n_pool[i], nr)
}

# Reshape timing results for plot
df_times_n <- data.frame(x = times_n$n,
                         y = c(times_n$rpwexp,
                               times_n$rpwexpRcpp,
                               times_n$rpwexpexp,
                               times_n$rpwexpunif,
                               times_n$rpwexpinvRcpp,
                               times_n$PWEALL),
                         group = c(rep("Old method in R", nrow(times_n)),
                                   rep("Old method in C++", nrow(times_n)),
                                   rep("Inverse CDF with exp(1) in R", nrow(times_n)),
                                   rep("Inverse CDF with unif in R", nrow(times_n)),
                                   rep("Inverse CDF with unif in C++", nrow(times_n)),
                                   rep("Inverse CDF with unif in Fortran", nrow(times_n))))
ggplot(df_times_n, aes(x, y, col = group)) +
  geom_line() +
  scale_x_log10(breaks = c(50, 100, 200, 500, 1000, 2000, 5000, 10000)) +
  # scale_x_continuous(trans='log10') + 
  scale_y_continuous(trans='log10') + 
  labs(x = "Number of observations to be generated", y = paste0("Runtime (", "\U003BC", "s)")) +
  theme_mk() +
  scale_color_adaptive("teal") +
  theme(legend.title=element_blank())
```

### Runtime comparison across different number of intervals
```{r}
# Fix n = 1000
n <- 1000

# Dataframe for storing timing results
times_nr <- data.frame(matrix(ncol = 7, nrow = length(nr_pool)))
colnames(times_nr) <- c("n_rates",
                        "rpwexp",
                        "rpwexpRcpp",
                        "rpwexph",
                        "rpwexpunif",
                        "rpwexpinvRcpp",
                        "PWEALL")
times_nr$n_rates <- nr_pool

# Benchmark
for (i in 1:length(nr_pool)) {
  times_nr[i, 2:7] <- bm_rpwexp(n, nr_pool[i])
}

# Reshape timing results for plot
df_times_nr <- data.frame(x = times_nr$n_rates,
                          y = c(times_nr$rpwexp,
                                times_nr$rpwexpRcpp,
                                times_nr$rpwexph,
                                times_nr$rpwexpunif,
                                times_nr$rpwexpinvRcpp,
                                times_nr$PWEALL),
                          group = c(rep("Old method in R", nrow(times_nr)),
                                    rep("Old method in C++", nrow(times_nr)),
                                    rep("Inverse CDF with exp(1) in R", nrow(times_nr)),
                                    rep("Inverse CDF with unif in R", nrow(times_nr)),
                                    rep("Inverse CDF with unif in C++", nrow(times_nr)),
                                    rep("Inverse CDF with unif in Fortran", nrow(times_nr))))
ggplot(df_times_nr, aes(x, y, col = group)) +
  geom_line() +
  scale_x_continuous(trans='log10') +
  labs(x = "Number of intervals", y = paste0("Runtime (", "\U003BC", "s)")) +
  theme_mk() +
  scale_color_adaptive("teal") +
  theme(legend.title=element_blank())
```


## Improvements

### A single iteration
```{r}
mbm_singleit2 <- microbenchmark(
  # Current
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
    rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
  },
  # Efficient filter
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),
           failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
    rpwexp(n=sum(indx),
           failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  },
  # Efficient filter and rpwexpinvRcpp
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexpinvRcpp(n=sum(indx),
           failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
    rpwexpinvRcpp(n=sum(indx),
           failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])  },
  times = 100
)

levels(mbm_singleit2$expr) <- c("Current",
                                "Efficient filter",
                                "Efficient filter and rpwexpinvRcpp")
mbm_singleit2
```


### The nested for loop
```{r}
mbm_nested2 <- microbenchmark(
  # Current nested for loop
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}    
  },
  # Nested for loop with efficient filter
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),
               failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
        rpwexp(n=sum(indx),
               failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}    
  },
  # Nested for loop with efficient filter and rpwexpinvRcpp
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexpinvRcpp(n=sum(indx),
               failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
        rpwexpinvRcpp(n=sum(indx),
               failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}    
  },
  times = 100
)

levels(mbm_nested2$expr) <- c("Current nested loop",
                              "Nested loop with efficient filter",
                              "Nested loop with efficient filter and rpwexpinvRcpp")
mbm_nested2
```

### The source code of `simPWSurv`
```{r}
mbm_sim2 <- microbenchmark(
  # Current
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        x$failTime[indx] <- rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        x$dropoutTime[indx] <- rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}
  },
  # Efficient filter
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      x$failTime[indx] <- rpwexp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      x$dropoutTime[indx] <- rpwexp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}
  },
  # Efficient filter and rpwexpinvRcpp
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      x$failTime[indx] <- rpwexpinvRcpp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      x$dropoutTime[indx] <- rpwexpinvRcpp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}
  },
  times = 100
)

levels(mbm_sim2$expr) <- c("Old simPWSurv",
                           "simPWSurv with efficient filter",
                           "simPWSurv with efficient filter and rpwexpinvRcpp")
mbm_sim2
```


## Profile again

### A single iteration of the nested for loops
```{r}
prof_singleit2 <- microbenchmark(
  # Get index of x
  x$Stratum==sr & x$Treatment==tr,
  # Count index of x
  sum(x_indx),
  # Get index of failRates and dropoutRates,
  {
    failRates$Stratum==sr & failRates$Treatment==tr
    dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
  },
  # Subset failRates
  {
    failRates[f_indx,]
    dropoutRates[d_indx,]
  },
  # rpwexp
  {
    rpwexpinvRcpp(n = x_n, failRates = test_failRates)
    rpwexpinvRcpp(n = x_n, failRates = test_dropoutRates)
  },
  times = 1000
)
levels(prof_singleit2$expr) <- c("Get x_index", "Count x_index", "Get f_index", "Filter data", "rpwexpinvRcpp")
prof_singleit2
```

After optimizing `rpwexp`, generating piecewise Exponential random numbers only takes ~$20\%$ of runtime of a single iteration.

### The source code of `simPWSurv`
```{r}
set.seed(2022)
prof_sim2 <- microbenchmark(
  # Create a tibble
  tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
    mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
    group_by(Stratum) %>% 
    mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
    group_by(Stratum, Treatment),
  # Get unique treatments and strata
  {
    utr <- unique(x$Treatment)
    usr <- unique(x$Stratum)
  },
  # Initialize columns of x
  {
    x$failTime <- 0
    x$dropoutTime <- 0
  },
  # Nested for loops to generate failTime and dropoutTime
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      rpwexpinvRcpp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      rpwexpinvRcpp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  }},
  times = 100
)
levels(prof_sim2$expr) <- c("Create a tibble",
                            "Get unique treatments and strata",
                            "Initialize columns of x",
                            "Nested for loops")
prof_sim2
```

Now creating a `tibble` takes 3/4 of the runtime, while the nested for loop takes the rest 1/4 of the runtime.


# Overall improvement

- Update in `simPWSurv`:
    - Filter rows using brackets instead of `dplyr` when calling `rpwexp`.
    - Generate piecewise Exponential random numbers using the inverse transform method implemented in C++ `rpwexpinvRcpp`.

- Speedup: $\times$ 7
```{r, warning=FALSE}
set.seed(2022)
mbm_simPWSurv <- microbenchmark(
  simtrial:::simPWSurv_(n = 1000, 
            strata = strata,
            block = block,
            enrollRates = enrollRates,
            failRates = failRates,
            dropoutRates = dropoutRates),
  simtrial::simPWSurv(n = 1000, 
               strata = strata,
               block = block,
               enrollRates = enrollRates,
               failRates = failRates,
               dropoutRates = dropoutRates),
  times = 100
)
levels(mbm_simPWSurv$expr) <- c("Old simPWSurv", "New simPWSurv")
mbm_simPWSurv
```

