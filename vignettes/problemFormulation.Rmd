---
title: "Computational Enhancement of `rpwexp` "
author: "Jianxiao Yang"
output:
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
    number_sections: true
---

```{r}
sessionInfo()
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(simtrial)
library(knitr)
library(tibble)
library(dplyr)
library(gt)
library(ggplot2)
library(profvis)
library(bench)
library(microbenchmark)
library(PWEALL)
library(parallel)
devtools::load_all()
```


# Data

In this example, we consider

- 7 strata
- 10 periods in enrollments
- 4 periods in failure rates of the control arm per stratum
- 5 periods in failure rates of the experimental arm per stratum
- 4 periods in dropout rates of the control arm per stratum
- 5 periods in dropout rates of the experimental arm per stratum

```{r}
# 1.1 Set up Strata & Block
strata <- tibble(
  Stratum = c("A", "B", "C", "D", "E", "F", "G"), 
  p = c(rep(0.1, 4), rep(0.2, 3)))
  
block <- c(rep("Control", 2), rep("Experimental", 2))

# 1.2 Set up Enrollment Rates
enrollRates <- bind_rows(
   # control arm - low stratum - 4 periods
   tibble(period = 1,  duration = 2, rate = 9),
   tibble(period = 2,  duration = 3, rate = 10),
   tibble(period = 3,  duration = 4, rate = 11),
   tibble(period = 4,  duration = 5, rate = 12),
   tibble(period = 5,  duration = 2, rate = 5),
   tibble(period = 6,  duration = 1, rate = 6),
   tibble(period = 7,  duration = 3, rate = 7),
   tibble(period = 8,  duration = 2, rate = 8),
   tibble(period = 9,  duration = 2, rate = 4),
   tibble(period = 10, duration = 1, rate = 2)
)

# 1.3 Set up Failure Rates
failRates <- bind_rows(
   # stratum A 
   tibble(Stratum = "A" , period = 1, Treatment = "Control"     , duration = 3, rate = .03),
   tibble(Stratum = "A" , period = 2, Treatment = "Control"     , duration = 2, rate = .04),
   tibble(Stratum = "A" , period = 3, Treatment = "Control"     , duration = 1, rate = .05),
   tibble(Stratum = "A" , period = 4, Treatment = "Control"     , duration = 2, rate = .06),
   tibble(Stratum = "A" , period = 1, Treatment = "Experimental", duration = 2, rate = .03),
   tibble(Stratum = "A" , period = 2, Treatment = "Experimental", duration = 3, rate = .04),
   tibble(Stratum = "A" , period = 3, Treatment = "Experimental", duration = 1, rate = .05),
   tibble(Stratum = "A" , period = 4, Treatment = "Experimental", duration = 2, rate = .06),
   tibble(Stratum = "A" , period = 5, Treatment = "Experimental", duration = 3, rate = .07),
   
   # stratum B 
   tibble(Stratum = "B", period = 1, Treatment = "Control"     , duration = 3, rate = .05),
   tibble(Stratum = "B", period = 2, Treatment = "Control"     , duration = 2, rate = .06),
   tibble(Stratum = "B", period = 3, Treatment = "Control"     , duration = 2, rate = .07),
   tibble(Stratum = "B", period = 4, Treatment = "Control"     , duration = 1, rate = .08),
   tibble(Stratum = "B", period = 1, Treatment = "Experimental", duration = 4, rate = .06),
   tibble(Stratum = "B", period = 2, Treatment = "Experimental", duration = 3, rate = .07),
   tibble(Stratum = "B", period = 3, Treatment = "Experimental", duration = 2, rate = .08),
   tibble(Stratum = "B", period = 4, Treatment = "Experimental", duration = 2, rate = .09),
   tibble(Stratum = "B", period = 5, Treatment = "Experimental", duration = 1, rate = .095),
   
   # stratum C
   tibble(Stratum = "C", period = 1, Treatment = "Control"     , duration = 4, rate = .01),
   tibble(Stratum = "C", period = 2, Treatment = "Control"     , duration = 2, rate = .02),
   tibble(Stratum = "C", period = 3, Treatment = "Control"     , duration = 3, rate = .025),
   tibble(Stratum = "C", period = 4, Treatment = "Control"     , duration = 1, rate = .022),
   tibble(Stratum = "C", period = 1, Treatment = "Experimental", duration = 3, rate = .011),
   tibble(Stratum = "C", period = 2, Treatment = "Experimental", duration = 2, rate = .014),
   tibble(Stratum = "C", period = 3, Treatment = "Experimental", duration = 1, rate = .012),
   tibble(Stratum = "C", period = 4, Treatment = "Experimental", duration = 3, rate = .02),
   tibble(Stratum = "C", period = 5, Treatment = "Experimental", duration = 2, rate = .022),
   
   # stratum D
   tibble(Stratum = "D", period = 1, Treatment = "Control"     , duration = 3, rate = .02),
   tibble(Stratum = "D", period = 2, Treatment = "Control"     , duration = 2, rate = .022),
   tibble(Stratum = "D", period = 3, Treatment = "Control"     , duration = 1, rate = .018),
   tibble(Stratum = "D", period = 4, Treatment = "Control"     , duration = 1, rate = .024),
   tibble(Stratum = "D", period = 1, Treatment = "Experimental", duration = 4, rate = .017),
   tibble(Stratum = "D", period = 2, Treatment = "Experimental", duration = 2, rate = .024),
   tibble(Stratum = "D", period = 3, Treatment = "Experimental", duration = 3, rate = .022),
   tibble(Stratum = "D", period = 4, Treatment = "Experimental", duration = 1, rate = .026),
   tibble(Stratum = "D", period = 5, Treatment = "Experimental", duration = 2, rate = .02),
   
   # stratum E
   tibble(Stratum = "E", period = 1, Treatment = "Control"     , duration = 1, rate = .05),
   tibble(Stratum = "E", period = 2, Treatment = "Control"     , duration = 2, rate = .045),
   tibble(Stratum = "E", period = 3, Treatment = "Control"     , duration = 2, rate = .052),
   tibble(Stratum = "E", period = 4, Treatment = "Control"     , duration = 4, rate = .04),
   tibble(Stratum = "E", period = 1, Treatment = "Experimental", duration = 2, rate = .06),
   tibble(Stratum = "E", period = 2, Treatment = "Experimental", duration = 3, rate = .065),
   tibble(Stratum = "E", period = 3, Treatment = "Experimental", duration = 3, rate = .058),
   tibble(Stratum = "E", period = 4, Treatment = "Experimental", duration = 2, rate = .062),
   tibble(Stratum = "E", period = 5, Treatment = "Experimental", duration = 2, rate = .064),

   # stratum F
   tibble(Stratum = "F", period = 1, Treatment = "Control"     , duration = 2, rate = .052),
   tibble(Stratum = "F", period = 2, Treatment = "Control"     , duration = 3, rate = .053),
   tibble(Stratum = "F", period = 3, Treatment = "Control"     , duration = 3, rate = .054),
   tibble(Stratum = "F", period = 4, Treatment = "Control"     , duration = 4, rate = .055),
   tibble(Stratum = "F", period = 1, Treatment = "Experimental", duration = 3, rate = .054),
   tibble(Stratum = "F", period = 2, Treatment = "Experimental", duration = 2, rate = .055),
   tibble(Stratum = "F", period = 3, Treatment = "Experimental", duration = 2, rate = .056),
   tibble(Stratum = "F", period = 4, Treatment = "Experimental", duration = 1, rate = .057),
   tibble(Stratum = "F", period = 5, Treatment = "Experimental", duration = 4, rate = .058),
   
   # stratum G
   tibble(Stratum = "G", period = 1, Treatment = "Control"     , duration = 1, rate = .04),
   tibble(Stratum = "G", period = 2, Treatment = "Control"     , duration = 2, rate = .042),
   tibble(Stratum = "G", period = 3, Treatment = "Control"     , duration = 3, rate = .044),
   tibble(Stratum = "G", period = 4, Treatment = "Control"     , duration = 4, rate = .048),
   tibble(Stratum = "G", period = 1, Treatment = "Experimental", duration = 4, rate = .05),
   tibble(Stratum = "G", period = 2, Treatment = "Experimental", duration = 2, rate = .053),
   tibble(Stratum = "G", period = 3, Treatment = "Experimental", duration = 3, rate = .056),
   tibble(Stratum = "G", period = 4, Treatment = "Experimental", duration = 1, rate = .057),
   tibble(Stratum = "G", period = 5, Treatment = "Experimental", duration = 3, rate = .058)
)

# 1.4 Set up Dropout Rates
dropoutRates <- bind_rows(
   # stratum A
   tibble(Stratum = "A" , period = 1, Treatment = "Control"     , duration = 3, rate = .001),
   tibble(Stratum = "A" , period = 2, Treatment = "Control"     , duration = 2, rate = .002),
   tibble(Stratum = "A" , period = 3, Treatment = "Control"     , duration = 3, rate = .0015),
   tibble(Stratum = "A" , period = 4, Treatment = "Control"     , duration = 3, rate = .0022),
   tibble(Stratum = "A" , period = 1, Treatment = "Experimental", duration = 2, rate = .001),
   tibble(Stratum = "A" , period = 2, Treatment = "Experimental", duration = 2, rate = .0015),
   tibble(Stratum = "A" , period = 3, Treatment = "Experimental", duration = 2, rate = .0009),
   tibble(Stratum = "A" , period = 4, Treatment = "Experimental", duration = 4, rate = .0008),
   tibble(Stratum = "A" , period = 5, Treatment = "Experimental", duration = 4, rate = .0007),
   
   # stratum B
   tibble(Stratum = "B", period = 1, Treatment = "Control"     , duration = 3, rate = .0008),
   tibble(Stratum = "B", period = 2, Treatment = "Control"     , duration = 1, rate = .0009),
   tibble(Stratum = "B", period = 3, Treatment = "Control"     , duration = 1, rate = .001),
   tibble(Stratum = "B", period = 4, Treatment = "Control"     , duration = 2, rate = .0011),
   tibble(Stratum = "B", period = 1, Treatment = "Experimental", duration = 3, rate = .0009),
   tibble(Stratum = "B", period = 2, Treatment = "Experimental", duration = 4, rate = .0008),
   tibble(Stratum = "B", period = 3, Treatment = "Experimental", duration = 4, rate = .0011),
   tibble(Stratum = "B", period = 4, Treatment = "Experimental", duration = 2, rate = .0012),
   tibble(Stratum = "B", period = 5, Treatment = "Experimental", duration = 3, rate = .0007),
   
   # stratum C
   tibble(Stratum = "C", period = 1, Treatment = "Control"     , duration = 3, rate = .0011),
   tibble(Stratum = "C", period = 2, Treatment = "Control"     , duration = 4, rate = .0012),
   tibble(Stratum = "C", period = 3, Treatment = "Control"     , duration = 2, rate = .0013),
   tibble(Stratum = "C", period = 4, Treatment = "Control"     , duration = 1, rate = .0014),
   tibble(Stratum = "C", period = 1, Treatment = "Experimental", duration = 2, rate = .001),
   tibble(Stratum = "C", period = 2, Treatment = "Experimental", duration = 3, rate = .0009),
   tibble(Stratum = "C", period = 3, Treatment = "Experimental", duration = 3, rate = .0008),
   tibble(Stratum = "C", period = 4, Treatment = "Experimental", duration = 1, rate = .0007),
   tibble(Stratum = "C", period = 5, Treatment = "Experimental", duration = 3, rate = .0006),
   
   # stratum D
   tibble(Stratum = "D", period = 1, Treatment = "Control"     , duration = 2, rate = .0015),
   tibble(Stratum = "D", period = 2, Treatment = "Control"     , duration = 3, rate = .0012),
   tibble(Stratum = "D", period = 3, Treatment = "Control"     , duration = 1, rate = .0013),
   tibble(Stratum = "D", period = 4, Treatment = "Control"     , duration = 4, rate = .0014),
   tibble(Stratum = "D", period = 1, Treatment = "Experimental", duration = 3, rate = .002),
   tibble(Stratum = "D", period = 2, Treatment = "Experimental", duration = 2, rate = .0018),
   tibble(Stratum = "D", period = 3, Treatment = "Experimental", duration = 1, rate = .0017),
   tibble(Stratum = "D", period = 4, Treatment = "Experimental", duration = 1, rate = .0015),
   tibble(Stratum = "D", period = 5, Treatment = "Experimental", duration = 5, rate = .0016),
   
   # stratum E
   tibble(Stratum = "E", period = 1, Treatment = "Control"     , duration = 3, rate = .0005),
   tibble(Stratum = "E", period = 2, Treatment = "Control"     , duration = 2, rate = .0008),
   tibble(Stratum = "E", period = 3, Treatment = "Control"     , duration = 2, rate = .0009),
   tibble(Stratum = "E", period = 4, Treatment = "Control"     , duration = 2, rate = .001),
   tibble(Stratum = "E", period = 1, Treatment = "Experimental", duration = 3, rate = .001),
   tibble(Stratum = "E", period = 2, Treatment = "Experimental", duration = 1, rate = .0012),
   tibble(Stratum = "E", period = 3, Treatment = "Experimental", duration = 1, rate = .0013),
   tibble(Stratum = "E", period = 4, Treatment = "Experimental", duration = 4, rate = .0011),
   tibble(Stratum = "E", period = 5, Treatment = "Experimental", duration = 1, rate = .0015),
   
   # stratum F
   tibble(Stratum = "F", period = 1, Treatment = "Control"     , duration = 3, rate = .0008),
   tibble(Stratum = "F", period = 2, Treatment = "Control"     , duration = 2, rate = .0009),
   tibble(Stratum = "F", period = 3, Treatment = "Control"     , duration = 1, rate = .001),
   tibble(Stratum = "F", period = 4, Treatment = "Control"     , duration = 2, rate = .0012),
   tibble(Stratum = "F", period = 1, Treatment = "Experimental", duration = 2, rate = .0007),
   tibble(Stratum = "F", period = 2, Treatment = "Experimental", duration = 3, rate = .0009),
   tibble(Stratum = "F", period = 3, Treatment = "Experimental", duration = 3, rate = .001),
   tibble(Stratum = "F", period = 4, Treatment = "Experimental", duration = 1, rate = .0012),
   tibble(Stratum = "F", period = 5, Treatment = "Experimental", duration = 4, rate = .0011),
   
   # stratum G
   tibble(Stratum = "G", period = 1, Treatment = "Control"     , duration = 4, rate = .0011),
   tibble(Stratum = "G", period = 2, Treatment = "Control"     , duration = 1, rate = .0012),
   tibble(Stratum = "G", period = 3, Treatment = "Control"     , duration = 2, rate = .0009),
   tibble(Stratum = "G", period = 4, Treatment = "Control"     , duration = 1, rate = .001),
   tibble(Stratum = "G", period = 1, Treatment = "Experimental", duration = 4, rate = .001),
   tibble(Stratum = "G", period = 2, Treatment = "Experimental", duration = 2, rate = .0012),
   tibble(Stratum = "G", period = 3, Treatment = "Experimental", duration = 3, rate = .0013),
   tibble(Stratum = "G", period = 4, Treatment = "Experimental", duration = 3, rate = .001),
   tibble(Stratum = "G", period = 5, Treatment = "Experimental", duration = 2, rate = .0012)
)

```


# Profile `simPWSurv`

## Profile using `profvis`
```{r}
n <- 1000
set.seed(2022)
profvis({
  # Source code of simPWSurv
  x <- tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
    mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
    group_by(Stratum) %>% 
    mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
    group_by(Stratum, Treatment)
  utr <- unique(x$Treatment)
  usr <- unique(x$Stratum)
  x$failTime <- 0
  x$dropoutTime <- 0
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      x$failTime[indx] <- rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
      x$dropoutTime[indx] <- rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
  }}
})
```

## "Profile" using `microbenchmark`

### The source code of `simPWSurv`
```{r}
set.seed(2022)
prof_sim <- microbenchmark(
  # Create a tibble
  tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
    mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
    group_by(Stratum) %>% 
    mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
    group_by(Stratum, Treatment),
  # Get unique treatments and strata
  {
    utr <- unique(x$Treatment)
    usr <- unique(x$Stratum)
  },
  # Initialize columns of x
  {
    x$failTime <- 0
    x$dropoutTime <- 0
  },
  # Nested for loops to generate failTime and dropoutTime
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
      rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
  }},
  times = 100
)
levels(prof_sim$expr) <- c("Create a tibble",
                        "Get unique treatments and strata",
                        "Initialize columns of x",
                        "Nested For loop")
prof_sim
```

The nested for loop takes almost $90\%$ of the runtime, while creating a `tibble` takes the rest $10\%$ of the runtime.

### A single iteration of the nested for loops
```{r}
# Select the third stratum and the first treatment
sr <- usr[3]
tr <- utr[1]
x_indx <- x$Stratum==sr & x$Treatment==tr
x_n <- sum(x_indx)
f_indx <- failRates$Stratum==sr & failRates$Treatment==tr
d_indx <- dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
test_failRates <- filter(failRates, f_indx) %>% select(c("duration", "rate"))
test_dropoutRates <- filter(dropoutRates, d_indx) %>% select(c("duration", "rate"))

prof_singleit <- microbenchmark(
  # Get index of x
  x$Stratum==sr & x$Treatment==tr,
  # Count index of x
  sum(x_indx),
  # Get index of failRates and dropoutRates,
  {
    failRates$Stratum==sr & failRates$Treatment==tr
    dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
  },
  # Subset failRates
  {
    filter(failRates, f_indx)
    filter(dropoutRates, d_indx)
  },
  # rpwexp
  {
    rpwexp(n = x_n, failRates = test_failRates)
    rpwexp(n = x_n, failRates = test_dropoutRates)
  },
  times = 1000
)
levels(prof_singleit$expr) <- c("Get x_index", "Count x_index", "Get f_index and d_indx", "Filter data", "rpwexp")
prof_singleit
```

Filtering rows using `dplyr` takes more than $90\%$ of the runtime of a single iteration of the nested loop.

### Number of observations and number of intervals
```{r}
df_n_nr <- data.frame(matrix(nrow = length(usr) * length(utr), ncol = 5))
colnames(df_n_nr) <- c("stratum", "treatment", "n", "failRates", "dropoutRates")
i = 1
for(sr in usr){for(tr in utr){
  indx <- x$Stratum==sr & x$Treatment==tr
  findx <- failRates$Stratum==sr & failRates$Treatment==tr
  dindx <- dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
  df_n_nr[i, ] <- c(sr, tr, sum(indx), sum(findx), sum(dindx))
  i = i+1
}}
df_n_nr <- df_n_nr %>% arrange(tr, sr)
kable(df_n_nr)
```


# Manipulate input data

## Filter rows
```{r}
mbm_subset <- bench::mark(
  filter(failRates, f_indx),
  subset(failRates, f_indx),
  failRates[f_indx,],
  iterations = 1000
)
mbm_subset
plot(mbm_subset)
```

Filtering rows using brackets is 35 times faster than `dplyr`.

## Select column
```{r}
mbm_pull <- bench::mark(
  test_failRates %>% pull(rate),
  test_failRates$rate,
  iterations = 1000
)
mbm_pull
plot(mbm_pull)
```

## Subset both rows and column
```{r}
mbm_subset_pull <- bench::mark(
  filter(failRates, f_indx) %>% pull(rate),
  failRates[f_indx, ]$rate,
  iterations = 1000
)
mbm_subset_pull
plot(mbm_subset_pull)
```

## Improvements

### A single iteration
```{r}
mbm_singleit1 <- microbenchmark(
  # Current
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
    rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
  },
  # Efficient filter
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),
           failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
    rpwexp(n=sum(indx),
           failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  },
  times = 100
)

levels(mbm_singleit1$expr) <- c("Current",
                                "Efficient filter")
mbm_singleit1
```


### The nested for loop
```{r}
mbm_nested1 <- microbenchmark(
  # Current nested for loop
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}    
  },
  # Nested for loop with efficient filter
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),
               failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
        rpwexp(n=sum(indx),
               failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}    
  },
  times = 100
)

levels(mbm_nested1$expr) <- c("Current nested loop",
                              "Nested loop with efficient filter")
mbm_nested1
```

### The source code of `simPWSurv`
```{r}
mbm_sim1 <- microbenchmark(
  # Current
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        x$failTime[indx] <- rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        x$dropoutTime[indx] <- rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}
  },
  # Efficient filter
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      x$failTime[indx] <- rpwexp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      x$dropoutTime[indx] <- rpwexp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}
  },
  times = 100
)

levels(mbm_sim1$expr) <- c("Current simPWSurv",
                           "simPWSurv with efficient filter")
mbm_sim1
```

Using brackets for filtering data gains 45-fold speedup for a single iteration, 15-fold speedup for the nested loop, and 5-fold speedup for the `simPWSurv`.

## Profile again

### A single iteration of the nested for loops
```{r}
prof_singleit1 <- microbenchmark(
  # Get index of x
  x$Stratum==sr & x$Treatment==tr,
  # Count index of x
  sum(x_indx),
  # Get index of failRates and dropoutRates,
  {
    failRates$Stratum==sr & failRates$Treatment==tr
    dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
  },
  # Subset failRates
  {
    failRates[f_indx,]
    dropoutRates[d_indx,]
  },
  # rpwexp
  {
    rpwexp(n = x_n, failRates = test_failRates)
    rpwexp(n = x_n, failRates = test_dropoutRates)
  },
  times = 1000
)
levels(prof_singleit1$expr) <- c("Get x_index", "Count x_index", "Get f_index", "Filter data", "rpwexp")
prof_singleit1
```

After optimizing filtering, `rpwexp` takes half of the runtime of a single iteration.

### The source code of `simPWSurv`
```{r}
set.seed(2022)
prof_sim1 <- microbenchmark(
  # Create a tibble
  tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
    mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
    group_by(Stratum) %>% 
    mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
    group_by(Stratum, Treatment),
  # Get unique treatments and strata
  {
    utr <- unique(x$Treatment)
    usr <- unique(x$Stratum)
  },
  # Initialize columns of x
  {
    x$failTime <- 0
    x$dropoutTime <- 0
  },
  # Nested for loops to generate failTime and dropoutTime
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      rpwexp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      rpwexp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  }},
  times = 100
)
levels(prof_sim1$expr) <- c("Create a tibble",
                        "Get unique treatments and strata",
                        "Initialize columns of x",
                        "Nested for loops")
prof_sim1
```

Now creating a `tibble` takes 2/3 of the runtime, while the nested for loop takes the rest 1/3 of the runtime.


# Generate piecewise Exponential random numbers

## The inverse transform method

### `rexp(1)`
```{r}
rpwexpexp <- function(n, rate = 1, duration = 1) {
  # Need to check rate, t are positive real vectors of same length, t is increasing, h > 0
  n_piece <- length(rate)
  # Get number of piecewise rates
  H <- c(0, cumsum(rate * duration))[1:n_piece]
  duration <- c(0, cumsum(duration))[1:n_piece]
  # Generate cumulative hazard for each observation
  y <- rexp(n = n, rate = 1)
  # Make a vector to record with interval each observation is in
  interval <- rep(1, n)
  if (n_piece > 1) {
    for (i in 2:(n_piece)) interval[y >= H[i]] <- i
    # if rate[i-1] = 0 (i.e. H[i] == H[i-1]), no observation will fall in to [i-1, i)
  }
  y <- (y - H[interval]) / rate[interval] + duration[interval]
  # if rate[n_piece] == 0, observations in final interval are Inf
  return (y)
}
```

### `runif`
```{r}
rpwexpunif <- function(n, rate, duration){
  # Need to check rate, t are positive real vectors of same length, t is increasing, h > 0
  n_piece <- length(rate)
  # Get number of piecewise rates
  H <- c(0, cumsum(rate * duration))[1:n_piece]
  duration <- c(0, cumsum(duration))[1:n_piece]
  # Generate cumulative hazard for each observation
  y <- -log(runif(n))
  # Make a vector to record with interval each observation is in
  interval <- rep(1, n)
  if (n_piece > 1) {
    for (i in 2:(n_piece)) {
      interval[y >= H[i]] <- i
    }
  }
  y <- (y - H[interval]) / rate[interval] + duration[interval]
  return (y)
}

# Simulate failRates
n_rates <- 10
duration <- floor(runif(n_rates, 1, 5))
rate <- runif(n_rates, 0.0005, 0.095)
rate[5] <- 0.0
rate[10] <- 0.0
tchange1 <- cumsum(duration)
tchange0 <- c(0, tchange1)[1:(length(duration-1))]

# Expect the same results
set.seed(2)
s1 <- PWEALL::rpwe(n = 10, rate = rate, tchange = tchange0)
set.seed(2)
s2 <- rpwexpunif(n = 10, rate = rate, duration = duration)
set.seed(2)
s3 <- simtrial::rpwexpinvRcpp(n = 10, failRates = data.frame(duration = duration,
                                                             rate = rate))

all.equal(s1$r, s2)
all.equal(s2, s3)
```

## Benchmark different methods for generating piecewise Exponential random numbers

### Generate ~100 observations using ~5 intervals
```{r}
# PWEALL requires time changing point
tchange0 <- cumsum(c(0, test_failRates$duration))[1:(length(test_failRates$duration-1))] # exclusive prefix sum of duration

mbm_rpwexp <- microbenchmark(
  # R
  rpwexp(n = x_n, failRates = test_failRates),
  # C++
  rpwexpRcpp(n = x_n, failRates = test_failRates),
  # Inverse exp(1) in R
  rpwexpexp(n = x_n, rate = test_failRates$rate, duration = test_failRates$duration),
  # Inverse unif in R
  rpwexpunif(n = x_n, rate = test_failRates$rate, duration = test_failRates$duration),
  # Inverse unif in C++
  rpwexpinvRcpp(n = x_n, failRates = test_failRates),
  # PWEALL (Inverse unif in Fortran)
  PWEALL::rpwe(n = x_n, rate = test_failRates$rate, tchange = tchange0),
  times = 1000
)
levels(mbm_rpwexp$expr) <- c("Current method in R",
                             "Current method in C++",
                             "Inverse CDF with exp(1) in R",
                             "Inverse CDF with unif in R",
                             "Inverse CDF with unif in C++",
                             "Inverse CDF with unif in Fortran")
mbm_rpwexp
```

The inverse transform method in C++ is 3 times faster than the current implementation in R in this small example.

### Runtime comparison across different number of observations to be generated
```{r}
bm_rpwexp <- function(n, nr, itr = 1000) {
  # simulate failRates
  duration <- floor(runif(nr, 1, 5))
  rate <- runif(nr, 0.0005, 0.095)
  failTbl <- tibble(duration, rate)
  tchange0 <- cumsum(c(0, duration))[1:(length(duration-1))]

  times <- rep(0, 6)
  for (i in 1:itr) {
    # Current method in R
    start_time <- Sys.time()
    rpwexp(n = n, failRates = failTbl)
    end_time <- Sys.time()
    times[1] = times[1] + end_time - start_time

    # Current method in C++
    start_time <- Sys.time()
    rpwexpRcpp(n = n, failRates = failTbl)
    end_time <- Sys.time()
    times[2] = times[2] + end_time - start_time

    # Inverse CDF with exp(1) in R
    start_time <- Sys.time()
    rpwexpexp(n = n, rate = rate, duration = duration)
    end_time <- Sys.time()
    times[3] = times[3] + end_time - start_time

    # Inverse CDF with unif in R
    start_time <- Sys.time()
    rpwexpunif(n = n, rate = rate, duration = duration)
    end_time <- Sys.time()
    times[4] = times[4] + end_time - start_time

    # Inverse CDF with unif in C++
    start_time <- Sys.time()
    rpwexpinvRcpp(n = x_n, failRates = failTbl)
    end_time <- Sys.time()
    times[5] = times[5] + end_time - start_time

    # Inverse CDF with unif in Fortran
    start_time <- Sys.time()
    PWEALL::rpwe(n = n, rate = rate, tchange = tchange0)
    end_time <- Sys.time()
    times[6] = times[6] + end_time - start_time
  }

  return (times * 1e6 / itr)
}

nr_pool <- c(2, 4, 6, 8, 10, 20, 50, 100) # number of time intervals
n_pool <- c(50, 100, 200, 500, 1000, 1500, 2000, 5000, 10000) # number of observations to be generated

##################################################################
# Fix n_rates = 5
nr <- 5

# Dataframe for storing timing results
times_n <- data.frame(matrix(ncol = 7, nrow = length(n_pool)))
colnames(times_n) <- c("n",
                       "rpwexp",
                       "rpwexpRcpp",
                       "rpwexpexp",
                       "rpwexpunif",
                       "rpwexpinvRcpp",
                       "PWEALL")
times_n$n <- n_pool

# Benchmark
for (i in 1:length(n_pool)) {
  times_n[i, 2:7] <- bm_rpwexp(n_pool[i], nr)
}

# Reshape timing results for plot
df_times_n <- data.frame(x = times_n$n,
                         y = c(times_n$rpwexp,
                               times_n$rpwexpRcpp,
                               times_n$rpwexpexp,
                               times_n$rpwexpunif,
                               times_n$rpwexpinvRcpp,
                               times_n$PWEALL),
                         group = c(rep("Current method in R", nrow(times_n)),
                                   rep("Current method in C++", nrow(times_n)),
                                   rep("Inverse CDF with exp(1) in R", nrow(times_n)),
                                   rep("Inverse CDF with unif in R", nrow(times_n)),
                                   rep("Inverse CDF with unif in C++", nrow(times_n)),
                                   rep("Inverse CDF with unif in Fortran", nrow(times_n))))
ggplot(df_times_n, aes(x, y, col = group)) +
  geom_line() +
  scale_x_log10(breaks = c(50, 100, 200, 500, 1000, 2000, 5000, 10000)) +
  # scale_x_continuous(trans='log10') + 
  scale_y_continuous(trans='log10') + 
  labs(x = "number of observations to be generated", y = paste0("time (", "\U003BC", "s)"))
```

### Runtime comparison across different number of intervals
```{r}
# Fix n = 1000
n <- 1000

# Dataframe for storing timing results
times_nr <- data.frame(matrix(ncol = 7, nrow = length(nr_pool)))
colnames(times_nr) <- c("n_rates",
                        "rpwexp",
                        "rpwexpRcpp",
                        "rpwexph",
                        "rpwexpunif",
                        "rpwexpinvRcpp",
                        "PWEALL")
times_nr$n_rates <- nr_pool

# Benchmark
for (i in 1:length(nr_pool)) {
  times_nr[i, 2:7] <- bm_rpwexp(n, nr_pool[i])
}

# Reshape timing results for plot
df_times_nr <- data.frame(x = times_nr$n_rates,
                          y = c(times_nr$rpwexp,
                                times_nr$rpwexpRcpp,
                                times_nr$rpwexph,
                                times_nr$rpwexpunif,
                                times_nr$rpwexpinvRcpp,
                                times_nr$PWEALL),
                          group = c(rep("Current method in R", nrow(times_nr)),
                                    rep("Current method in C++", nrow(times_nr)),
                                    rep("Inverse CDF with exp(1) in R", nrow(times_nr)),
                                    rep("Inverse CDF with unif in R", nrow(times_nr)),
                                    rep("Inverse CDF with unif in C++", nrow(times_nr)),
                                    rep("Inverse CDF with unif in Fortran", nrow(times_nr))))
ggplot(df_times_nr, aes(x, y, col = group)) +
  geom_line() +
  scale_x_continuous(trans='log10') +
  labs(x = "number of intervals", y = paste0("time (", "\U003BC", "s)"))
```


## Improvements

### A single iteration
```{r}
mbm_singleit2 <- microbenchmark(
  # Current
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
    rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
  },
  # Efficient filter
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexp(n=sum(indx),
           failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
    rpwexp(n=sum(indx),
           failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  },
  # Efficient filter and rpwexpinvRcpp
  {
    indx <- x$Stratum==sr & x$Treatment==tr
    rpwexpinvRcpp(n=sum(indx),
           failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
    rpwexpinvRcpp(n=sum(indx),
           failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])  },
  times = 100
)

levels(mbm_singleit2$expr) <- c("Current",
                                "Efficient filter",
                                "Efficient filter and rpwexpinvRcpp")
mbm_singleit2
```


### The nested for loop
```{r}
mbm_nested2 <- microbenchmark(
  # Current nested for loop
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}    
  },
  # Nested for loop with efficient filter
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexp(n=sum(indx),
               failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
        rpwexp(n=sum(indx),
               failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}    
  },
  # Nested for loop with efficient filter and rpwexpinvRcpp
  {
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        rpwexpinvRcpp(n=sum(indx),
               failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
        rpwexpinvRcpp(n=sum(indx),
               failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}    
  },
  times = 100
)

levels(mbm_nested2$expr) <- c("Current nested loop",
                              "Nested loop with efficient filter",
                              "Nested loop with efficient filter and rpwexpinvRcpp")
mbm_nested2
```

### The source code of `simPWSurv`
```{r}
mbm_sim2 <- microbenchmark(
  # Current
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
        indx <- x$Stratum==sr & x$Treatment==tr
        x$failTime[indx] <- rpwexp(n=sum(indx),failRates=filter(failRates,Stratum==sr&Treatment==tr))
        x$dropoutTime[indx] <- rpwexp(n=sum(indx),failRates=filter(dropoutRates,Stratum==sr&Treatment==tr))
    }}
  },
  # Efficient filter
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      x$failTime[indx] <- rpwexp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      x$dropoutTime[indx] <- rpwexp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}
  },
  # Efficient filter and rpwexpinvRcpp
  {
    tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
      mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
      group_by(Stratum) %>% 
      mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
      group_by(Stratum, Treatment)
    unique(x$Treatment)
    unique(x$Stratum)
    x$failTime <- 0
    x$dropoutTime <- 0
    for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      x$failTime[indx] <- rpwexpinvRcpp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      x$dropoutTime[indx] <- rpwexpinvRcpp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
    }}
  },
  times = 100
)

levels(mbm_sim2$expr) <- c("Current simPWSurv",
                           "simPWSurv with efficient filter",
                           "simPWSurv with efficient filter and rpwexpinvRcpp")
mbm_sim2
```


## Profile again

### A single iteration of the nested for loops
```{r}
prof_singleit2 <- microbenchmark(
  # Get index of x
  x$Stratum==sr & x$Treatment==tr,
  # Count index of x
  sum(x_indx),
  # Get index of failRates and dropoutRates,
  {
    failRates$Stratum==sr & failRates$Treatment==tr
    dropoutRates$Stratum==sr & dropoutRates$Treatment==tr
  },
  # Subset failRates
  {
    failRates[f_indx,]
    dropoutRates[d_indx,]
  },
  # rpwexp
  {
    rpwexpinvRcpp(n = x_n, failRates = test_failRates)
    rpwexpinvRcpp(n = x_n, failRates = test_dropoutRates)
  },
  times = 1000
)
levels(prof_singleit2$expr) <- c("Get x_index", "Count x_index", "Get f_index", "Filter data", "rpwexpinvRcpp")
prof_singleit2
```

After optimizing `rpwexp`, generating piecewise Exponential random numbers only takes ~$20\%$ of runtime of a single iteration.

### The source code of `simPWSurv`
```{r}
set.seed(2022)
prof_sim2 <- microbenchmark(
  # Create a tibble
  tibble(Stratum = sample(x = strata$Stratum, size = n, replace = TRUE, prob = strata$p)) %>%
    mutate(enrollTime = rpwenroll(n, enrollRates)) %>%
    group_by(Stratum) %>% 
    mutate(Treatment = fixedBlockRand(n = n(), block = block))  %>%
    group_by(Stratum, Treatment),
  # Get unique treatments and strata
  {
    utr <- unique(x$Treatment)
    usr <- unique(x$Stratum)
  },
  # Initialize columns of x
  {
    x$failTime <- 0
    x$dropoutTime <- 0
  },
  # Nested for loops to generate failTime and dropoutTime
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      rpwexpinvRcpp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      rpwexpinvRcpp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  }},
  times = 100
)
levels(prof_sim2$expr) <- c("Create a tibble",
                            "Get unique treatments and strata",
                            "Initialize columns of x",
                            "Nested for loops")
prof_sim2
```

Now creating a `tibble` takes 3/4 of the runtime, while the nested for loop takes the rest 1/4 of the runtime.


# Use `mapply` to avoid the nested for loop
```{r}
generateAllFailTime <- function(x, failRates, asr, atr) {
  generateFailTime <- function(sr, tr) {
    indx <- x$Stratum==sr & x$Treatment==tr
    findx <- failRates$Stratum == sr & failRates$Treatment == tr
    return(rpwexpinvRcpp(n = sum(indx),
                         failRates = failRates[findx, ]))
  }
  mapply(generateFailTime, asr, atr)
}
```

## Improvments

### The nested for loop
```{r}
set.seed(2022)
mbm_nested3 <- microbenchmark(
  # Nested for loops to generate failTime and dropoutTime
  for(sr in usr){for(tr in utr){
      indx <- x$Stratum==sr & x$Treatment==tr
      # failTime
      rpwexpinvRcpp(n=sum(indx),
             failRates=failRates[failRates$Stratum==sr & failRates$Treatment==tr, ])
      # dropoutTime
      rpwexpinvRcpp(n=sum(indx),
             failRates=dropoutRates[dropoutRates$Stratum==sr & dropoutRates$Treatment==tr, ])
  }},
  # Use mapply to generate failTime and dropoutTime
  {
    asr <- rep(usr, each = length(utr), times = 1)
    atr <- rep(utr, each = 1, times = length(usr))
    # failTime
    unlist(generateAllFailTime(x, failRates, asr, atr))
    # dropoutTime
    unlist(generateAllFailTime(x, dropoutRates, asr, atr))
  },
  times = 100
)
levels(mbm_nested3$expr) <- c("Nested for loops",
                            "mapply")
mbm_nested3
```

In this example, `mapply` is 3 times faster than the nested for loop.


# Parallelization - TODO


# Create a `tibble` - TODO


# Overall improvement

- Update in `simPWSurvNew`:
    - Filter rows using brackets instead of `dplyr` when calling `rpwexp`.
    - Generate piecewise Exponential random numbers using the inverse transform method implemented in C++.
    - Generate failure rates and dropout rates using `mapply` instead of the nested for loop. 

- Speedup: $\times$ 7
```{r, warning=FALSE}
set.seed(2022)
mbm_simPWSurv <- microbenchmark(
  simPWSurv(n = 1000, 
            strata = strata,
            block = block,
            enrollRates = enrollRates,
            failRates = failRates,
            dropoutRates = dropoutRates),
  simPWSurvNew(n = 1000, 
               strata = strata,
               block = block,
               enrollRates = enrollRates,
               failRates = failRates,
               dropoutRates = dropoutRates),
  times = 100
)
levels(mbm_simPWSurv$expr) <- c("simPWSurv", "simPWSurvNew")
mbm_simPWSurv
```

# Benchmark Example for `simfix`

## Example 1: Biomarker Positive

In this example, we consider

- 2 strata
- 2 periods in enrollments
- 4 periods in failure rates of the control arm per stratum
- 4 periods in failure rates of the experimental arm per stratum
- 4 periods in dropout rates of the control arm per stratum
- 4 periods in dropout rates of the experimental arm per stratum

```{r}
# 2 strata: Biomarker negative (50% of population) + Biomarker positive (50% of population); 
strata <- tibble(Stratum = c("Biomarker Negative", "Biomarker Positive"), p = c(.5, .5))

block <- c(rep("Control", 2), rep("Experimental", 2))

# enrollment over 1 year, with ramp-up over first 6 months
enrollRates <- tibble(rate = c(9, 2), duration = c(6, 6))

# failure rate:
# - biomarker negative: control is exponential with median of 12 months; experimental has HR = 1.2 for 4 months followed by HR=.65
# - biomarker positive: control is exponential with median of 12 months; experimental has HR = .9 for 4 months followed by HR=.4)
failRates <- tibble(
  Stratum = c(rep("Biomarker Negative", 3), rep("Biomarker Positive", 3)),
  period = c(1, 1:2, 1, 1:2),
  Treatment = rep(c("Control", rep("Experimental", 2)), 2),
  duration = c(12, 4, 8, 12, 4, 8), 
  rate = c(log(2)/12, log(2)/12*1.2, log(2)/12*0.65, log(2)/12, log(2)/12*0.9, log(2)/12*0.4)
)

# dropout rate
dropoutRates <- tibble(
  Stratum = c(rep("Biomarker Negative", 4), rep("Biomarker Positive", 4)),
  period = rep(1:2, 4),
  Treatment = rep(c(rep("Control", 2), rep("Experimental", 2)), 2),
  duration = rep(c(3, 1), 4),
  rate = rep(c(.001, .001), 4)
)

# Create failRatesAll for simfix
failRatesAll <- failRates[failRates$Treatment == "Experimental", ]
failRatesAll$dropoutRate <- dropoutRates[dropoutRates$Treatment == "Experimental", ]$rate
failRatesAll$hr <- c(rep(0.6, 2), rep(0.9, 2))
failRatesAll <- failRatesAll %>%
  mutate(failRate = rate/hr) %>%
  select("Stratum", "duration", "failRate", "hr", "dropoutRate")
rg <- tibble(rho = 0, gamma = 0)
```

### One simulation: `simfix`
```{r}
ex_simfix1 <- microbenchmark(
  simfix(
    nsim = 1, # Number of simulations
    sampleSize = 1000, # Trial sample size
    targetEvents = 350, # Targeted events at analysis
    strata = strata, # Study strata
    enrollRates = enrollRates, # Enrollment rates
    failRates = failRatesAll, # Failure rates
    totalDuration = 30, # Planned trial duration
    block = block, # Block for treatment
    timingType = 1:5, # Use all possible data cutoff methods
    rg = rg # FH test(s) to use; in this case, logrank
  ),
  simfixNew(
    nsim = 1, # Number of simulations
    sampleSize = 1000, # Trial sample size
    targetEvents = 350, # Targeted events at analysis
    strata = strata, # Study strata
    enrollRates = enrollRates, # Enrollment rates
    failRates = failRatesAll, # Failure rates
    totalDuration = 30, # Planned trial duration
    block = block, # Block for treatment
    timingType = 1:5, # Use all possible data cutoff methods
    rg = rg # FH test(s) to use; in this case, logrank
  ),
  times = 10
)
levels(ex_simfix1$expr) <- c("simfix", "simfixNew")
ex_simfix1
```

### One simulation: `simPWSurv`
```{r}
sampleSize = 1000 # Trial sample size

# put failure rates into simPWSurv format
xx <- simfix2simPWSurv(failRatesAll)
fr <- xx$failRates
dr <- xx$dropoutRates

ex_simPWSurv <- microbenchmark(
  simPWSurv(n = sampleSize,
            strata = strata,
            enrollRates = enrollRates,
            failRates = fr,
            dropoutRates = dr,
            block = block),
  simPWSurvNew(n = sampleSize,
               strata = strata,
               enrollRates = enrollRates,
               failRates = fr,
               dropoutRates = dr,
               block = block),
  times = 100
)
levels(ex_simPWSurv$expr) <- c("simPWSurv", "simPWSurvNew")
ex_simPWSurv
```

### One hundred simulations
```{r}
system.time(
    simfix(
    nsim = 100, # Number of simulations
    sampleSize = 1000, # Trial sample size
    targetEvents = 350, # Targeted events at analysis
    strata = strata, # Study strata
    enrollRates = enrollRates, # Enrollment rates
    failRates = failRatesAll, # Failure rates
    totalDuration = 30, # Planned trial duration
    block = block, # Block for treatment
    timingType = 1:5, # Use all possible data cutoff methods
    rg = rg # FH test(s) to use; in this case, logrank
  )
)

system.time(
  simfixNew(
    nsim = 100, # Number of simulations
    sampleSize = 1000, # Trial sample size
    targetEvents = 350, # Targeted events at analysis
    strata = strata, # Study strata
    enrollRates = enrollRates, # Enrollment rates
    failRates = failRatesAll, # Failure rates
    totalDuration = 30, # Planned trial duration
    block = block, # Block for treatment
    timingType = 1:5, # Use all possible data cutoff methods
    rg = rg # FH test(s) to use; in this case, logrank
  )
)
```

