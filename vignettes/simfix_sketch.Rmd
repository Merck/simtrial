---
title: "Benchmark Example for `simfix`"
author: "Jianxiao Yang"
output:
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
    number_sections: true
---

```{r}
sessionInfo()
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(simtrial)
library(knitr)
library(tibble)
library(dplyr)
library(gt)
library(ggplot2)
library(profvis)
library(bench)
library(microbenchmark)
library(PWEALL)
library(parallel)
library(doParallel)
devtools::load_all()
```

# Data

In this example, we consider

- 2 strata
- 2 periods in enrollments
- 4 periods in failure rates of the control arm per stratum
- 4 periods in failure rates of the experimental arm per stratum
- 4 periods in dropout rates of the control arm per stratum
- 4 periods in dropout rates of the experimental arm per stratum

```{r data}
# 2 strata: Biomarker negative (50% of population) + Biomarker positive (50% of population); 
enrollStrata <- tibble(Stratum = c("Biomarker Negative", "Biomarker Positive"), p = c(.5, .5))

block <- c(rep("Control", 2), rep("Experimental", 2))

# enrollment over 1 year, with ramp-up over first 6 months
enrollRates <- tibble(rate = c(9, 2), duration = c(6, 6))

# failure rate:
# - biomarker negative: control is exponential with median of 12 months; experimental has HR = 1.2 for 4 months followed by HR=.65
# - biomarker positive: control is exponential with median of 12 months; experimental has HR = .9 for 4 months followed by HR=.4)
failRates <- tibble(
  Stratum = c(rep("Biomarker Negative", 3), rep("Biomarker Positive", 3)),
  period = c(1, 1:2, 1, 1:2),
  Treatment = rep(c("Control", rep("Experimental", 2)), 2),
  duration = c(12, 4, 8, 12, 4, 8), 
  rate = c(log(2)/12, log(2)/12*1.2, log(2)/12*0.65, log(2)/12, log(2)/12*0.9, log(2)/12*0.4)
)

# dropout rate
dropoutRates <- tibble(
  Stratum = c(rep("Biomarker Negative", 4), rep("Biomarker Positive", 4)),
  period = rep(1:2, 4),
  Treatment = rep(c(rep("Control", 2), rep("Experimental", 2)), 2),
  duration = rep(c(3, 1), 4),
  rate = rep(c(.001, .001), 4)
)

# Create failRatesAll for simfix
failRatesAll <- failRates[failRates$Treatment == "Experimental", ]
failRatesAll$dropoutRate <- dropoutRates[dropoutRates$Treatment == "Experimental", ]$rate
failRatesAll$hr <- c(rep(0.6, 2), rep(0.9, 2))
failRatesAll <- failRatesAll %>%
  mutate(failRate = rate/hr) %>%
  select("Stratum", "duration", "failRate", "hr", "dropoutRate")
rg <- tibble(rho = 0, gamma = 0)
```


# Parallel Computing using `foreach` 
```{r detectCores}
detectCores()
```

```{r runSimfix}
# Functions for run simfix and simfixNew in serial and in parallel

runSimfix <- function(nsim = 1000, # Number of simulations
                      sampleSize = 800, # Trial sample size
                      targetEvents = 350, # Targeted events at analysis
                      totalDuration = 30, # Planned trial duration
                      timingType = 1:5 # Use all possible data cutoff methods
                      ) {
  times <- rep(0, 5)
  cores <- c(1, 2, 4, 6, 8)

  # In serial
  registerDoParallel(1)
  start <- Sys.time()
  s <- simfix(
    nsim = nsim, # Number of simulations
    sampleSize = sampleSize, # Trial sample size
    targetEvents = targetEvents, # Targeted events at analysis
    enrollStrata = enrollStrata, # Study strata
    enrollRates = enrollRates, # Enrollment rates
    failRates = failRatesAll, # Failure rates
    totalDuration = totalDuration, # Planned trial duration
    block = block, # Block for treatment
    timingType = timingType, # Use all possible data cutoff methods
    rg = rg, # FH test(s) to use; in this case, logrank
    setSeed = TRUE
  )
  times[1] <- Sys.time() - start
  
  # In parallel
  for (i in 2:length(cores)) {
    registerDoParallel(cores[i])
    start <- Sys.time()
    sp <- simfix(
      nsim = nsim, # Number of simulations
      sampleSize = sampleSize, # Trial sample size
      targetEvents = targetEvents, # Targeted events at analysis
      enrollStrata = enrollStrata, # Study strata
      enrollRates = enrollRates, # Enrollment rates
      failRates = failRatesAll, # Failure rates
      totalDuration = totalDuration, # Planned trial duration
      block = block, # Block for treatment
      timingType = timingType, # Use all possible data cutoff methods
      rg = rg, # FH test(s) to use; in this case, logrank
      setSeed = TRUE
    )
    times[i] <- Sys.time() - start
    message("Results are identical: ", identical(s, sp))
  }

  return (times)
}

runSimfixNew <- function(nsim = 1000, # Number of simulations
                         sampleSize = 800, # Trial sample size
                         targetEvents = 350, # Targeted events at analysis
                         totalDuration = 30, # Planned trial duration
                         timingType = 1:5 # Use all possible data cutoff methods
                         ) {
  times <- rep(0, 5)
  cores <- c(1, 2, 4, 6, 8)

  # In serial
  registerDoParallel(1)
  start <- Sys.time()
  s <- simfixNew(
    nsim = nsim, # Number of simulations
    sampleSize = sampleSize, # Trial sample size
    targetEvents = targetEvents, # Targeted events at analysis
    enrollStrata = enrollStrata, # Study strata
    enrollRates = enrollRates, # Enrollment rates
    failRates = failRatesAll, # Failure rates
    totalDuration = totalDuration, # Planned trial duration
    block = block, # Block for treatment
    timingType = timingType, # Use all possible data cutoff methods
    rg = rg, # FH test(s) to use; in this case, logrank
    setSeed = TRUE
  )
  times[1] <- Sys.time() - start
  
  # In parallel
  for (i in 2:length(cores)) {
    registerDoParallel(cores[i])
    start <- Sys.time()
    sp <- simfixNew(
      nsim = nsim, # Number of simulations
      sampleSize = sampleSize, # Trial sample size
      targetEvents = targetEvents, # Targeted events at analysis
      enrollStrata = enrollStrata, # Study strata
      enrollRates = enrollRates, # Enrollment rates
      failRates = failRatesAll, # Failure rates
      totalDuration = totalDuration, # Planned trial duration
      block = block, # Block for treatment
      timingType = timingType, # Use all possible data cutoff methods
      rg = rg, # FH test(s) to use; in this case, logrank
      setSeed = TRUE
    )
    times[i] <- Sys.time() - start
    message("Results are identical: ", identical(s, sp))
  }

  return (times)
}
```

## 100 simulations
```{r 100sims}
n_sim <- 100
cores <- c(1, 2, 4, 6, 8)

times_100 <- runSimfix(nsim = n_sim)
times_100_new <- runSimfixNew(nsim = n_sim)

# Reshape timing results for plot
df_times_100 <- data.frame(x = cores,
                           y = c(times_100,
                                 times_100_new),
                           group = c(rep("simfix", length(cores)),
                                     rep("simfixNew", length(cores))))
ggplot(df_times_100, aes(x, y, col = group)) +
  geom_line() +
  scale_x_continuous(breaks = cores) +
  labs(x = "cores", y = paste0("time (sec)"))

# Table
kable(t(data.frame(cores = as.character(cores),
                   simfix = times_100,
                   simfixNew = times_100_new)))
```

## 10000 simulations
```{r 10000sims, cache = TRUE, eval = FALSE}
n_sim <- 10000
cores <- c(1, 2, 4, 6, 8)
times_10000_new <- runSimfixNew(nsim = n_sim)
times_10000 <- runSimfix(nsim = n_sim)

# Reshape timing results for plot
df_times_10000 <- data.frame(x = cores,
                             y = c(times_10000,
                                   times_10000_new),
                             group = c(rep("simfix", length(cores)),
                                       rep("simfixNew", length(cores))))
ggplot(df_times_10000, aes(x, y, col = group)) +
  geom_line() +
  scale_x_continuous(breaks = cores) +
  labs(x = "cores", y = paste0("time (min)"))

# Table
kable(t(data.frame(cores = as.character(cores),
                   simfix = times_10000,
                   simfixNew = times_10000_new)))
```


# Optimize one simulation

## Profile one simulation
```{r}
sampleSize = 800
targetEvents = 350
totalDuration = 30
timingType = 1:5

nstrata <- nrow(enrollStrata)
doAnalysis <- function(d,rg,nstrata){
  if (nrow(rg)==1) {
    Z = tibble::tibble(Z=(d %>%
                            simtrial::tensurv(txval="Experimental") %>%
                            simtrial::tenFH(rg=rg))$Z)
  } else {
    Z = d %>%
      simtrial::tensurv(txval="Experimental") %>%
      simtrial::tenFHcorr(rg=rg,corr=TRUE)
  }
    r <- cbind(tibble::tibble(Events = sum(d$event),
                              lnhr = as.numeric(ifelse(nstrata>1,
                                                       survival::coxph(survival::Surv(tte,event)~
                                                                         (Treatment=="Experimental")+
                                                     survival::strata(Stratum),data=d)$coefficients,
                                   survival::coxph(survival::Surv(tte,event)~
                                                     (Treatment=="Experimental"),data=d)$coefficients))
                           ),
               Z
    )
  r
}

# compute minimum planned follow-up time
minFollow <- max(0,totalDuration - sum(enrollRates$duration))
# put failure rates into simPWSurv format
xx <- simfix2simPWSurv(failRatesAll)
fr <- xx$failRates
dr <- xx$dropoutRates

# Benchmark
n_iter = 20
times_iter <- rep(0, 6)
for (i in 1:n_iter) {
  set.seed(2022)

  # simPWSurvNew
  s1 <- Sys.time()
  sim <- simtrial::simPWSurvNew(n = sampleSize,
                               enrollStrata = enrollStrata,
                               enrollRates = enrollRates,
                               failRates = fr,
                               dropoutRates = dr,
                               block = block)
  times_iter[1] = times_iter[1] + Sys.time() - s1

  # getCutDateForCount
  s2 <- Sys.time()
  # study date that targeted event rate achieved
  tedate <- sim %>% getCutDateForCount(targetEvents)
  times_iter[2] = times_iter[2] + Sys.time() - s2

  # Compute tests
  s3 <- Sys.time()
  # study data that targeted minimum follow-up achieved
  tmfdate <- max(sim$enrollTime) + minFollow
  # Compute tests for all specified cutoff options
  r1 <- NULL ; r2 <- NULL; r3 <- NULL;
  tests <- rep(FALSE,3)
  ## Total planned trial duration or max of this and targeted events
  if (max(1 == timingType)) tests[1] <- TRUE # planned duration cutoff
  if (max(2 == timingType)) tests[2] <- TRUE # targeted events cutoff
  if (max(3 == timingType)) tests[3] <- TRUE # minimum follow-up duration target
  if (max(4 == timingType)){ # max of planned duration, targeted events
    if (tedate > totalDuration){
      tests[2] <- TRUE
    }else tests[1] <- TRUE
  }
  if (max(5 == timingType)){ # max of minimum follow-up, targeted events
    if (tedate > tmfdate){
      tests[2] <- TRUE
    }else tests[3] <- TRUE
  }
  times_iter[3] = times_iter[3] + Sys.time() - s3

  # cutData
  s4 <- Sys.time()
    if (tests[1]){ # Total duration cutoff
      d1 <- sim %>% cutData(totalDuration)
      # r1 <- d %>% doAnalysis(rg,nstrata)
    }
    if (tests[2]){ # targeted events cutoff
      d2 <- sim %>% cutData(tedate)
      # r2 <- d %>% doAnalysis(rg,nstrata)
    }
    if (tests[3]){ # minimum follow-up cutoff
      d3 <- sim %>% cutData(tmfdate)
      # r3 <- d %>% doAnalysis(rg,nstrata)
    }
  times_iter[4] = times_iter[4] + Sys.time() - s4

  # doAnalysis
  s5 <- Sys.time()
    if (tests[1]){ # Total duration cutoff
      # d <- sim %>% cutData(totalDuration)
      r1 <- d1 %>% doAnalysis(rg,nstrata)
    }
    if (tests[2]){ # targeted events cutoff
      # d <- sim %>% cutData(tedate)
      r2 <- d2 %>% doAnalysis(rg,nstrata)
    }
    if (tests[3]){ # minimum follow-up cutoff
      # d <- sim %>% cutData(tmfdate)
      r3 <- d3 %>% doAnalysis(rg,nstrata)
    }
  times_iter[5] = times_iter[5] + Sys.time() - s5

  # Compute addit
  s6 <- Sys.time()
    addit <- NULL
    # planned duration cutoff
    if (max(1 == timingType)) addit <- rbind(addit,
                                             r1 %>% mutate(cut="Planned duration",Duration=totalDuration))
    # targeted events cutoff
    if (max(2 == timingType)) addit <- rbind(addit, r2 %>% mutate(cut="Targeted events",Duration=tedate))
    # minimum follow-up duration target
    if (max(3 == timingType)) addit <- rbind(addit, r3 %>% mutate(cut="Minimum follow-up",Duration=tmfdate))
    if (max(4 == timingType)){ # max of planned duration, targeted events
      if (tedate > totalDuration){
        addit <- rbind(addit, r2 %>% mutate(cut="Max(planned duration, event cut)",Duration=tedate))
      }else addit <- rbind(addit, r1 %>% mutate(cut="Max(planned duration, event cut)",Duration=totalDuration))
    }
    if (max(5 == timingType)){ # max of minimum follow-up, targeted events
      if (tedate > tmfdate){
        addit <- rbind(addit, r2 %>% mutate(cut="Max(min follow-up, event cut)",Duration=tedate))
      }else addit <- rbind(addit, r3 %>% mutate(cut="Max(min follow-up, event cut)",Duration=tmfdate))
    }
  times_iter[6] = times_iter[3] + Sys.time() - s6

  # # Clean up
  # rm(list = c("minFollow",
  #             "xx", "dr", "fr",
  #             "tests", "addit",
  #             "d1", "d2", "d3",
  #             "r1", "r2", "r3"))
}

kable(data.frame(eval = c("simPWSurvNew",
                          "getCutDateForCount",
                          "compute tests",
                          "cutData",
                          "doAnalysis",
                          "compute addit"),
                 time = times_iter/n_iter,
                 percent = round(times_iter / sum(times_iter) * 100, 2)))
```
Overall `doAnalysis` take $70\%$ of the runtime in one simulation.

### `doAnalysis`
```{r}
d = d1

# Benchmark
n_iter = 20
times_do <- rep(0, 4)
for (i in 1:n_iter) {

  # tensurv
  s1 <- Sys.time()
  d11 <- d %>% simtrial::tensurv(txval="Experimental")
  times_do[1] = times_do[1] + Sys.time() - s1

  # tenFH
  s2 <- Sys.time()
  d12 <- d11 %>% simtrial::tenFH(rg=rg)
  times_do[2] = times_do[2] + Sys.time() - s2

  # Z tibble
  s3 <- Sys.time()
  Z = tibble::tibble(Z=d12$Z)
  times_do[3] = times_do[3] + Sys.time() - s3

  # cbind
  s4 <- Sys.time()
  r <- cbind(tibble::tibble(Events = sum(d$event),
                            lnhr = as.numeric(ifelse(nstrata>1,
                                                     survival::coxph(survival::Surv(tte,event)~
                                                                       (Treatment=="Experimental")+
                                                   survival::strata(Stratum),data=d)$coefficients,
                                 survival::coxph(survival::Surv(tte,event)~
                                                   (Treatment=="Experimental"),data=d)$coefficients))
                         ),
             Z
  )
  times_do[4] = times_do[3] + Sys.time() - s3

# rm(list = c("d11", "d12",
#             "Z", "r"))
}

kable(data.frame(eval = c("tensurv",
                          "tenFH",
                          "Z",
                          "r"),
                 time = times_do/n_iter,
                 percent = round(times_do / sum(times_do) * 100, 2)))
```
Further benchmark `doAnalysis`, we can see `tensurv` is the most time-consuming part.

Overall, the following functions take more than $10\%$ of the runtime in one simulation:

- `tensurv`. A single call of `tensurv` takes ~$20\%$ of the runtime in one simulation, but `tensurv` may be called multiple times (3 times in this example) in one simulation.
- `simPWSurvNew`. ~$10\%$. Only will be called once in one simulation.
- `cutData`. A single call of `cutData` takes ~$4\%$ of the runtime in one simulation, but `cutData` may be called multiple times (3 times in this example) in one simulation.

## `tensurv`
```{r}
options(dplyr.summarise.inform = FALSE)
x <- d3
txval="Experimental"

# Benchmark
n_iter = 20
times_tensurv <- rep(0, 9)
for (i in 1:n_iter) {
  s1 <- Sys.time()
  x1 <- x %>% group_by(Stratum) %>% arrange(desc(tte))
  times_tensurv[1] = times_tensurv[1] + Sys.time() - s1
  
  s2 <- Sys.time()
  x2 <- x1 %>% mutate(one=1,
                      atrisk=cumsum(one),
                      txatrisk=cumsum(Treatment==txval)) 
  times_tensurv[2] = times_tensurv[2] + Sys.time() - s2
  
  s3 <- Sys.time()
  x3 <- x2 %>%
        # Handling ties using Breslow's method
        group_by(Stratum, mtte=desc(tte)) %>%
        dplyr::summarise(events=sum(event),
                         txevents=sum((Treatment==txval)*event),
                         tte=first(tte),
                         atrisk=max(atrisk),
                         txatrisk=max(txatrisk)) 
  times_tensurv[3] = times_tensurv[3] + Sys.time() - s3
  
  s4 <- Sys.time()
  x4 <- x3 %>%
        # Keep calculation for observed time with at least one event, at least one subject is
        # at risk in both treatment group and control group.
        filter(events>0, atrisk-txatrisk>0, txatrisk>0)
  times_tensurv[4] = times_tensurv[4] + Sys.time() - s4
  
  s5 <- Sys.time()
  x5 <- x4 %>%
        select(-mtte) 
  times_tensurv[5] = times_tensurv[5] + Sys.time() - s5
  
  s6 <- Sys.time()
  x6 <- x5 %>%
        mutate(s=1-events/atrisk) 
  times_tensurv[6] = times_tensurv[6] + Sys.time() - s6
  
  s7 <- Sys.time()
  x7 <- x6 %>%
        arrange(Stratum, tte) 
  times_tensurv[7] = times_tensurv[7] + Sys.time() - s7
  
  s8 <- Sys.time()
  x8 <- x7 %>%
        group_by(Stratum) %>%
        mutate(S=lag(cumprod(s), default=1),               # left continuous Kaplan-Meier Estimator
               OminusE=txevents-txatrisk/atrisk*events,    #  Observed events minus Expected events in treatment group
               Var=(atrisk-txatrisk)*txatrisk*events*(atrisk-events)/atrisk^2/(atrisk-1)) 
  times_tensurv[8] = times_tensurv[8] + Sys.time() - s8
  
  s9 <- Sys.time()
  x9 <- x8 %>% #Variance of OminusE
               select(-s)
  times_tensurv[9] = times_tensurv[9] + Sys.time() - s9
}

kable(data.frame(eval = c("group_by arrange",
                          "mutate",
                          "group_by summarise",
                          "filter",
                          "select",
                          "mutate",
                          "arrange",
                          "group_by mutate",
                          "select"),
                 time = times_tensurv/n_iter,
                 percent = round(times_tensurv / sum(times_tensurv) * 100, 2)))
```

### Filter
```{r}
bench::mark(
  filter(x3, events>0, atrisk-txatrisk>0, txatrisk>0),
  x3[which(x3$events > 0 & x3$atrisk - x3$txatrisk > 0 & x3$txatrisk > 0), ],
  iterations = 100
)
```
