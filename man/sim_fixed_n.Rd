% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simfix.R
\name{sim_fixed_n}
\alias{sim_fixed_n}
\title{Simulation of fixed sample size design for time-to-event endpoint}
\usage{
sim_fixed_n(
  nsim = 1000,
  sampleSize = 500,
  target_event = 350,
  stratum = tibble(stratum = "All", p = 1),
  enroll_rate = tibble(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = tibble(stratum = "All", duration = c(3, 100), fail_rate = log(2)/c(9, 18),
    hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),
  totalDuration = 30,
  block = rep(c("Experimental", "Control"), 2),
  timing_type = 1:5,
  rg = tibble(rho = 0, gamma = 0),
  seed = NULL
)
}
\arguments{
\item{nsim}{Number of simulations to perform.}

\item{sampleSize}{Total sample size per simulation.}

\item{target_event}{Targeted event count for analysis.}

\item{stratum}{A tibble with stratum specified in \code{stratum}, probability (incidence) of each stratum in \code{p}.}

\item{enroll_rate}{Piecewise constant enrollment rates by time period.
Note that these are overall population enrollment rates and the \code{stratum} argument controls the
random distribution between stratum.}

\item{fail_rate}{Piecewise constant control group failure rates, hazard ratio for experimental vs control,
and dropout rates by stratum and time period.}

\item{totalDuration}{Total follow-up from start of enrollment to data cutoff.}

\item{block}{As in \code{simtrial::sim_pw_surv()}. Vector of treatments to be included in each block.}

\item{timing_type}{A numeric vector determining data cutoffs used; see details.
Default is to include all available cutoff methods.}

\item{rg}{As in \code{simtrial::tenFHCorr()}.
A \code{tibble} with variables \code{rho} and \code{gamma}, both greater than equal
to zero, to specify one Fleming-Harrington weighted logrank test per row.}

\item{seed}{Optional. Initial seed for simulations}
}
\value{
A \code{tibble} including columns \code{Events} (event count), \code{lnhr} (log-hazard ratio),
\code{Z} (normal test statistic; < 0 favors experimental) cut (text describing cutoff used),
\code{Duration} (duration of trial at cutoff for analysis) and \code{sim} (sequential simulation id).
One row per simulated dataset per cutoff specified in \code{timing_type}, per test statistic specified.
If multiple Fleming-Harrington tests are specified in \code{rg}, then columns {rho,gamma}
are also included.
}
\description{
\code{sim_fixed_n()} provide simulations of a single endpoint two-arm trial
where the enrollment, hazard ratio, and failure and dropout rates change over time.
}
\details{
\code{timing_type} has up to 5 elements indicating different options for data cutoff.
1 uses the planned study duration, 2 the time the targeted event count is achieved,
3 the planned minimum follow-up after enrollment is complete,
4 the maximum of planned study duration and targeted event count cuts (1 and 2),
5 the maximum of targeted event count and minimum follow-up cuts (2 and 3).
}
\examples{
library(tidyr)
library(dplyr)
library(doParallel)
library(tibble)

# example 1
# Show output structure
sim_fixed_n(nsim = 3)

# example 2
# Example with 2 tests: logrank and FH(0,1)
sim_fixed_n(nsim = 1,rg = tibble(rho = 0, gamma = c(0, 1)))

# example 3
# Power by test
# Only use cuts for events, events + min follow-up
xx <- sim_fixed_n(nsim = 100,
             timing_type = c(2, 5),
             rg = tibble(rho = 0, gamma = c(0, 1)))
# Get power approximation for FH, data cutoff combination
xx \%>\%
  group_by(cut, rho, gamma) \%>\%
  summarise(mean(Z <= qnorm(.025)))

# MaxCombo power estimate for cutoff at max of targeted events, minimum follow-up
p <- xx \%>\%
  filter(cut != "Targeted events") \%>\%
  group_by(Sim) \%>\%
  group_map(pvalue_maxcombo) \%>\%
  unlist()

mean(p < .025)

# MaxCombo estimate for targeted events cutoff
p <- xx \%>\%
  filter(cut == "Targeted events") \%>\%
  group_by(Sim) \%>\%
  group_map(pvalue_maxcombo) \%>\%
  unlist()

mean(p < .025)

# example 3
# Use two cores
registerDoParallel(2)
sim_fixed_n(nsim = 10, seed = 2022)
stopImplicitCluster()
registerDoSEQ()

}
