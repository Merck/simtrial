#  Copyright (c) 2024 Merck & Co., Inc., Rahway, NJ, USA and its affiliates.
#  All rights reserved.
#
#  This file is part of the simtrial program.
#
#  simtrial is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' Summary of group sequential simulations.
#'
#' @param object Simulation results generated by [sim_gs_n()]
#' @param design Asymptotic design generated by [gsDesign2::gs_design_ahr()],
#' [gsDesign2::gs_power_ahr()], [gsDesign2::gs_design_wlr()], or [gsDesign2::gs_power_wlr].
#' @param bound The boundaries.
#' @param ... Additional parameters (not used).
#'
#' @rdname summary
#' @return A tibble
#' @export
#'
#' @examples
#' library(gsDesign2)
#'
#' # Parameters for enrollment
#' enroll_rampup_duration <- 4 # Duration for enrollment ramp up
#' enroll_duration <- 16 # Total enrollment duration
#' enroll_rate <- define_enroll_rate(
#'   duration = c(
#'     enroll_rampup_duration, enroll_duration - enroll_rampup_duration),
#'  rate = c(10, 30))
#'
#' # Parameters for treatment effect
#' delay_effect_duration <- 3 # Delay treatment effect in months
#' median_ctrl <- 9 # Survival median of the control arm
#' median_exp <- c(9, 14) # Survival median of the experimental arm
#' dropout_rate <- 0.001
#' fail_rate <- define_fail_rate(
#'   duration = c(delay_effect_duration, 100),
#'   fail_rate = log(2) / median_ctrl,
#'   hr = median_ctrl / median_exp,
#'   dropout_rate = dropout_rate)
#'
#' # Other related parameters
#' alpha <- 0.025 # Type I error
#' beta <- 0.1 # Type II error
#' ratio <- 1 # Randomization ratio (experimental:control)
#'
#' # Build a one-sided group sequential design
#' design <- gs_design_ahr(
#'   enroll_rate = enroll_rate, fail_rate = fail_rate,
#'   ratio = ratio, alpha = alpha, beta = beta,
#'   analysis_time = c(12, 24, 36),
#'   upper = gs_spending_bound,
#'   upar = list(sf = gsDesign::sfLDOF, total_spend = alpha),
#'   lower = gs_b,
#'   lpar = rep(-Inf, 3))
#'
#' # Define cuttings of 2 IAs and 1 FA
#' ia1_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[1]))
#' ia2_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[2]))
#' fa_cut <- create_cut(target_event_overall = ceiling(design$analysis$event[3]))
#'
#' # Run simulations
#' simulation <- sim_gs_n(
#'   n_sim = 3,
#'   sample_size = ceiling(design$analysis$n[3]),
#'   enroll_rate = design$enroll_rate,
#'   fail_rate = design$fail_rate,
#'   test = wlr,
#'   cut = list(ia1 = ia1_cut, ia2 = ia2_cut, fa = fa_cut),
#'   weight = fh(rho = 0, gamma = 0.5))
#'
#' # Summarize simulations
#' simulation |> summary(bound = gsDesign::gsDesign(k = 3, test.type = 1, sfu = gsDesign::sfLDOF)$upper$bound)
#'
#' # Summarize simulation and compare with the planned design
#' simulation |> summary(design = design)
summary.simtrial_gs_wlr <- function(object,
                                    design = NULL,
                                    bound = NULL,
                                    ...) {
  # get the total number of analysis and simulations
  n_analysis <- nrow(object[object$sim_id == 1, ])
  n_sim <- nrow(object) / n_analysis

  # if the design input is NULL
  # then simply output the simulated n, event, power
  if (is.null(design)) {
    ans1 <- object |>
      dplyr::group_by(analysis) |>
      dplyr::summarize(sim_n = mean(n), sim_event = mean(event), sim_time = mean(cut_date))

    ans2 <- object |>
      dplyr::left_join(data.frame(analysis = 1:n_analysis, upper_bound = bound)) |>
      dplyr::mutate(cross_upper = -z >= upper_bound) |>
      dplyr::filter(cross_upper == TRUE) |>
      dplyr::group_by(sim_id) |>
      dplyr::filter(dplyr::row_number() == 1) |>
      dplyr::ungroup() |>
      dplyr::group_by(analysis) |>
      dplyr::summarize(n_cross_upper = dplyr::n()) |>
      dplyr::mutate(sim_upper_prob = cumsum(n_cross_upper) / n_sim) |>
      dplyr::select(analysis, sim_upper_prob)

    suppressMessages(
      ans <- ans1 |> dplyr::left_join(ans2)
    )

    attr(ans, "compare_with_design") <- "no"
  } else {
    # get the design type, 1-sided or 2-sided
    design_type <- ifelse(length(unique(design$bound$bound)) == 1, "one-sided", "two-sided")

    # add the futility and efficacy bounds to the simulation results
    if (design_type == "one-sided") {
      suppressMessages(
        sim_tbl <- object |>
          dplyr::left_join(
            design$bound |>
              dplyr::select(analysis, z, bound) |>
              dplyr::rename(upper_bound = z)
          ) |>
          dplyr::mutate(cross_upper = -z >= upper_bound)
      )
    } else {
      suppressMessages(
        sim_tbl <- object |>
          dplyr::left_join(
            design$bound |>
              dplyr::select(analysis, z, bound) |>
              tidyr::pivot_wider(values_from = z, names_from = bound) |>
              dplyr::rename(lower_bound = lower, upper_bound = upper)
          ) |>
          dplyr::mutate(cross_lower = -z <= lower_bound,
                        cross_upper = -z >= upper_bound)
      )
    }

    # calculate the prob of crossing efficacy bounds
    tbl_upper <- sim_tbl |>
      dplyr::filter(cross_upper == TRUE) |>
      dplyr::group_by(sim_id) |>
      dplyr::filter(dplyr::row_number() == 1) |>
      dplyr::ungroup() |>
      dplyr::group_by(analysis) |>
      dplyr::summarize(n_cross_upper = dplyr::n()) |>
      dplyr::mutate(sim_upper_prob = cumsum(n_cross_upper) / n_sim) |>
      dplyr::select(analysis, sim_upper_prob)

    # calculate the prob of crossing futility bounds
    if (design_type == "two-sided") {
      tbl_lower <- sim_tbl |>
        dplyr::filter(cross_lower == TRUE) |>
        dplyr::group_by(sim_id) |>
        dplyr::filter(dplyr::row_number() == 1) |>
        dplyr::ungroup() |>
        dplyr::group_by(analysis) |>
        dplyr::summarize(n_cross_lower = dplyr::n()) |>
        dplyr::mutate(sim_lower_prob = cumsum(n_cross_lower) / n_sim) |>
        dplyr::select(analysis, sim_lower_prob)
    }

    # combining prob of crossing efficacy and futility bounds under H1
    if (design_type == "one-sided") {
      tbl_asy_prob <- design$bound |>
        dplyr::select(analysis, probability) |>
        dplyr::rename(asy_upper_prob = probability)
    } else {
      tbl_asy_prob <- design$bound |>
        dplyr::select(analysis, bound, probability) |>
        tidyr::pivot_wider(values_from = probability, names_from = bound) |>
        dplyr::rename(asy_upper_prob = upper, asy_lower_prob = lower)
    }

    # calculate the number of analysis time, events and sample size
    suppressMessages(
      tbl_event <- object |>
        dplyr::group_by(analysis) |>
        dplyr::summarize(sim_event = mean(event),
                         sim_n = mean(n),
                         sim_time = mean(cut_date)) |>
        dplyr::right_join(design$analysis |>
                            dplyr::select(analysis, time, n, event) |>
                            dplyr::rename(asy_time = time, asy_n = n, asy_event = event))
    )
    # combine all the information together
    if (design_type == "one-sided") {
      suppressMessages(
        ans <- tbl_asy_prob |>
          dplyr::left_join(tbl_upper) |>
          dplyr::left_join(tbl_event)
      )
    } else {
      suppressMessages(
        ans <- tbl_asy_prob |>
          dplyr::left_join(tbl_upper) |>
          dplyr::left_join(tbl_lower) |>
          dplyr::left_join(tbl_event)
      )
    }

    attr(ans, "compare_with_design") <- "yes"
    attr(ans, "design_type") <- design_type
  }

  class(ans) <- c("simtrial_gs_wlr", class(ans))
  attr(ans, "method") <- attributes(object)$method

  return(ans)
}
