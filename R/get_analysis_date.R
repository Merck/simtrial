#  Copyright (c) 2023 Merck & Co., Inc., Rahway, NJ, USA and its affiliates.
#  All rights reserved.
#
#  This file is part of the simtrial program.
#
#  simtrial is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' Get the analysis date under multiple conditions
#'
#' @param simu_data A simulated data generated by sim_pw_surv()
#' @param planned_calendar_time A numerical value specifying the planned calendar time for the analysis.
#' @param target_event_overall A numerical value specifying the targeted events for the overall population.
#' @param target_event_per_stratum A numerical vector specifying the targeted events per stratum.
#' @param max_extension_for_target_event A numerical value specifying the max time extension to reach targeted events.
#' @param previous_analysis_date A numerical value specifying the previous analysis date.
#' @param min_time_after_previous_analysis A numerical value specifying the planned minimum time after the previous analysis.
#' @param enroll_rate Enrollment rates, see details and examples.
#' @param min_n_overall A numerical value specifying the minimal overall sample size enrolled to kick off the analysis.
#' @param min_n_per_stratum A numerical value specifying the minimal sample size enrolled per stratum to kick off the analysis.
#' @param min_followup A numerical value specifying the minimal follow-up time after specified enrollment fraction in min_n_overall or min_n_per_stratum.
#'
#' @return a numerical value of the analysis date
#' @export
#'
#' @examples
#' library(gsDesign2)
#' library(simtrial)
#'
#' alpha <- 0.025
#' ratio <- 3
#' n <- 500
#' info_frac <- c(0.7, 1)
#' prevelance_ratio <- c(0.4, 0.6)
#' study_duration <- 48
#'
#' # two strata
#' stratum <- c("Biomarker-positive", "Biomarker-negative")
#'
#' prevelance_ratio <- c(0.6, 0.4)
#' # enrollment rate
#' enroll_rate <- define_enroll_rate(
#'   stratum = rep(stratum, each = 2),
#'   duration = c(2, 10, 2, 10),
#'   rate =  c(c(1, 4) * prevelance_ratio[1], c(1, 4) * prevelance_ratio[2]))
#' enroll_rate$rate <- enroll_rate$rate * n / sum(enroll_rate$duration * enroll_rate$rate)
#'
#' # failure rate
#' med_pos <- 10         # median of the biomarker positive population
#' med_neg <- 8          # median of the biomarker negative population
#' hr_pos <- c(1, 0.7)   # hazard ratio of the biomarker positive population
#' hr_neg <- c(1, 0.8)   # hazard ratio of the biomarker negative population
#' fail_rate <- define_fail_rate(
#'   stratum = rep(stratum, each = 2),
#'   duration = 1000,
#'   fail_rate = c(log(2) / c(med_pos, med_pos, med_neg, med_neg)),
#'   hr = c(hr_pos, hr_neg),
#'   dropout_rate = 0.01)
#'
#' # simulate data
#' temp <- simfix2simpwsurv(fail_rate)        # transfer the failure rate
#' set.seed(2023)
#' simu_data <- sim_pw_surv(
#'   n = n,                                                            # sample size
#'   stratum = tibble(stratum = stratum, p = prevelance_ratio),        # stratified design with prevalence ratio of 6:4
#'   block =  c("control", "control", "experimental", "experimental"), # randomization ratio
#'   enroll_rate = enroll_rate,                                        # enrollment rate
#'   fail_rate = temp$fail_rate,                                       # failure rate
#'   dropout_rate = temp$dropout_rate)                                 # dropout rate
#'
#' # example 1: cut for analysis at the 24-th month.
#' get_analysis_date(
#'   simu_data,
#'   planned_calendar_time = 24)
#'
#' # example 2: cut for analysis when there are 300 events in the overall population.
#' get_analysis_date(
#'   simu_data,
#'   target_event_overall = 300)
#'
#' # example 3: cut for analysis at the 24-th month, and there are 300 events in the overall population,
#' # which arrives later.
#' get_analysis_date(
#'   simu_data,
#'   planned_calendar_time = 24,
#'   target_event_overall = 300)
#'
#' # example 4: cut for analysis when there are at least 100 events in the biomarker-positive population,
#' # and at least 200 events in the biomarker-negative population, which arrives later.
#' get_analysis_date(
#'   simu_data,
#'   target_event_per_stratum = c(100, 200))
#' get_analysis_date(
#'   simu_data,
#'   target_event_overall = 150,
#'   target_event_per_stratum = c(100, NA))
#'
#' # example 5: cut for analysis when there are at least 100 events in the biomarker positive population,
#' # and at least 200 events in the biomarker negative population, which arrives later.
#' # But will stop at the 30-th months if events less than 100/200.
#' get_analysis_date(
#'   simu_data,
#'   target_event_per_stratum = c(100, 200),
#'   max_extension_for_target_event = 30)
#'
#' # example 6: cut for analysis after 12 months followup when 80% of the patients are enrolled in the overall population.
#' get_analysis_date(
#'   simu_data,
#'   enroll_rate = enroll_rate,
#'   min_n_overall = n * 0.8,
#'   min_followup = 12)
#'
#' # example 7: cut for analysis when 12 months after at least 200/160 patients are enrolled at the
#' # biomarker positive/negative population.
#' get_analysis_date(
#'   simu_data,
#'   enroll_rate = enroll_rate,
#'   min_n_per_stratum = c(200, 160),
#'   min_followup = 12)
#' get_analysis_date(
#'   simu_data,
#'   enroll_rate = enroll_rate,
#'   min_n_per_stratum = c(200, NA),
#'   min_followup = 12)
get_analysis_date <- function(
    simu_data,
    # Option 1: planned calendar time for the analysis
    planned_calendar_time = NA,
    # Option 2: reach targeted events
    target_event_overall = NA,
    target_event_per_stratum = NA,
    # Option 3: max time extension to reach targeted events
    max_extension_for_target_event = NA,
    # Option 4: planned minimum time after the previous analysis
    previous_analysis_date = 0,
    min_time_after_previous_analysis = NA,
    # Option 5: minimal follow-up time after specified enrollment fraction
    enroll_rate = NA,
    min_n_overall = NA,
    min_n_per_stratum = NA,
    min_followup = NA
){
  # input checking
  input_check_scale <- function(x = NA, label = "x"){
    if(!is.na(x)){
      if(is.numeric(x) & x < 0){
        stop(paste0(label, " must be a positive number!"))
      } else if(!is.numeric(x)){
        stop(paste0(label, " must be a numerical value!"))
      }
    }
  }
  input_check_scale(planned_calendar_time, label = "planned_calendar_time")
  input_check_scale(target_event_overall, label = "target_event_overall")
  input_check_scale(max_extension_for_target_event, label = "max_extension_for_target_event")
  input_check_scale(min_time_after_previous_analysis, label = "min_time_after_previous_analysis")
  input_check_scale(min_n_overall, label = "min_n_overall")
  input_check_scale(min_followup, label = "min_followup")

  input_check_vector <- function(x = NA, label = "x"){
    if (!(all(is.na(x) | (is.numeric(x) & x > 0)))) {
      stop(paste0(label, " must be a positive number with either NA or positive numbers!"))
    }
  }
  input_check_vector(target_event_per_stratum)
  input_check_vector(min_n_per_stratum)

  cond1 <- inherits(enroll_rate, c("tbl_df", "data.frame")) # check if enrollment is input by user
  cond2 <- !is.na(min_n_overall)                            # check if min_n_overall is input by user
  cond3 <- !all(is.na(min_n_overall))                       # check if min_n_per_stratum is input by user
  if(cond1){
    n_max <- sum(enroll_rate$rate * enroll_rate$duration)

    if(is.na(min_followup)){
      stop("min_followup must be provided!")
    }

    if(cond2){
      if(min_n_overall > n_max){
        stop("min_n_overall should be a positive number smaller than the total sample size!")
      }
    }

    if(cond3){
      if(sum(min_n_per_stratum, na.rm = TRUE) > n_max){
        stop("min_n_per_stratum should be a sum of positive numbers smaller than the total sample size!")
      }
    }
  }

  # cutting option 1: planned calendar time for the analysis
  cut_date1 <- planned_calendar_time

  # cutting option 2:  reach targeted events
  # 2a: reach targeted events of the overall population
  if(!is.na(target_event_overall)){
    cut_date2a <- get_cut_date_by_event(simu_data, event = target_event_overall)
  } else {
    cut_date2a <- NA
  }
  # 2b: reach targeted events per sub-population
  if(!all(is.na(target_event_per_stratum))){
    stratum <- unique(simu_data$stratum)
    cut_date2b <- lapply(seq_along(target_event_per_stratum),
                         function(x){
                           get_cut_date_by_event(simu_data %>% filter(stratum == stratum[x]),
                                                 event = target_event_per_stratum[x])
                         }) %>% unlist() %>% max()
  } else {
    cut_date2b <- NA
  }
  cut_date2 <- pmax(cut_date2a, cut_date2b, na.rm = TRUE)

  # cutting option 3: max time extension to reach targeted events
  cut_date3 <- max_extension_for_target_event

  # cutting option 4: planned minimum time after the previous analysis
  cut_date4 <- previous_analysis_date + min_time_after_previous_analysis

  # cutting option 5: minimal follow-up time after specified enrollment fraction
  get_min_date <- function(enroll_rate, min_n = 400) {
    if(!is.na(min_n)){
      res <- uniroot(f = function(x){expected_accrual(time = x, enroll_rate = enroll_rate) -  min_n},
                     interval = c(0, sum(enroll_rate$duration)))
      ans <- res$root
    } else {
      ans <- NA
    }
    return(ans)
  }
  # 5a: at least 10 months after the 80% of the patients are enrolled
  if(!all(is.na(min_n_overall))){
    cut_date5a <- get_min_date(enroll_rate, min_n = min_n_overall) + min_followup
  } else {
    cut_date5a <- NA
  }
  # 5b: at least 10 months after the 80% biomarker positive patients are enrolled and 70% biomarker negative patients are enrolled
  if(!all(is.na(min_n_per_stratum))){
    cut_date5b <- lapply(seq_along(min_n_per_stratum),
                         function(x){
                           get_min_date(enroll_rate %>% filter(stratum == stratum[x]), min_n = min_n_per_stratum[x])
                         }) %>% unlist() %>% max(na.rm = TRUE) + min_followup
  } else{
    cut_date5b <- NA
  }
  cut_date5 <- pmax(cut_date5a, cut_date5b, na.rm = TRUE)

  # combining all 5 cutting options
  cut_date <- pmin(pmax(cut_date1, cut_date2, cut_date4, cut_date5, na.rm = TRUE), cut_date3, na.rm = TRUE)
  return(cut_date)
}
